<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>ChristmasDoorRegistry</name>
			<script>ChristmasDoorRegistry:handle_input(matches[1])</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^.+$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>ChristmasThiefRegistry</name>
			<script>ChristmasThiefRegistry:handle_input(matches[1])</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^.+$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
	</TriggerPackage>
	<TimerPackage>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>ChristmasDoorRegistry</name>
			<script>ChristmasDoorRegistry:trigger_hint()</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:02.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>ChristmasThiefRegistry</name>
			<script>ChristmasThiefRegistry:trigger_hint()</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:02.000</time>
		</Timer>
	</TimerPackage>
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>ChristmasDoorRegistry</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Neues Ziel erfragen</name>
				<script>---@pattern #WTneu 
ChristmasDoorRegistry:trigger_hint()
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#WTneu$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziele auflisten</name>
				<script>---@pattern #WTlist &lt;Jahr&gt;?
---@desc Liste alle Ziele fuer das Jahr auf. 
---@desc Ohne Jahr wird das aktuelle Jahr genommen. 
ChristmasDoorRegistry:all_targets(tonumber(matches[3]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#WTlist(\s(\d+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Offene Ziele auflisten</name>
				<script>---@pattern #WTlisttodo &lt;Jahr&gt;?
---@desc Liste alle unerledigten Ziele fuer das Jahr auf. 
---@desc Ohne Jahr wird das aktuelle Jahr genommen. 
ChristmasDoorRegistry:all_targets(tonumber(matches[3]), true)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#WTlisttodo(\s(\d+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel Details</name>
				<script>---@pattern #WT &lt;ID&gt;
---@desc Gib alle Details zu einem Ziel mit der ID &lt;ID&gt; an.
ChristmasDoorRegistry:single_target(tonumber(matches[2]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#WT (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel als gefunden markieren</name>
				<script>---@pattern #WTcheck &lt;ID&gt; 
ChristmasDoorRegistry:target_done(tonumber(matches[2]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#WTcheck (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel loeschen</name>
				<script>---@pattern #WTdel &lt;ID&gt; 
ChristmasDoorRegistry:delete_target(tonumber(matches[2]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#WTdel (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel Kurzhinweis aendern</name>
				<script>---@pattern #WTshort &lt;ID&gt; &lt;Inhalt&gt;
---@desc Ersetze den Kurzhinweis des Ziels &lt;ID&gt; mit &lt;Inhalt&gt;
ChristmasDoorRegistry:change_target_short(tonumber(matches[2]), matches[3])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#WTshort (\d+) (.+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziele vereinen</name>
				<script>---@pattern #WTmerge &lt;ID1&gt; &lt;ID2&gt;
---@desc Verschmelze die beiden Ziele zu einem Ziel und vereine Hinweise
ChristmasDoorRegistry:merge_targets(tonumber(matches[2]), tonumber(matches[3]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#WTmerge (\d+) (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel wieder als offen markieren</name>
				<script>---@pattern #WTcheck &lt;ID&gt; 
ChristmasDoorRegistry:open_target(tonumber(matches[2]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#WTuncheck (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel Notiz hinzufuegen/aendern</name>
				<script>---@pattern #WTnote &lt;ID&gt; &lt;Notizposition&gt; &lt;Inhalt&gt;
---@desc Falls die Notizposition groesser ist als die Liste, 
---@desc dann wird die Notiz am Ende hinzugefuegt.
---@desc Ansonsten wird die Notiz mit dem Inhalt ersetzt.
---@desc Der Inhalt kann dabei weggelassen werden um den entsprechenden
---@desc Notiz zu loeschen.
ChristmasDoorRegistry:change_target_note(tonumber(matches[2]), tonumber(matches[3]), matches[5])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#WTnote (\d+) (\d+) (\s(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziele teilen</name>
				<script>---@pattern #WTsplit &lt;ID&gt;
---@desc Zerlege eine verschmolzenen Hinweis wieder in Einzelhinweise.
ChristmasDoorRegistry:split_targets(tonumber(matches[2]), tonumber(matches[3]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#WTsplit (\d+)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>ChristmasThiefRegistry</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Neues Ziel erfragen</name>
				<script>---@pattern #PWTneu 
ChristmasThiefRegistry:trigger_hint()
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#PWTneu$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziele auflisten</name>
				<script>---@pattern #PWTlist &lt;Jahr&gt;?
---@desc Liste alle Ziele fuer das Jahr auf. 
---@desc Ohne Jahr wird das aktuelle Jahr genommen. 
ChristmasThiefRegistry:all_targets(tonumber(matches[3]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#PWTlist(\s(\d+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Offene Ziele auflisten</name>
				<script>---@pattern #PWTlisttodo &lt;Jahr&gt;?
---@desc Liste alle unerledigten Ziele fuer das Jahr auf. 
---@desc Ohne Jahr wird das aktuelle Jahr genommen. 
ChristmasThiefRegistry:all_targets(tonumber(matches[3]), true)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#PWTlisttodo(\s(\d+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel Details</name>
				<script>---@pattern #PWT &lt;ID&gt;
---@desc Gib alle Details zu einem Ziel mit der ID &lt;ID&gt; an.
ChristmasThiefRegistry:single_target(tonumber(matches[2]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#PWT (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel als gefunden markieren</name>
				<script>---@pattern #PWTcheck &lt;ID&gt; 
ChristmasThiefRegistry:target_done(tonumber(matches[2]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#PWTcheck (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel loeschen</name>
				<script>---@pattern #PWTdel &lt;ID&gt; 
ChristmasThiefRegistry:delete_target(tonumber(matches[2]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#PWTdel (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel Kurzhinweis aendern</name>
				<script>---@pattern #PWTshort &lt;ID&gt; &lt;Inhalt&gt;
---@desc Ersetze den Kurzhinweis des Ziels &lt;ID&gt; mit &lt;Inhalt&gt;
ChristmasThiefRegistry:change_target_short(tonumber(matches[2]), matches[3])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#PWTshort (\d+) (.+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziele vereinen</name>
				<script>---@pattern #PWTmerge &lt;ID1&gt; &lt;ID2&gt;
---@desc Verschmelze die beiden Ziele zu einem Ziel und vereine Hinweise
ChristmasThiefRegistry:merge_targets(tonumber(matches[2]), tonumber(matches[3]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#PWTmerge (\d+) (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel wieder als offen markieren</name>
				<script>---@pattern #PWTcheck &lt;ID&gt; 
ChristmasThiefRegistry:open_target(tonumber(matches[2]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#PWTuncheck (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel Notiz hinzufuegen/aendern</name>
				<script>---@pattern #PWTnote &lt;ID&gt; &lt;Notizposition&gt; &lt;Inhalt&gt;
---@desc Falls die Notizposition groesser ist als die Liste, 
---@desc dann wird die Notiz am Ende hinzugefuegt.
---@desc Ansonsten wird die Notiz mit dem Inhalt ersetzt.
---@desc Der Inhalt kann dabei weggelassen werden um den entsprechenden
---@desc Notiz zu loeschen.
ChristmasThiefRegistry:change_target_note(tonumber(matches[2]), tonumber(matches[3]), matches[5])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#PWTnote (\d+) (\d+) (\s(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziele teilen</name>
				<script>---@pattern #PWTsplit &lt;ID&gt;
---@desc Zerlege eine verschmolzenen Hinweis wieder in Einzelhinweise.
ChristmasThiefRegistry:split_targets(tonumber(matches[2]), tonumber(matches[3]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#PWTsplit (\d+)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>EasterEggRegistry</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Neues Ziel erfragen</name>
				<script>---@pattern #EEneu 
EasterEggRegistry:trigger_hint()
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EEneu$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziele auflisten</name>
				<script>---@pattern #EElist &lt;Jahr&gt;?
---@desc Liste alle Ziele fuer das Jahr auf. 
---@desc Ohne Jahr wird das aktuelle Jahr genommen. 
EasterEggRegistry:all_targets(tonumber(matches[3]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EElist(\s(\d+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Offene Ziele auflisten</name>
				<script>---@pattern #EElisttodo &lt;Jahr&gt;?
---@desc Liste alle unerledigten Ziele fuer das Jahr auf. 
---@desc Ohne Jahr wird das aktuelle Jahr genommen. 
EasterEggRegistry:all_targets(tonumber(matches[3]), true)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EElisttodo(\s(\d+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel Details</name>
				<script>---@pattern #EE &lt;ID&gt;
---@desc Gib alle Details zu einem Ziel mit der ID &lt;ID&gt; an.
EasterEggRegistry:single_target(tonumber(matches[2]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EE (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel als gefunden markieren</name>
				<script>---@pattern #EEcheck &lt;ID&gt; 
EasterEggRegistry:target_done(tonumber(matches[2]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EEcheck (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel loeschen</name>
				<script>---@pattern #EEdel &lt;ID&gt; 
EasterEggRegistry:delete_target(tonumber(matches[2]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EEdel (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel Kurzhinweis aendern</name>
				<script>---@pattern #EEshort &lt;ID&gt; &lt;Inhalt&gt;
---@desc Ersetze den Kurzhinweis des Ziels &lt;ID&gt; mit &lt;Inhalt&gt;
EasterEggRegistry:change_target_short(tonumber(matches[2]), matches[3])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EEshort (\d+) (.+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziele vereinen</name>
				<script>---@pattern #EEmerge &lt;ID1&gt; &lt;ID2&gt;
---@desc Verschmelze die beiden Ziele zu einem Ziel und vereine Hinweise
EasterEggRegistry:merge_targets(tonumber(matches[2]), tonumber(matches[3]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EEmerge (\d+) (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel wieder als offen markieren</name>
				<script>---@pattern #EEcheck &lt;ID&gt; 
EasterEggRegistry:open_target(tonumber(matches[2]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EEuncheck (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel Notiz hinzufuegen/aendern</name>
				<script>---@pattern #EEnote &lt;ID&gt; &lt;Notizposition&gt; &lt;Inhalt&gt;
---@desc Falls die Notizposition groesser ist als die Liste, 
---@desc dann wird die Notiz am Ende hinzugefuegt.
---@desc Ansonsten wird die Notiz mit dem Inhalt ersetzt.
---@desc Der Inhalt kann dabei weggelassen werden um den entsprechenden
---@desc Notiz zu loeschen.
EasterEggRegistry:change_target_note(tonumber(matches[2]), tonumber(matches[3]), matches[5])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EEnote (\d+) (\d+) (\s(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziele teilen</name>
				<script>---@pattern #EEsplit &lt;ID&gt;
---@desc Zerlege eine verschmolzenen Hinweis wieder in Einzelhinweise.
EasterEggRegistry:split_targets(tonumber(matches[2]), tonumber(matches[3]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EEsplit (\d+)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>PotionRegistry</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Neues Ziel erfragen</name>
				<script>---@pattern #ZTneu 
PotionRegistry:trigger_hint()
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#ZTneu$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziele auflisten</name>
				<script>---@pattern #ZTlist &lt;Jahr&gt;?
---@desc Liste alle Ziele fuer das Jahr auf. 
---@desc Ohne Jahr wird das aktuelle Jahr genommen. 
PotionRegistry:all_targets(tonumber(matches[3]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#ZTlist(\s(\d+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Offene Ziele auflisten</name>
				<script>---@pattern #ZTlisttodo &lt;Jahr&gt;?
---@desc Liste alle unerledigten Ziele fuer das Jahr auf. 
---@desc Ohne Jahr wird das aktuelle Jahr genommen. 
PotionRegistry:all_targets(tonumber(matches[3]), true)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#ZTlisttodo(\s(\d+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel Details</name>
				<script>---@pattern #ZT &lt;ID&gt;
---@desc Gib alle Details zu einem Ziel mit der ID &lt;ID&gt; an.
PotionRegistry:single_target(tonumber(matches[2]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#ZT (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel als gefunden markieren</name>
				<script>---@pattern #ZTcheck &lt;ID&gt; 
PotionRegistry:target_done(tonumber(matches[2]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#ZTcheck (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel loeschen</name>
				<script>---@pattern #ZTdel &lt;ID&gt; 
PotionRegistry:delete_target(tonumber(matches[2]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#ZTdel (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel Kurzhinweis aendern</name>
				<script>---@pattern #ZTshort &lt;ID&gt; &lt;Inhalt&gt;
---@desc Ersetze den Kurzhinweis des Ziels &lt;ID&gt; mit &lt;Inhalt&gt;
PotionRegistry:change_target_short(tonumber(matches[2]), matches[3])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#ZTshort (\d+) (.+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziele vereinen</name>
				<script>---@pattern #ZTmerge &lt;ID1&gt; &lt;ID2&gt;
---@desc Verschmelze die beiden Ziele zu einem Ziel und vereine Hinweise
PotionRegistry:merge_targets(tonumber(matches[2]), tonumber(matches[3]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#ZTmerge (\d+) (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel wieder als offen markieren</name>
				<script>---@pattern #ZTcheck &lt;ID&gt; 
PotionRegistry:open_target(tonumber(matches[2]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#ZTuncheck (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziel Notiz hinzufuegen/aendern</name>
				<script>---@pattern #ZTnote &lt;ID&gt; &lt;Notizposition&gt; &lt;Inhalt&gt;
---@desc Falls die Notizposition groesser ist als die Liste, 
---@desc dann wird die Notiz am Ende hinzugefuegt.
---@desc Ansonsten wird die Notiz mit dem Inhalt ersetzt.
---@desc Der Inhalt kann dabei weggelassen werden um den entsprechenden
---@desc Notiz zu loeschen.
PotionRegistry:change_target_note(tonumber(matches[2]), tonumber(matches[3]), matches[5])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#ZTnote (\d+) (\d+) (\s(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ziele teilen</name>
				<script>---@pattern #ZTsplit &lt;ID&gt;
---@desc Zerlege eine verschmolzenen Hinweis wieder in Einzelhinweise.
PotionRegistry:split_targets(tonumber(matches[2]), tonumber(matches[3]))
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#ZTsplit (\d+)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>WT_Help</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>WT_high_help</name>
				<script>GOR:show_help("WT")</script>
				<command></command>
				<packageName></packageName>
				<regex>^\?WT$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>WT_deep_help</name>
				<script>GOR:show_help("WT", matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^\?WT (\d+(.\d+)*)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>PWT_Help</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>PWT_high_help</name>
				<script>GOR:show_help("PWT")</script>
				<command></command>
				<packageName></packageName>
				<regex>^\?PWT$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>PWT_deep_help</name>
				<script>GOR:show_help("PWT", matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^\?PWT (\d+(.\d+)*)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>EE_Help</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>EE_high_help</name>
				<script>GOR:show_help("EE")</script>
				<command></command>
				<packageName></packageName>
				<regex>^\?EE$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>EE_deep_help</name>
				<script>GOR:show_help("EE", matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^\?EE (\d+(.\d+)*)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>ZT_Help</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>ZT_high_help</name>
				<script>GOR:show_help("ZT")</script>
				<command></command>
				<packageName></packageName>
				<regex>^\?ZT$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>ZT_deep_help</name>
				<script>GOR:show_help("ZT", matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^\?ZT (\d+(.\d+)*)$</regex>
			</Alias>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>HR_misc</name>
			<packageName></packageName>
			<script>function Advent_days()
  if os.date("%m", os.time()) &lt; "12" then
    return 24
  end
  return math.min(24, tonumber(os.date("%d", os.time())))
end

function this_year()
  return os.date("%Y", os.time())
end

function get_year(delta)
  delta = delta or 0
  local result = f"{tonumber(this_year())+delta}"
  return result
end</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>HintRegistryTemplate</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>HRT_init</name>
				<packageName></packageName>
				<script>HintRegistryTemplate = HintRegistryTemplate or MundronClassMethods:extend{
  _name="HintRegistryTemplate",
  _module="HintRegistry",
  _version="2.0.0",
  files={profile={history={}}, game={targets={}, hints={}}},
  limit=function() return math.inf end,
  _fixed_version={MundronClassMethods="1.1.0"}
}

function HintRegistryTemplate:new(spec)
  -- test for asserted fields
  for _, field in pairs({"trigger", "prefix"}) do
    assert(
      table.get(spec, {"config", field}),
      f"Missing field {field} for {spec._name}"
    )
  end
  table.set(spec, "config.data_on_demand", true)
  
  -- add file references
  for key, refs in pairs(self.files) do
    for field, default in pairs(refs) do
      table.set(spec, {key, field}, default)
    end
  end
  local object = MundronClassMethods.new(self, spec)
  object:create_aliases()
  return object
end


function HintRegistryTemplate:post_load_data()
  local pos_map, hid_map, hint_map = {}, {}, {}
  for _, target in pairs(self.data.targets) do
    for _, hid in pairs(target.hints) do
      local hint_text = self.data.hints[hid]
      if not hint_text then
        self:error(f"Ziel {target.tid} has ungueltigen Hinweis {hid}")
      end
      local normed_hint_text = normalized_text(hint_text) 
      pos_map[normed_hint_text] = target
      hint_map[normed_hint_text] = hid
      hid_map[hid] = target
    end
  end
  self.data.target_by_hint = pos_map
  self.data.target_by_hid = hid_map
  self.data.hint_by_norm = hint_map
  self:info(f"{len(self.data.targets)} Ziele mit {len(pos_map)} Beschreibungen geladen.")
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>HRT_create_aliases</name>
				<packageName></packageName>
				<script>local aliases = {
  {
    "Neues Ziel erfragen", 
    "^#{self:shortname()}neu$", 
    [[
---@pattern #{self:shortname()}neu 
{self:name()}:trigger_hint()
]]
  },
  {
    "Ziele auflisten", 
    "^#{self:shortname()}list(\\s(\\d+))?$", 
    [[
---@pattern #{self:shortname()}list &lt;Jahr&gt;?
---@desc Liste alle Ziele fuer das Jahr auf. 
---@desc Ohne Jahr wird das aktuelle Jahr genommen. 
{self:name()}:all_targets(tonumber(matches[3]))
]]
  },
  {
    "Offene Ziele auflisten", 
    "^#{self:shortname()}listtodo(\\s(\\d+))?$", 
    [[
---@pattern #{self:shortname()}listtodo &lt;Jahr&gt;?
---@desc Liste alle unerledigten Ziele fuer das Jahr auf. 
---@desc Ohne Jahr wird das aktuelle Jahr genommen. 
{self:name()}:all_targets(tonumber(matches[3]), true)
]]
  },
  {
    "Ziel Details", 
    "^#{self:shortname()} (\\d+)$", 
    [[
---@pattern #{self:shortname()} &lt;ID&gt;
---@desc Gib alle Details zu einem Ziel mit der ID &lt;ID&gt; an.
{self:name()}:single_target(tonumber(matches[2]))
]]
  },
  {
    "Ziel als gefunden markieren", 
    "^#{self:shortname()}check (\\d+)(\\s(\\d+))?$", 
    [[
---@pattern #{self:shortname()}check &lt;Ziel ID&gt; &lt;Jahr&gt;?
---@desc Markiere das Ziel mit der ID fuer das Jahr
---@desc als erledigt an. Ohne das Jahr wird das
---@desc aktuelle Jahr genommen.
---@desc Sonderfall: Bei Zaubertraenken sollte das
---@desc Jahr weggelassen werden.
{self:name()}:target_done(tonumber(matches[2]), tonumber(matches[4]))
]]
  },
  {
    "Ziel wieder als offen markieren", 
    "^#{self:shortname()}uncheck (\\d+)(\\s(\\d+))?$", 
    [[
---@pattern #{self:shortname()}check &lt;Ziel ID&gt; &lt;Jahr&gt;?
---@desc Markiere das Ziel mit der ID fuer das Jahr
---@desc wieder als offen an. Ohne das Jahr wird das
---@desc aktuelle Jahr genommen.
---@desc Sonderfall: Bei Zaubertraenken sollte das
---@desc Jahr weggelassen werden.
{self:name()}:open_target(tonumber(matches[2]), tonumber(matches[4]))
]]
  },
  {
    "Ziel loeschen", 
    "^#{self:shortname()}del (\\d+)$", 
    [[
---@pattern #{self:shortname()}del &lt;ID&gt; 
{self:name()}:delete_target(tonumber(matches[2]))
]]
  },
  {
    "Ziel Kurzhinweis aendern", 
    "^#{self:shortname()}short (\\d+) (.+)$", 
    [[
---@pattern #{self:shortname()}short &lt;ID&gt; &lt;Inhalt&gt;
---@desc Ersetze den Kurzhinweis des Ziels &lt;ID&gt; mit &lt;Inhalt&gt;
{self:name()}:change_target_short(tonumber(matches[2]), matches[3])
]]
  },
  {
    "Ziel Notiz hinzufuegen/aendern", 
    "^#{self:shortname()}note (\\d+) (\\d+) (\\s(.*))?$", 
    [[
---@pattern #{self:shortname()}note &lt;ID&gt; &lt;Notizposition&gt; &lt;Inhalt&gt;
---@desc Falls die Notizposition groesser ist als die Liste, 
---@desc dann wird die Notiz am Ende hinzugefuegt.
---@desc Ansonsten wird die Notiz mit dem Inhalt ersetzt.
---@desc Der Inhalt kann dabei weggelassen werden um den entsprechenden
---@desc Notiz zu loeschen.
{self:name()}:change_target_note(tonumber(matches[2]), tonumber(matches[3]), matches[5])
]]
  },
  {
    "Ziele vereinen", 
    "^#{self:shortname()}merge (\\d+) (\\d+)$", 
    [[
---@pattern #{self:shortname()}merge &lt;ID1&gt; &lt;ID2&gt;
---@desc Verschmelze die beiden Ziele zu einem Ziel und vereine Hinweise
---@desc und Notizen.
{self:name()}:merge_targets(tonumber(matches[2]), tonumber(matches[3]))
]]
  },
  {
    "Ziele teilen", 
    "^#{self:shortname()}split (\\d+)$", 
    [[
---@pattern #{self:shortname()}split &lt;ID&gt;
---@desc Zerlege eine verschmolzenen Hinweis wieder in Einzelhinweise.
{self:name()}:split_targets(tonumber(matches[2]))
]]
  }

}  
  
function HintRegistryTemplate:create_aliases()
  local group = self:name()
  if exists(group, "alias") == 0 then
    self:info(f"Build alias group {group}")
    permGroup(group, "alias", self._module)
  end
  for _, alias in pairs(aliases) do
    local name, regex, script = unpack(alias)
    local known = false
    for _, aid in pairs(findItems(name, "alias")) do
      known = ancestors(aid, "alias")[1].name == group
      if known then
        break
      end
    end
    if not known then
      permAlias(name, group, f(regex), f(script))
    end
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>HRT_migration</name>
				<packageName></packageName>
				<script>function HintRegistryTemplate:migrate_profile(saved_version)
  if self.version_lt(saved_version, "1.0.0") then
    MundronClassMethods.migrate_profile(HintRegistryTemplate)
    saved_version = "1.0.0"
  end
  if self.version_lt(saved_version, "2.0.0") then
    local old_history, new_history = self.pload("history"), {}
    for year, yhist in pairs(old_history) do
      new_history[year] = {}
      for _, entry in pairs(yhist) do
        local target = self.data.targets[entry._id]
        for _, hid in pairs(target.hints) do
          new_history[year][hid] = entry.done
        end
      end
    end
    self.psave(new_history, "history")
    saved_version = "2.0.0"
  end
  return saved_version
end

function HintRegistryTemplate:migrate_game(saved_version)
  if self.version_lt(saved_version, "1.0.0") then
    MundronClassMethods.migrate_game(HintRegistryTemplate)
    saved_version = "1.0.0"
  end
  if self.version_lt(saved_version, "2.0.0") then
    self.mremove("remap")
    local old_targets, new_targets, hints = self.mload(self:filename("targets")), {}, {}
    local hid = 1
    for _, target in pairs(old_targets) do
      local new_target = {tid=target._id, hints={}, notes=target.notes}
      for _, hint in pairs(target.hints) do
        table.insert(hints, hint)
        table.insert(new_target.hints, hid)
        hid = hid + 1
      end
      table.insert(new_targets, new_target)
    end
    if len(new_targets) &gt; 0 then
      self.msave(new_targets, self:filename("targets"))
      self.msave(hints, self:filename("hints"))
    end
    saved_version = "2.0.0"
  end
  return saved_version
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>HRT_misc</name>
				<packageName></packageName>
				<script>function HintRegistryTemplate:reset_reading()
  self.data.temp = ""
  disableTrigger(self:name())
  disableTimer(self:name())
end

function HintRegistryTemplate:progress(year)
  local done = 0
  year = year or this_year()
  local hist = self.data.history[year] or {}
  local year_targets = {}
  for hid, done in pairs(hist) do
    local target = self.data.target_by_hid[hid]
    if not target then
      self:error(f"Hinweis {hid} gehoert zu keinem Ziel")
    end
    local tid = target.tid
    year_targets[tid] = year_targets[tid] or done
  end
  local dones = 0
  for _, done in pairs(year_targets) do
    dones = done and dones + 1 or dones
  end
  local result = f"Fortschritt: {dones} erledigt / " ..
    f"{len(year_targets)} bekannt / {self.limit()} möglich"
  return result
end

function HintRegistryTemplate:trigger_hint()
  if not self.data then
    self:demand_data()
  end
  enableTrigger(self:name())
  send(self.config.trigger)
  disableTimer(self:name())
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>HRT_handle_input</name>
				<packageName></packageName>
				<script>function HintRegistryTemplate:handle_input(raw_input)
  local clean_input, prefix = raw_input, self.config.prefix
  if raw_input == "&gt; " then
    self:analyze_hint()
    return
  end
  
  if len(prefix) &gt; 0 then
    if not string.find(raw_input, f"^{prefix}") then
      -- false activated trigger!!!
      self:reset_reading()
      return
    end
    clean_input = raw_input:sub(len(prefix) + 1)
  end
  self.data.temp = f'{self.data.temp or ""}\n{clean_input}'
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>HRT_analyze_target</name>
				<packageName></packageName>
				<script>function HintRegistryTemplate:announce_text(tracked, is_new_hint, target)
  local result = ""
  if tracked then
    result = f"Bereits gelistetes Ziel."
  else
    result = f"Neues Ziel fuer die Liste gefunden!"
  end
  result = f"{result}\n{self:progress()}"
  if is_new_hint then
    result = f"{result}\nUnbekanntes Ziel! Id: {target.tid}"
  else
    result = f"{result}\nBekanntes Ziel. Id: {target.tid}"
  end
  self:info(result)
end

function HintRegistryTemplate:analyze_hint()
  local hint = self.data.temp
  local norm_hint = normalized_text(hint)
  local hid = self.data.hint_by_norm[norm_hint]
  local hist = table.get(self.data.history, this_year(), {})
  local target = self.data.target_by_hid[hid]
  
  if not hid then
    -- new hint, new target which was never tracked!
    table.insert(self.data.hints, hint)
    local new_hid = len(self.data.hints)
    target = {tid=len(self.data.targets)+1, hints={new_hid}, notes={}}
    table.insert(self.data.targets, target)
    
    self:announce_text(false, true, target)
    self:save_data()
    self:post_load_data()
  else
    self:announce_text(hist[hid] ~= nil, false, target)
    if hist[hid] == nil then
      hist[hid] = true
      self:save_profile()
    end
  end

  --------------------------------------------------
  -- input processed. Ask for next target?
  --------------------------------------------------
  self.data.temp = ""
  self:reset_reading()
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>HRT_display</name>
				<packageName></packageName>
				<script>function HintRegistryTemplate:get_repr(target)
  if target.repr then
    return target.repr
  end
  local hint_text = self.data.hints[target.hints[1]]
  local lines = hint_text:split("\n")
  return lines[1]
end

function HintRegistryTemplate:all_targets(year)
  if not self.data then
    self:demand_data()
  end
  year = year or this_year()
  local hist = table.get(self.data.history, year) or {}
  local size = len(history)
  local msg = f"Du hast {size} Hinweise fuer {year}"
  self:info(msg)
  local descriptions, unknown = {}, 0
  for hid, _ in pairs(hist) do
    local target = self.data.target_by_hid[hid]
    if hid &lt;= 0 then
      unknown = unknown + 1
    elseif not target then
      self:error("Ziel zum Hinweis mit der ID {hid} fehlt!")
    else
      local done = false
      for _, lhid in pairs(target.hints) do
        done = done or hist[lhid]
      end
      descriptions[target.tid] = {
        {{"Id: ", "y"}, target.tid},
        {{"Kurzhinweis: ", "y"}, self:get_repr(target)},
        {{"Erledigt: ", "y"}, done and {"Ja", "g"} or {"Nein", "r"}}
      }
    end   
  end
  local limiter = string.rep("=", 50)
  print(limiter)
  for _, tab in pairs(descriptions) do
    print_table(tab)
    print(limiter)
  end
  if unknown &gt; 0 then
    print(f"Ausserdem sind {unknown} unregistrierte Hinweise vorhanden.")    
  end
end

function HintRegistryTemplate:single_target(target_id)
  if not self.data then
    self:demand_data()
  end
  local target = self.data.targets[target_id]
  local tab = {
    {{"Id: ", "y"}, target.tid},
    {{"Kurzhinweis: ", "y"}, self:get_repr(target)},
  }
  for i, hid in pairs(target.hints) do
    local hint = self.data.hints[hid]
    local lines = hint:split("\n")
    table.insert(tab, {{f"Hinweis ({i}/{len(target.hints)}): ", "y"}, lines[1]})
    for i=2,len(lines) do
      table.insert(tab, {"", lines[i]})
    end
  end
  for i, note in pairs(target.notes) do
    local lines = note:split("\n")
    table.insert(tab, {{f"Notiz ({i}/{len(target.notes)}): ", "y"}, lines[1]})
    for i=2,len(lines) do
      table.insert(tab, {"", lines[i]})
    end
  end
  print_table(tab)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>HRT_check_target</name>
				<packageName></packageName>
				<script>local function get_hist(self, target_id, year)
  local target = self.data.targets[target_id]
  if not target then
    self:warn(f"Es gibt kein Ziel mit der ID {target_id}")
    return nil, nil
  end
  year = year or this_year()
  local hist = self.data.history[year]
  if not hist then
    self:warn(f"Ungueltiges Eingabejahr {year}")
    return nil, nil
  end
  return target, hist
end

function HintRegistryTemplate:target_done(target_id, year)
  if not self.data then
    self:demand_data()
  end
  local target, hist = get_hist(self, target_id, year)
  if not hist then
    return
  end
  
  local change, was_done = false, false
  for _, hid in pairs(target.hints) do
    was_done = was_done or hist[hid]
    if not hist[hid] then
      change = true
      hist[hid] = true
    end
  end
  if was_done then
    self:warn(f"Der Eintrag des Ziels {target_id} ist bereits erledigt.")
  else
    self:info(f"Der Eintrag des Ziels {target_id} ist nun erledigt.")
  end
  if change then
    self:save_profile()
  end
end

function HintRegistryTemplate:open_target(target_id, year)
  if not self.data then
    self:demand_data()
  end
  local target, hist = get_hist(self, target_id, year)
  if not hist then
    return
  end
  
  local was_done = false
  for _, hid in pairs(target.hints) do
    if hist[hid] then
      was_done = true
      hist[hid] = false
    end
  end
  if was_done then
    self:warn(f"Der Eintrag des Ziels {target_id} ist wieder offen.")
    self:save_profile()
  else
    self:warn(f"Der Eintrag des Ziels {target_id} war noch offen.")
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>HRT_merge_split</name>
				<packageName></packageName>
				<script>function HintRegistryTemplate:merge_targets(first_id, second_id)
  if not self.data then
    self:demand_data()
  end
  local target_one = self.data.targets[first_id]
  if not target_one then
    self:warn(f"Es gibt kein Ziel mit der ID {first_id}")
    return
  end
  local target_two = self.data.targets[second_id]
  if not target_two then
    self:warn(f"Es gibt kein Ziel mit der ID {second_id}")
    return
  end
  table.append_table(target_one.hints, target_two.hints)
  table.append_table(target_one.notes, target_two.notes)
  table.remove(self.data.targets, second_id)
  self:save_game()
  self:post_load_data()
end

function HintRegistryTemplate:split_targets(target_id)
  if not self.data then
    self:demand_data()
  end
  local target = self.data.targets[target_id]
  if not target then
    self:warn(f"Es gibt kein Ziel mit der ID {target_id}")
    return
  end
  if len(target.hints) == 1 then
    self:warn(f"Das Ziel mit der ID {target_id} besteht nur aus einem Hinweis.")
    return
  end
  local removed_hid = table.remove(target.hints, 2)
  local new_target, new_tid = {}, len(self.data.targets)
  while removed_hid do
    new_tid = new_tid + 1
    new_target = {tid=new_tid, hints={removed_hid}, notes=table.deepcopy(target.notes)}
    table.insert(self.data.targets, new_target)
    removed_hid = table.remove(target.hints, 2)
  end
  self:save_game()
  self:post_load_data()
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>HRT_change_target</name>
				<packageName></packageName>
				<script>function HintRegistryTemplate:change_target_short(target_id, content)
  if not self.data then
    self:demand_data()
  end
  local target = self.data.targets[target_id]
  if not target then
    self:warn(f"Es gibt kein Ziel mit der ID {target_id}")
    return
  end
  if not target.repr and not content then
    self:warn(f"Der Kurzhinweis ist bereits entfernt.")
    return
  end
  if target.repr and target.repr == content then
    self:warn(f"Der Kurzhinweis ist bereits auf '{content}' gesetzt.")
    return
  end
    
  if content then
    target.repr = content
    self:info(f"Aendere den Kurzhinweis zu '{content}'.")
  else
    target.repr = nil
    self:info("Loesche den Kurzhinweis")
  end
  self:save_game()
end

function HintRegistryTemplate:change_target_note(target_id, note_id, content)
  if not self.data then
    self:demand_data()
  end
  local target = self.data.targets[target_id]
  if not target then
    self:warn(f"Es gibt kein Ziel mit der ID {target_id}")
    return
  end
  if target.notes[note_id] and target.notes[note_id] == content then
    self:warn(f"Der Inhalt dieser Notiz ist bereit '{content}'")
    return
  end
    
  if len(content) &gt; 0 then
    if note_id &gt; len(target.notes) then
      table.insert(target.notes, content)
      self:info(f"Die Notiz '{content}' wurde hinzugefuegt.")
    elseif not target.notes[note_id] then
      self:warn(f"Es gibt keine Notiz an der Position {note_id}")  
      return
    else
      target.notes[note_id] = content
      self:info(f"Aendere die Notiz an der Position {note_id} zu '{content}'.")
    end
  else
    local note = table.remove_at(target.notes, note_id)
    self:info(f"Loesche die Notiz an der Position {note_id} mit dem Inhalt '{note}'")
  end
  self:save_game()
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>HRT_delete</name>
				<packageName></packageName>
				<script>function HintRegistryTemplate:delete_target(target_id)
  if not self.data then
    self:demand_data()
  end
  local target = table.remove(self.data.targets, target_id)
  if not target then
    self:warn(f"Es gibt kein Ziel mit der ID {target_id}")
    return
  end
  self:info(f"Das Ziel mit der ID {target_id} wurde geloescht")
  self:save_game()
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>ChristmasDoorRegistry</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>CDR_init</name>
				<packageName></packageName>
				<script>ChristmasDoorRegistry = ChristmasDoorRegistry or HintRegistryTemplate:new{
  _name = "ChristmasDoorRegistry",
  _shortname = "WT",
  _module = "HintRegistry",
  _version = "1.0.0",
  config = {
    prefix = "Der Weihnachtstroll sagt: ",
    trigger = "frage troll nach tuerchen"
  },
  limit = Advent_days,
  _fixed_version={MundronClassMethods="1.1.0", HintRegistryTemplate="1.0.0"}
}

WT = ChristmasDoorRegistry

function ChristmasDoorRegistry:migrate_profile(saved_version)
  if self.version_lt(saved_version, "1.0.0") then
    MundronClassMethods.migrate_profile(ChristmasDoorRegistry)
    saved_version = "1.0.0"
  end
  return saved_version
end

function ChristmasDoorRegistry:migrate_game(saved_version)
  if self.version_lt(saved_version, "1.0.0") then
    MundronClassMethods.migrate_game(ChristmasDoorRegistry)
    saved_version = "1.0.0"
  end
  return saved_version
end
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>ChristmasThiefRegistry</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>CTR_init</name>
				<packageName></packageName>
				<script>ChristmasThiefRegistry = ChristmasThiefRegistry or HintRegistryTemplate:new{
  _name = "ChristmasThiefRegistry",
  _shortname = "PWT",
  _module = "HintRegistry",
  _version = "1.0.0",
  config = {
    prefix = "Der Para-Weihnachtstroll sagt: ",
    trigger = "frage troll nach dieb"
  },
  limit = Advent_days,
  _fixed_version={MundronClassMethods="1.1.0", HintRegistryTemplate="1.0.0"}
}

PWT = ChristmasThiefRegistry

function ChristmasThiefRegistry:migrate_profile(saved_version)
  if self.version_lt(saved_version, "1.0.0") then
    MundronClassMethods.migrate_profile(ChristmasThiefRegistry)
    saved_version = "1.0.0"
  end
  return saved_version
end

function ChristmasThiefRegistry:migrate_game(saved_version)
  if self.version_lt(saved_version, "1.0.0") then
    self.mmove("PWT_remap", self:name("remap"))
    local targets = {}
    for _, target in pairs(self.mload("PWT_thieves")) do
      targets[target._id] = {
        _id = target._id,
        hints = target.descriptions,
        notes = {},
        npc_id = target.npc_id
      }
    end
    self.msave(targets, self:name("targets"))
    self.mremove("PWT_remap")
    self.mremove("PWT_thieves")
    MundronClassMethods.migrate_game(ChristmasThiefRegistry)
    saved_version = "1.0.0"
  end
  return saved_version
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>CTR_announcement</name>
				<packageName></packageName>
				<script>function ChristmasThiefRegistry:announce_text(known_target, new_target, target)
  local result = HintRegistryTemplate.announce_text(self, known_target, new_target, target)
  if target.npc_id then
    for _, npc in pairs(EK.data.npcs) do
      if npc._id == npc_id then
        result = f"{result}\nEK zugewiesen: {target.npc_id} - {npc.name} - {npc.ort} - {npc.region}"
        break  
      end
    end
  else
    result = f"{result}\nKein EK zugewiesen."
  end
  return result
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>EasterEggRegistry</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>EER_init</name>
				<packageName></packageName>
				<script>EasterEggRegistry = EasterEggRegistry or HintRegistryTemplate:new{
  _name = "EasterEggRegistry",
  _shortname = "EE",
  _module = "HintRegistry",
  _version = "1.0.0",
  config = {
    prefix = "Der Osterhase sagt: ",
    trigger = "frage hase nach ei"
  },
  limit = Advent_days,
  _fixed_version={MundronClassMethods="1.1.0", HintRegistryTemplate="1.0.0"}
}

EER = EasterEggRegistry

function EasterEggRegistry:migrate_profile(saved_version)
  if self.version_lt(saved_version, "1.0.0") then
    MundronClassMethods.migrate_profile(EasterEggRegistry)
    saved_version = "1.0.0"
  end
  return saved_version
end

function EasterEggRegistry:migrate_game(saved_version)
  if self.version_lt(saved_version, "1.0.0") then
    MundronClassMethods.migrate_game(EasterEggRegistry)
    saved_version = "1.0.0"
  end
  return saved_version
end
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>PotionRegistry</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>ZT_init</name>
				<packageName></packageName>
				<script>PotionRegistry = PotionRegistry or HintRegistryTemplate:new{
  _name = "PotionRegistry",
  _shortname = "ZT",
  _module = "HintRegistry",
  _version = "1.0.0",
  config = {
    prefix = "",
    trigger = "zaubertraenke"
  },
  limit = function() return 40 end,
  _fixed_version={MundronClassMethods="1.1.0", HintRegistryTemplate="1.0.0"}
}

ZT = PotionRegistry</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>ZT_migration</name>
				<packageName></packageName>
				<script>function PotionRegistry:migrate_profile(saved_version)
  if self.version_lt(saved_version, "1.0.0") then
    self:info("START")
    local history = {}
    for _, line in pairs(pload_csv("Zaubertraenke_History")) do
      local _id, _ = unpack(line)
      table.insert(history, {_id=_id, done=false})
    end
    self.psave({[this_year()]=history}, self:name("history"))
    premove_csv("Zaubertraenke_History")
    premove_tlines("Zaubertraenke_gefunden")
    MundronClassMethods.migrate_profile(PotionRegistry)
    saved_version = "1.0.0"
  end
  return saved_version
end

function PotionRegistry:migrate_game(saved_version)
  if self.version_lt(saved_version, "1.0.0") then
    local potions = {}
    local _id = 1
    local flag = "meta"
    local hint, note = "", ""
    for _, line in pairs(mload_tlines("Zaubertraenke")) do
      if flag == "meta" then
        if not string.startswith(line, "ZT_") then
          hint = line
          flag = "hint"
        end
      elseif flag == "hint" then
        if len(line) &gt; 0 then
          hint = f"{hint}\n{line}"
        else
          flag = "note"
        end
      elseif flag == "note" then
        if string.startswith(line, "----------") then
          table.insert(potions, {
            _id = _id,
            hints = {hint},
            notes = {note}
          })
          _id = _id + 1
          hint, note = "", ""
          flag = "meta"
        else
          note = f"{note}\n{line}"
        end
      end
    end
    self.msave(potions, self:name("targets"))
    mremove_tlines("Zaubertraenke")
    MundronClassMethods.migrate_game(PotionRegistry)
    saved_version = "1.0.0"
  end
  return saved_version
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>ZT_post_load</name>
				<packageName></packageName>
				<script>function PotionRegistry:post_load_data()
  HintRegistryTemplate.post_load_data(self)
  local history = self.data.history
  if len(history) == 0 then
    return
  elseif len(history) &gt; 1 then
    self:error("Zaubertrank History läuft über mehrere Jahre!")
  end
  local hyear, tyear = table.keys(history)[1], this_year()
  if hyear == tyear then
    return
  end
  history[tyear] = history[hyear]
  history[hyear] = nil
  self:info(f"Zaubertranke vom Jahr {hyear} nach {tyear} übertragen")
  self:save_profile()
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
