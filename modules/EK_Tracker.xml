<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>EKs lesen</name>
			<script>local found_eks = tonumber(matches[2])
local delta = found_eks - len(EK.data.known_kills) - EK.data.unknown_kills
if delta &lt; 0 then
  MainGUI.ekanzahl:echo(f"EK-Anzahl: {found_eks - delta}({delta})", "black")
elseif delta == 0 then
  MainGUI.ekanzahl:echo(f"EK-Anzahl: {found_eks}", "black")
else
  MainGUI.ekanzahl:echo(f"EK-Anzahl: {found_eks - delta}(+{delta})", "black")
end</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>(\d+)\s+verschiedene Monster getoetet,</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Gag</name>
			<script>selectCurrentLine()
deleteLine()</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Traeger dieser ehrenvollen Plakette,</string>
				<string>hat, unter absolut heroischem Einsatz</string>
				<string>seines wertvollen Lebens</string>
				<string>fuer deren Hinscheiden er mit Stufenpunkten</string>
				<string>belohnt wurde.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Plakette zurueckrichten!</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>(\w+) richtet (seine|ihre) Plakette auf Dich.$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Auslesen Teil 1</name>
			<script>if matches[2] == "ein" then
  EK.data.competitor_hasnt = 1
else
  EK.data.competitor_hasnt = tonumber(matches[2])
end
EK:save_plakettenabgleich(matches[4])</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Du hast (\w+) Monster getoetet, (das|die) (\w+) noch nicht getoetet hat.$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Auslesen Teil 2</name>
			<script>if matches[3] == "ein" then
  EK.data.player_hasnt = 1
else
  EK.data.player_hasnt = tonumber(matches[3])
end
EK:save_plakettenabgleich(matches[2])</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(\w+) hat (\w+) Monster getoetet, (das|die) Du noch nicht getoetet hast.$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Einloggen</name>
			<script>if EK and EK.config.plaketten_lesen then
  tempTimer(
    1,
    function()
      send("lies plakette")
    end
  )
end</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Verwende Deine alte sterbliche Huelle ...</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>temp</name>
			<script>
local trigger_name = "Kerbholz"

if not TRIGGER[trigger_name] or not TRIGGER[trigger_name].isOpen then   -- this checks for the first line, and initializes your variables
  TRIGGER[trigger_name] = {text="", len=1, isOpen=true}
end

TRIGGER[trigger_name].text = TRIGGER[trigger_name].text .. line .. " "   -- this appends each line, with a space added in so that you don't get words running together
TRIGGER[trigger_name].len = TRIGGER[trigger_name].len + 1   -- this keeps track of how many lines the trigger is capturing


if line:match("nichts\..*$") or line:match("stark\..*$") or line:match("leicht\..*$") then   -- this checks to see if the current line ends with "gross.", and closes things out
  TRIGGER[trigger_name].len = 0
  TRIGGER[trigger_name].isOpen = false
  tempTimer(1, function() display(TRIGGER[trigger_name].text) end)
  TRIGGER[trigger_name].text = ""
  -- do other stuff here to actually work with all the text you just captured
  -- name, place, region, creator, hint, world

  -- EK.suggestion = {matches[3], gmcp.MG.room.info.short, gmcp.MG.room.info.domain, nil, nil, 0}

  --local find_result = EK:find({name=matches[3]})
  --if not find_result or find_result == 0  then
    --iprint("Kein Eintrag gefunden. Vorschlag:", "EK-Tracker")
    --local npc_table = {
    --  {"&lt;0,255,0:0,0,0&gt;Name:", "&lt;0,255,0:0,0,0&gt;Ort:", "&lt;0,255,0:0,0,0&gt;Region:", "&lt;0,255,0:0,0,0&gt;Welt:"},
      --{EK.suggestion[1], EK.suggestion[2], EK.suggestion[3], EK.suggestion[6]}
    --}
    --echo("\n")
    --print_table(norm_table(npc_table, -1, 1))
  --end
end

--display(TRIGGER[trigger_name].len)

setTriggerStayOpen(trigger_name, TRIGGER[trigger_name].len)   -- this sets the number of lines for the trigger to capture

--setTriggerStayOpen("Kerbholz", 0)
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Du richtest Dein Kerbholz auf</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Weihnachtsdieb</name>
			<script>local input = matches[1]
local line_start = "Der Para%-Weihnachtstroll sagt:"

if not string.find(input, line_start) then
  if input == "&gt; " then
    PWT:analyse_told_thief()
  else
    -- false activated trigger!!!
    PWT:reset()
  end
else
  
  PWT:add_input(string.gsub(matches[1], "Der Para%-Weihnachtstroll sagt:", ""))
end</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^.+$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>EK-Haken bearbeiten</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>hake EK ab</name>
				<script>if #matches==2 then
	EK:check(tonumber(matches[2]))
elseif #matches==5 then
  EK:check(tonumber(matches[2]), matches[4], true)
else
  if matches[4]=="-f" then
    EK:check(tonumber(matches[2]), nil, true)
  else
    EK:check(tonumber(matches[2]), matches[4])
  end
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKcheck (\d+)(\s([^\s]+))?(\s-f)?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>entferne Haken am EK</name>
				<script>EK:uncheck(tonumber(matches[2]))</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKuncheck (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Pass Anzahl unbekannter EKs an</name>
				<script>EK:unknown(tonumber(matches[2]))</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKunknown (-?\d+)?$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>EK Infos anzeigen</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>finde EK</name>
				<script>local prop = {}

if matches[3]=="" then
  -- wird nur ein Wort als Suchbegriff eingegeben,
  -- wird automatisch nach dem Namen gesucht, da dies
  -- auch der haeufigste Fall ist.
	prop["name"] = matches[4]
else
  -- andernfalls erstellen wir ein table mit der Property
  -- als key und dem Suchbegriff als Wert.
  prop[matches[3]:lower()] = matches[4]
end

if #matches[5] &gt; 0 then
  for _,pattern in pairs(string.split(matches[5], "&amp;")) do
    if #pattern &gt; 0 then
      split_pattern = string.split(pattern, ":")
      prop[split_pattern[1]:lower()] = split_pattern[2]
    end
  end
end

EK:find_by_prop(prop)</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKfind ((\w+):)?([^:]+)((\&amp;\w+:[^:\&amp;]+)*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>liste Attribute</name>
				<script>EK:find_attr(matches[2], matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKlist (\w+):(.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>EK am Datum anzeigen</name>
				<script>EK:zeige(matches[2], matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKam (\d\d\.\d\d.\d\d)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>EK ab Datum anzeigen</name>
				<script>EK:zeige(matches[2], nil)</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKab (\d\d\.\d\d.\d\d)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>EK bis Datum anzeigen</name>
				<script>EK:zeige(nil, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKbis (\d\d\.\d\d.\d\d)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>EK zwischen Daten anzeigen</name>
				<script>EK:zeige(matches[2], matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKzwischen (\d\d\.\d\d\.\d\d) und (\d\d\.\d\d\.\d\d)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>fehlende EKs</name>
				<script>EK:missing()</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKmiss$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>zeige EK an</name>
				<script>if #matches == 2 then
  EK:find_by_id(tonumber(matches[2]))
else
  EK:find_by_range(tonumber(matches[2]), tonumber(matches[4]), matches[5])
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EK (\d+)( bis (\d+) (\w+))?$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>EK hinzufuegen/bearbeiten/loeschen</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>fuege NPC (kein EK) hinzu</name>
				<script>EK:add(matches[2], matches[3], matches[4],matches[5], matches[6], tonumber(matches[7]) or 0, true)</script>
				<command></command>
				<packageName></packageName>
				<regex>^#NPCadd ([^\|]+)\|([^\|]*)\|([^\|]*)\|([^\|]*)\|([^\|]*)\|(\d)?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>fuege EK hinzu</name>
				<script>EK:add(matches[2], matches[3], matches[4],matches[5], matches[6], tonumber(matches[7]) or 0)</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKadd ([^\|]+)\|([^\|]*)\|([^\|]*)\|([^\|]*)\|([^\|]*)\|(\d)?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>EK loeschen</name>
				<script>EK:delete(tonumber(matches[2]))</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKdel (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>EK verschieben</name>
				<script>EK:sort(tonumber(matches[2]), tonumber(matches[3]))</script>
				<command></command>
				<packageName></packageName>
				<regex>#EKmove (\d+) (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>schnelles NPC hinzufügen</name>
				<script>if matches[2] then
  EK:add(matches[2], gmcp.MG.room.info.short, gmcp.MG.room.info.domain, nil, nil, 0, true)
elseif EK.suggestion then
  table.insert(EK.suggestion, true)
  EK:add(unpack(EK.suggestion))
  EK.suggestion = nil
else
  eprint("Name oder Vorschlag fehlt fuer die schnelle Eintragung", "EK-Tracker")
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#NPCsadd(\s.+)?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>schnelles EK hinzufügen</name>
				<script>if matches[2] then
  EK:add(matches[2], gmcp.MG.room.info.short, gmcp.MG.room.info.domain, nil, nil, 0)
elseif EK.suggestion then
  EK:add(unpack(EK.suggestion))
  EK.suggestion = nil
else
  eprint("Name oder Vorschlag fehlt fuer die schnelle Eintragung", "EK-Tracker")
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKsadd(\s.+)?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>mehrere EKs bearbeiten</name>
				<script>EK:multichange(matches[2], matches[5], matches[6])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EK (\d+(\s(bis\s)?\d+)*) multichange (\w+):(.*)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ändere Angaben</name>
				<script>EK:change(tonumber(matches[2]), matches[3], matches[4])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EK (\d+) change (\w+):(.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>EK filtern und bearbeiten</name>
				<script>if matches[3] == "" then
  EK:multichange(EK:find_by_prop("name", matches[4]), matches[5], matches[6])
else
  EK:multichange(EK:find_by_prop(matches[3], matches[4]), matches[5], matches[6])
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKfilter ((\w+):)?([^:]*) change (\w+):(.*)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Plakettenvergleich</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Plaketteninfo zeigen</name>
				<script>EK:show_friend(matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#Plak (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Plaketteneintrag löschen</name>
				<script>EK:del_abgleich(tonumber(matches[2]))</script>
				<command></command>
				<packageName></packageName>
				<regex>^#Plakdel (\d+)$</regex>
			</Alias>
		</AliasGroup>
		<Alias isActive="yes" isFolder="no">
			<name>Hilfe</name>
			<script>local verbose=false
if #matches &gt; 1 then
  verbose =true
end
if verbose then
  decho("&lt;255,255,0:0,0,0&gt;#EK\n")
  echo("    Auflistung moeglicher Befehle zur Syntaxuebersicht, ohne Beschreibung\n")
else
  decho("&lt;255,255,0:0,0,0&gt;#EK -v (Befehlsliste mit kurzer Beschreibung)\n")
end
decho("&lt;255,255,0:0,0,0&gt;#EKcheck &lt;ID&gt; &lt;Datum&gt;? -f?\n")
if verbose then
  echo("   markiert als geholten EK, -f zum Ueberschreiben des Datums\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKuncheck &lt;ID&gt;\n")
if verbose then
  echo("    entfernt Markierung als geholten EK)\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EK &lt;ID&gt;\n")
if verbose then
  echo("    zeigt den NPC mit der genannten ID an\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKunknown -?&lt;Anzahl&gt;\n")
if verbose then
  echo("    Anzahl unbekannter, geholter EKs\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EK &lt;ID&gt; change &lt;Attribut&gt;:&lt;Inhalt&gt;\n")
if verbose then
  echo("    aendere Attribut bei einem NPC\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKfind &lt;Attribut&gt;:?&lt;Suchtext&gt;\n")
if verbose then
  echo("    suche nach NPC dessen Attribut das Suchtext beinhalten (case-insensitive)\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKlist &lt;Attribut&gt;:?&lt;Suchtext&gt;\n")
if verbose then
  echo("    liste alle Attribute auf, die den Suchtext beinhalten  (case-insensitive)\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKam &lt;Datum DD.MM.YY&gt;\n")
if verbose then
  echo("    alle geholten EKs an dem Datum\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKab &lt;Datum DD.MM.YY&gt;\n")
if verbose then
  echo("    alle geholten EKs ab dem Datum\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKbis &lt;Datum DD.MM.YY&gt;\n")
if verbose then
  echo("    alle geholten EKs bis dem Datum\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKzwischen &lt;Datum DD.MM.YY&gt; und &lt;Datum DD.MM.YY&gt;\n")
if verbose then
  echo("    alle geholten EKs zwischen den Daten\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKadd &lt;Name&gt;|&lt;Ort&gt;|&lt;Region&gt;|&lt;Magier&gt;|&lt;Hinweis&gt;|&lt;Para&gt;\n")
if verbose then
  echo("    fuege NPC hinzu. Felder zwischen | koennen frei bleiben, aber alle | muessen gesetzt werden.\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKdel &lt;ID&gt;\n")
if verbose then
  echo("    entferne NPC-Eintrag mit entsprechender ID\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKmove &lt;alte ID&gt; &lt;neue ID&gt;\n")
if verbose then
  echo("    tausche die IDs der beiden Eintraege\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKsadd &lt;Name&gt;?\n")
if verbose then
  echo("    ohne Parameter wird der Vorschlag vom Kerbholz gespeichert.\n")
  echo("    ansonsten wird ein Eintrag mit dem Namen und Raum+Region aus gmcp erstellt.\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EK &lt;ID&gt; change &lt;Attribut&gt;:&lt;Inhalt&gt;\n")
if verbose then
  echo("    aendert das Attribut eines Eintrags\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EK &lt;ID1&gt; &lt;ID2&gt; ... &lt;IDn&gt; multichange &lt;Attribut&gt;:&lt;Inhalt&gt;\n")
if verbose then
  echo("    aendert das Attribut aller NPCs mit den IDs gleichzeitig.\n")
  echo("    zwischen den IDs ist 'bis' moeglich um ID-Bereiche anzugeben.\n")
  echo("     z.B. #EK 100 bis 120 multichange region:Gebirge\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKmiss\n")
if verbose then
  echo("    zeigt die NPC-Eintraege, die noch offene EKs sind.\n")
end

decho("&lt;255,255,0:0,0,0&gt;#Plak &lt;Konkurentenname&gt;\n")
if verbose then
  echo("    die letzten Eintraege des Plakettenvergleichs mit Konkurenten\n")
end

decho("&lt;255,255,0:0,0,0&gt;#Plakdel &lt;Nummer&gt;\n")
if verbose then
  echo("    Loescht den Eintrag mit dieser Nummer\n")
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^#EK( -v)?$</regex>
		</Alias>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Para Weihnachtstroll Diebe</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Frage nach neuen Dieben</name>
				<script>enableTrigger("Weihnachtsdieb")
PWT.state.continue = 1
PWT.temp = ""
send("frage troll nach dieb")</script>
				<command></command>
				<packageName></packageName>
				<regex>^#PWT\ ?neu$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Liste Diebe</name>
				<script>local this_year = table.get(PWT.data.history, PWT:year(), {})

if #this_year == 0 then
  PWT:info(f"Keine Diebe fuer {PWT:year()} gefunden")
else
  PWT:info(f"Es sind {PWT:progress()} Diebe erfragt:")
  local index = 1
  for _, thief_ref in ipairs(this_year) do
    if #matches &gt; 1 or not thief_ref.done then
      local thief = PWT.data.thieves[thief_ref._id]
      if thief.npc_id == nil then
        print(f"\n{index}) Unbekannter EK:")
        for _, desc in pairs(thief.descriptions) do
          print(desc)
          print("---")
        end
      else
        print(f"\n{index}) {PWT:print_ek(EK.data.npcs[thief.npc_id])}")
      end
      print(f"   done: {thief_ref.done}")
      index = index + 1
    end
  end
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#PWT\ ?list$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Identifiziere Spruch</name>
				<script>
local ref = tonumber(matches[2])
local npc_id = tonumber(matches[3])

PWT:info(f"Identifiziere folgenden Spruch mit {json.encode(npcs)}\n{EK.diebe.list[ref]}")

PWT.data.thieves[ref].npc_id = npc_id
 </script>
				<command></command>
				<packageName></packageName>
				<regex>^#PWT\ ?id (\d+) (\d)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Suche Spruch</name>
				<script>PWT:info(f"Suche nach '{matches[2]}' normaliziert zu '{pattern}'")

local thieves = PWT:get_thieves(matches[2])

for _, thief in ipairs(thieves) do
  for _, desc in pairs(thief.descriptions) do 
    print(f"{thief._id}) ---\n{desc}")
    if thief.npc_id then
      print(f" - EK-ID: {thief.npc_id}")
    end
  end
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#PWT\s?find ([\w\s]+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Erfrage alle Diebe!</name>
				<script>enableTrigger("Weihnachtsdieb")
PWT.state.continue = 10
PWT.temp = ""
send("frage troll nach dieb")</script>
				<command></command>
				<packageName></packageName>
				<regex>^#PWT\ ?all$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Stoppe Wiederholung</name>
				<script>PWT.state.continue = false</script>
				<command></command>
				<packageName></packageName>
				<regex>^#PWT\ ?stop$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Dieb getötet</name>
				<script>local nr = tonumber(matches[2])
local this_year = PWT.data.history[PWT:year()]
this_year[nr]["done"] = true
PWT:info(f"Der {nr}.te Eintrag der Diebe ist erledigt:\n{this_year[nr].description}")</script>
				<command></command>
				<packageName></packageName>
				<regex>^#PWT\ ?check (\d+)$</regex>
			</Alias>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>EK</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>EK_init</name>
				<packageName></packageName>
				<script>function EK_init()
  return EK or MundronClassMethods:new{
    _name = "EK",
    _module = "EK_Tracker",
    _version = "1.0.0",
    config = {
      plaketten_lesen = true, 
    },
    data = {
      player_hasnt = -1, 
      competitor_hasnt = -1
    },
    files = {
      profile = {
        ["diebe.trace"] = {}, 
        known_kills = {}, 
        unknown_kills = 0, 
        competitions={}
      },
      game = {
        npcs={}, 
        ["diebe.list"]={}, 
        ["diebe.ids"]={},
      }
    }
  }
 end
 
EK = EK_init()

function EK:post_load_data()
  self:info(f"{len(self.data.npcs)} NPCs und {len(self.data.known_kills)} Kills geladen")
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>EK_helpers</name>
				<packageName></packageName>
				<script>------------------------------------------------------
--
------------------------------------------------------

function EK:kill_count()
  return len(self.data.known_kills) + self.data.unknown_kills
end

------------------------------------------------------
--
------------------------------------------------------

function EK:print_npc(position, npc)
  if not npc then
    eprint("Unzulaessiger NPC zur Anzeige uebergeben.", "EK-Tracker")
    display(npc)
    return
  end
  if len(npc) == 0 then
    iprint("Kein NPC gefunden.", "EK-Tracker")
    return
  end
  local ort = "Ort"
  local world = tonumber(npc["para"]) or 0
  ort = ort .. "(" .. world .. "):"
  if world &gt; 0 then
    ort = "&lt;255,255,0:0,0,0&gt;" .. ort
  else
    ort = "&lt;0,255,0:0,0,0&gt;" .. ort
  end
  local npc_table =
    {
      {
        "&lt;0,255,0:0,0,0&gt;Nr:",
        "&lt;0,255,0:0,0,0&gt;Name:",
        ort,
        "&lt;0,255,0:0,0,0&gt;Region:",
        "&lt;0,255,0:0,0,0&gt;Magier:",
      },
      {
        npc["position"] or "",
        npc["name"] or "",
        npc["ort"] or "",
        npc["region"] or "",
        npc["magier"] or "",
      },
    }
  table.insert(npc_table[1], "&lt;0,255,0:0,0,0&gt;Hinweis:")
  local hintlines = break_lines(npc["hinweis"] or "")
  table.insert(npc_table[2], hintlines[1])
  for i = 2, len(hintlines) do
    table.insert(npc_table[1], "")
    table.insert(npc_table[2], hintlines[i])
  end
  if npc.ek then
    table.insert(npc_table[1], "&lt;0,255,0:0,0,0&gt;Geholt:")
    local kill = self.data.known_kills[npc._id]
    if not kill then
      table.insert(npc_table[2], "&lt;255,0,0:0,0,0&gt;Nein")
    else
      if kill.date == 0 then
        table.insert(npc_table[2], "unbekannt")
      else
        table.insert(npc_table[2], os.date("%d.%m.%y", kill.date))
      end
    end
  else
    table.insert(npc_table[1], "&lt;255,255,0:0,0,0&gt;Kein EK")
    table.insert(npc_table[2], "")
  end
  echo("\n")
  print_table(norm_table(npc_table, -1, 1))
end

------------------------------------------------------
--
------------------------------------------------------

function EK:print_npc_list(npcs, prop, no_killer)
  if len(npcs) == 0 then
    iprint("Keine NPCs gefunden.", "EK-Tracker")
    return
  end
  local npc_table = {{}, {}, {}, {}}
  prop = prop or "ort"
  positions = table.keys(npcs)
  table.sort(positions)
  for _, position in pairs(positions) do
    local npc = npcs[position]
    local kill = self.data.known_kills[npc._id]
    if no_killer or (kill and kill.date &gt; -1) then
      position = "&lt;0,255,0:0,0,0&gt;" .. position
    else
      position = "&lt;255,255,0:0,0,0&gt;" .. position
    end
    local prop_title = string.title(prop)
    if prop == "ort" then
      prop_title = prop_title .. "(" .. npc["para"] .. "):"
      if npc["para"] &gt; 0 then
        prop_title = "&lt;255,200,0:0,0,0&gt;" .. prop_title
      else
        prop_title = "&lt;0,255,0:0,0,0&gt;" .. prop_title
      end
    else
      prop_title = "&lt;0,255,0:0,0,0&gt;" .. prop_title
    end
    table.insert(npc_table[1], position)
    table.insert(npc_table[2], npc["name"]:sub(1, 30))
    table.insert(npc_table[3], prop_title)
    table.insert(npc_table[4], npc[prop]:sub(1, 30))
  end
  echo("\n")
  print_table(norm_table(npc_table, {1, -1, -1, -1}, 1))
end

------------------------------------------------------
--
------------------------------------------------------

function EK:num_plus_diff(base, reference)
  if type(reference) == "nil" then
    return {tostring(base), "", ""}
  end
  local difference = base - reference
  local sign = "+"
  local diff_color = "&lt;0,255,0:0,0,0&gt;"
  if difference &lt; 0 then
    sign = ""
    -- don't change to "-", because the negative value has already the sign
    diff_color = "&lt;255,255,0:0,0,0&gt;"
  end
  return {tostring(base), diff_color, "(" .. sign .. difference .. ")"}
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>EK_list_handling</name>
				<packageName></packageName>
				<script>------------------------------------------------------
--
------------------------------------------------------

function EK:missing()
  local npcs = {}
  for position, npc in ipairs(self.data.npcs) do
    if not self.data.known_kills[npc._id] then
      npcs[position] = npc
    end
  end
  self:print_npc_list(npcs, "ort", false)
  iprint({"Es sind", {len(npcs), "ly"}, "fehlende EKs eingetragen."}, "EK-Tracker")
end

------------------------------------------------------
--
------------------------------------------------------
function EK:find_by_id(search_id)
  local npc = self.data.npcs[search_id]
  self:print_npc(search_id, npc)
end

function EK:find_by_range(start_id, end_id, prop_filter)
  if start_id &gt; end_id then
    eprint("Start ID muss kleiner sein als End ID.", "EK-Tracker")
    return
  end
  local npcs = {}
  for position, npc in ipairs(self.data.npcs) do
    if start_id &lt;= npc.position and npc.position &lt;= end_id then
      npcs[position] = npc
    end
  end
  self:print_npc_list(npcs, prop_filter)
end

function EK:find_by_prop(pattern_dict)
  local npcs = {}
  for position, npc in ipairs(self.data.npcs) do
    npc_condition = true
    for attr, value in pairs(pattern_dict) do
      if not substring(string.lower(npc[attr]), string.lower(value)) then
        npc_condition = false
        break
      end
    end
    if npc_condition then
      npcs[position]= npc
    end
  end
  self:print_npc_list(npcs)
  return npcs
end


------------------------------------------------------
--
------------------------------------------------------

function EK:check(nr, date, overwrite)
  local npc = self.data.npcs[nr]
  if npc == nil then
    eprint({"Kein NPC mit der Nummer ", {id, "y"}, " gefunden."}, "EK-Tracker")
    return
  end
  local kill = self.data.known_kills[npc._id]
  if kill then
    if overwrite then
      if date then
        local d, m, y = date:match("(%d+)\.(%d+)\.(%d+)")
        kill.date = os.time({year = 2000 + y, month = m, day = d})
      else
        kill.date = os.time()
      end
      iprint({"EK mit der Nummer ", {nr, "y"}, " hat Datumskorrektur erhalten."}, "EK-Tracker")
    else
      wprint("EK bereits erworben! Zum Ueberschreiben -f benutzen.", "EK-Tracker")
    end
  else
    if date then
      if string.lower(date) == "x" then
        date = 0
      else
        local d, m, y = date:match("(%d+)\.(%d+)\.(%d+)")
        date = os.time({year = 2000 + y, month = m, day = d})
      end
    else
      date = os.time()
    end
    self.data.known_kills[npc._id] = {name=npc.name, date=date, _id=npc._id}
    self:save_data()
    iprint({"EK mit der Nummer ", {nr, "y"}, " ist nun abgehakt."}, "EK-Tracker")
    if EK.config.plaketten_lesen then
      send("lies plakette")
    else
      MainGUI.ekanzahl:echo("EK-Anzahl: " .. self:kill_count(), "black")
    end
  end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:uncheck(nr)
  local npc = self.data.npcs[nr]
  if npc == nil then
    eprint({"Kein NPC mit der Nummer ", {nr, "y"}, " gefunden."}, "EK-Tracker")
    return
  end
  if self.data.known_kills[npc._id] then
    self.data.known_kills[npc._id] = nil
    self:save_kills()
    iprint({"Der EK mit der Nummer ", {nr, "y"}, " ist nun nicht mehr abgehakt."}, "EK-Tracker")
  else
    wprint("Der EK wurde noch nicht erworben.", "EK-Tracker")
    return
  end
  if self.data.plaketten_lesen then
    send("lies plakette")
  else
    MainGUI.ekanzahl:echo("EK-Anzahl: " .. self:kill_count(), "black")
  end
end

------------------------------------------------------
--
------------------------------------------------------


function EK:add(name, place, region, creator, hint, world, nonkillpoints)
  if not name then
    eprint("Der Eintrag muss wenigstens einen Namen haben.", "EK-Tracker")
  end
  max_id = -1
  for _, npc in pairs(self.data.npcs) do
    max_id = math.max(next_id, npc._id)
  end
  local doc = {name = name, _id = max_id + 1}
  local function add(field, value)
    if value and len(value) &gt; 0 then
      doc[field] = value
    end
  end
  add("ort", place)
  add("region", region)
  add("magier", creator)
  add("hinweis", hint)
  doc["para"] = world or 0
  doc["ek"] = not nonkillpoints
  table.insert(self.data.npcs, doc)
  iprint({{"Neu eingetragener EK:", "y"}}, "EK-Tracker")
  self:print_npc(len(self.data.npcs), doc)
  self:save_game()
end

------------------------------------------------------
--
------------------------------------------------------

function EK:find_attr(attr, sub)
  local matches = {}
  local _attr = string.lower(attr)
  local _sub = string.lower(sub)
  for _, npc in pairs(self.data.npcs) do
    if npc[_attr] and substring(string.lower(npc[_attr]), _sub) then
      matches[npc[_attr]] = true
    end
  end
  if len(matches) == 0 then
    iprint("Keine " .. string.title(attr) .. " gefunden.", "EK-Tracker")
  else
    matches = table.keys(matches)
    table.sort(matches)
    iprint("Zum '" .. attr .. "' mit '" .. sub .. "' gefunden:", "EK-Tracker")
    for i, v in ipairs(matches) do
      decho("&lt;0,255,0:0,0,0&gt;" .. i .. ": ")
      echo(v .. "\n")
    end
    echo("\n")
  end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:unknown(x)
  if not x then
    iprint(
      {"Die Anzahl unbekannter EKs ist ", {self.data.unknown_kills, "&lt;0,255,0:0,0,0&gt;"}, "."},
      "EK-Tracker"
    )
    return
  end
  local ausgabe =
    {
      "Die Anzahl unbekannter EKs aendert sich von ",
      {self.data.unknown_kills, "&lt;0,255,0:0,0,0&gt;"},
      " zu ",
    }
  self.data.unknown_kills = self.data.unknown_kills + x
  table.insert(ausgabe, {self.data.unknown_kills, "&lt;0,255,0:0,0,0&gt;"})
  table.insert(ausgabe, ".")
  self:save_data()
  iprint(ausgabe, "EK-Tracker")
  if self.config.plaketten_lesen then
    send("lies plakette")
  else
    MainGUI.ekanzahl:echo("EK-Anzahl: " .. self:kill_count(), "black")
  end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:zeige(von, bis)
  if von then
    local d, m, y = von:match("(%d+)\.(%d+)\.(%d+)")
    von = os.time({year = 2000 + y, month = m, day = d})
  else
    von = 0
  end
  if bis then
    -- we like to get all kill entries even
    -- for the chosen day. So, the upper limit
    -- has to be extended for a day
    local d, m, y = bis:match("(%d+)\.(%d+)\.(%d+)")
    bis = os.time({year = 2000 + y, month = m, day = d}) + 24 * 60 * 60
  else
    bis = os.time() + 24 * 60 * 60
  end
  local npcs = {}
  for position, npc in ipairs(self.data.npcs) do
    date = (self.data.known_kills[npc._id] or {}).date
    if date and von &lt;= date and date &lt;= bis then
      npcs[position] = npc
    end
  end
  self:print_npc_list(npcs)
  iprint({"Es wurden ", {len(npcs), "y"}, " NPCs gefunden."}, "EK-Tracker")
end

------------------------------------------------------
--
------------------------------------------------------

function EK:delete(nr)
  if self.state.del_flag and self.state.del_flag.nr == nr then
    table.remove(self.data.npcs, nr)
    for pos, npc in ipairs(self.data.npcs) do
      if pos &gt;= nr then
        npc.position = pos
      end
    end
    self.state.del_flag = nil
    self:save_game()
    iprint("Der EK wurde geloescht.", "EK-Tracker")
  else
    local npc = self.data.npcs[nr]
    if not npc then
      iprint("Es wurde kein NPC mit der Nummer " .. nr .. " gefunden.", "EK-Tracker")
      return
    end
    iprint(
      "Moechtest du folgenden EK aus der Liste loeschen? Falls ja, wiederhole den Befehl!",
      "EK-Tracker"
    )
    self:print_npc(nr, npc)
    self.state.del_flag = {nr = nr}
  end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:sort(old_nr, new_nr)
  if old_nr &lt; 1 or old_nr &gt; len(self.data.npcs) or new_nr &lt; 1 or new_nr &gt; len(self.data.npcs) then
    eprint("Unzulaessige Positionen " .. old_nr .. " oder " .. new_nr .. ".", "EK-Tracker")
    return
  end
  local temp = self.data.npcs[old_nr]
  if old_nr &gt; new_nr then
    for i = old_nr, new_nr + 1, -1 do
      self.data.npcs[i] = self.data.npcs[i - 1]
      self.data.npcs[i].position = i
    end
  else
    for i = old_nr, new_nr - 1, 1 do
      self.data.npcs[i] = self.data.npcs[i + 1]
      self.data.npcs[i].position = i
    end
  end
  temp.position = new_nr
  self.data.npcs[new_nr] = temp
  self:save_game()
  iprint(
    "Der NPC an der Stelle " .. old_nr .. " wurde nun an die Stelle " .. new_nr .. " gesteckt.",
    "EK-Tracker"
  )
end

------------------------------------------------------
--
------------------------------------------------------

function EK:change(nr, attr, content)
  local position = tonumber(nr)
  attr = string.lower(attr)
  if not position then
    eprint({"Die Eingabe", {nr, "y"}, "ist keine Zahl."}, "EK-Tracker")
    return
  end
  if self.state.change_flag and self.state.change_flag.npc.position == position then
    self.state.change_flag.npc[attr] = self.state.change_flag.change
    echo("\nDas Attribut ")
    decho("&lt;0,255,0:0,0,0&gt;" .. string.title(attr))
    echo(" wurde zu \n")
    decho("&lt;0,255,0:0,0,0&gt;" .. content)
    echo("\ngeaendert.\n\n")
    self:print_npc(self.state.change_flag.position, self.state.change_flag.npc)
    self.state.change_flag = nil
    self:save_game()
  else
    if attr == "para" then
      local num = tonumber(content)
      if num and num &gt; -1 then
        content = num
      else
        eprint(
          "Die Welt/Parallelwelt muss eine ganze Zahl groesser oder gleich 0 sein.", "EK-Tracker"
        )
      end
    end
    local npc = self.data.npcs[nr]
    if npc == nil then
      iprint({"Es konnte kein NPC mit der ID", {id, "y"}, "gefunden werden."}, "EK-Tracker")
      return
    end
    echo("Willst du bei ...\n\n")
    self:print_npc(nr, npc)
    echo("\n... wirklich das Attribut ")
    decho("&lt;0,255,0:0,0,0&gt;" .. string.title(attr))
    echo(" zu \n")
    decho("&lt;0,255,0:0,0,0&gt;" .. content)
    echo("\naendern? Falls ja, dann wiederhole den Befehl.\n\n")
    self.state.change_flag = {npc = npc, position=nr, change = content}
  end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:multichange(ids, attr, content)
  attr = string.lower(attr)
  if self.state.mchange_flag and self.state.mchange_flag.ids == ids then
    for _, npc in pairs(self.state.mchange_flag.npcs) do
      npc[attr] = self.state.mchange_flag.change
    end
    echo("\nDas Attribut ")
    decho("&lt;0,255,0:0,0,0&gt;" .. string.title(attr))
    echo(" wurde zu \n")
    decho("&lt;0,255,0:0,0,0&gt;" .. content)
    echo("\ngeaendert:\n")
    self:print_npc_list(self.state.mchange_flag.npcs, attr)
    self.state.mchange_flag = nil
    self:save_game()
  else
    if attr == "para" then
      local num = tonumber(content)
      if num and num &gt; -1 then
        content = num
      else
        eprint(
          "Die Welt/Parallelwelt muss eine ganze Zahl groesser oder gleich 0 sein.", "EK-Tracker"
        )
      end
    end
    local id_list = {}
    for von, bis in ids:gmatch("(%d+) bis (%d+)") do
      for i = von, bis, 1 do
        table.insert(id_list, i)
      end
    end
    shorten_ids = ids:gsub("(%d+) bis (%d+)", "")
    for id in shorten_ids:gmatch("%d+") do
      table.insert(id_list, tonumber(id))
    end
    local npcs = {}
    for _, id in pairs(id_list) do
      npcs[id] = self.data.npcs[id]
    end
    if len(npcs) == 0 then
      iprint({"Es konnte kein NPCs mit den IDs", {ids, "y"}, "gefunden werden."}, "EK-Tracker")
      return
    end
    echo("Willst du bei ...\n\n")
    self:print_npc_list(npcs, attr)
    echo("\n... wirklich das Attribut ")
    decho("&lt;0,255,0:0,0,0&gt;" .. string.title(attr))
    echo(" zu \n")
    decho("&lt;0,255,0:0,0,0&gt;" .. content)
    echo("\naendern? Falls ja, dann wiederhole den Befehl.\n\n")
    self.state.mchange_flag = {ids = ids, npcs = npcs, change = content}
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>EK_plaketten_handling</name>
				<packageName></packageName>
				<script>------------------------------------------------------
--
------------------------------------------------------

function EK:save_plakettenabgleich(name)
  echo(
    "\n\nCompetitor: " ..
    name ..
    " is missing " ..
    self.data.player_hasnt ..
    " and has " ..
    self.data.competitor_hasnt ..
    "\n\n"
  )
  if self.data.player_hasnt &gt; -1 and self.data.competitor_hasnt &gt; -1 then
    name = name:lower()
    table.insert(
      self.data.competitions,
      {
        player_count = self:kill_count(),
        player_hasnt = self.data.player_hasnt,
        date = os.time(),
        competitor_name = name,
        competitor_count = self:kill_count() - self.data.competitor_hasnt + self.data.player_hasnt,
        competitor_hasnt = self.data.competitor_hasnt,
      }
    )
    self.data.player_hasnt = -1
    self.data.competitor_hasnt = -1
    self:save_data()
    self:show_friend(name)
  end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:del_abgleich(nr)
  if nr &lt; 1 or nr &gt; len(self.data.competitions) then
    eprint("Ungueltige Nummer " .. nr .. ".", "EK-Tracker")
    return
  end
  if self.state.pdel_flag and self.state.pdel_flag.nr == nr then
    table.remove(self.data.competitions, nr)
    self.state.pdel_flag = nil
    self:save_data()
    iprint("Plakettenvergleichseintrag geloescht.", "EK-Tracker")
  else
    iprint({"Willst du wirklich den Eintrag mit der Nummer ", {nr, "y"}, "loeschen?"}, "EK-Tracker")
    self:show_friend(nr)
    iprint("Falls ja, dann wiederhole den Befehl.", "EK-Tracker")
    self.state.pdel_flag = {nr = nr}
  end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:show_friend(arg)
  local entries = {}
  local name = arg
  if type(arg) == "number" then
    if arg &lt; 1 or arg &gt; len(self.data.competitions) then
      eprint("Ungueltige Nummer " .. nr .. ".", "EK-Tracker")
      return
    end
    entries = {self.data.competitions[arg]}
    entries[1]._row_id = arg
    if len(entries) &gt; 0 then
      name = string.title(entries[1]["competitor_name"])
    end
  else
    arg = string.lower(arg)
    local cnt = 3
    local entry
    for i = len(self.data.competitions), 1, -1 do
      entry = self.data.competitions[i]
      if entry.competitor_name == arg then
        entry._row_id = i
        table.insert(entries, 1, entry)
        cnt = cnt - 1
      end
      if cnt == 0 then
        break
      end
    end
  end
  if len(entries) == 0 then
    iprint("Es wurden keine Eintraege gefunden.", "EK-Tracker")
    return
  end
  echo("\n\n")
  local tab = {}
  table.insert(
    tab,
    norm_length(
      {
        "ID:",
        "",
        "",
        "",
        "Deine EKs:",
        "EKs von " .. name .. ":",
        "Dir fehlen:",
        name .. " fehlen:",
      },
      1
    )
  )
  local previous_entry = {}
  local keys = {"player_count", "competitor_count", "player_hasnt", "competitor_hasnt"}
  for _, entry in pairs(entries) do
    local date = os.date("%d.%m.%y", entry["date"])
    local time = os.date("%H:%M", entry["date"])
    local values = {}
    local max_diff_len = 0
    for _, key in pairs(keys) do
      table.insert(values, EK:num_plus_diff(entry[key], previous_entry[key]))
      max_diff_len = math.max(max_diff_len, #values[#values][3])
    end
    for i, v in pairs(values) do
      local spaces = " "
      for _ = 1, max_diff_len - #v[3], 1 do
        spaces = spaces .. " "
      end
      values[i] = v[1] .. spaces .. v[2] .. v[3]
    end
    table.insert(
      tab,
      norm_length({entry["_row_id"] .. " ", date .. " ", time .. " ", "", unpack(values)}, 1, 2)
    )
    previous_entry = entry
  end
  print_table(tab)
  echo("\n")
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>EK_no_badge_for_small_players</name>
				<packageName></packageName>
				<script>function EK_no_badge_for_small_players()
  -- nicht-Seher haben eh keine Plakette und damit muessen
  -- Spielanfaenger erstmal sich nicht um diese
  -- Einstellung kuemmern
  EK.config.plakette_lesen = gmcp.MG.char.base.wizlevel ~= 0
end</script>
				<eventHandlerList>
					<string>gmcp.MG.char.base</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>EK_generic_migration</name>
				<packageName></packageName>
				<script>function EK:migrate_game(saved_version)
  if saved_version &lt; "1.0.0" then
    local npcs = mload_jsonl("EK_NPC_liste")
    msave_json(npcs, self:name("npcs"))
    mremove_jsonl("EK_NPC_liste")
    self:info(f"Migration von Spieldaten auf Version 1.0.0 mit {len(npcs)} NPCs erledigt")
  end
end

function EK:migrate_profile(saved_version)
  if saved_version &lt; "1.0.0" then
    pmove_json("EK_pwt_diebe_trace", self:name("diebe.trace"))
    local competitions = pload_jsonl("EK_Plakettenvergleich")
    psave_json(competitions, self:name("competitions"))
    premove_jsonl("EK_Plakettenvergleich")
    
    local kills = pload_jsonl("EK_Kills")
    local new_kills = {}
    local unknown_kills = 0
    for _, kill in pairs(kills) do
      if kill._id then
        new_kills[kill._id] = kill
      else
        unknown_kills = unknown_kills + 1
      end
    end
    psave_json(new_kills, self:name("known_kills"))
    psave_json(unknown_kills, self:name("unknown_kills"))
    premove_jsonl("EK_Kills")
    self:info("Migration von Profildaten auf Version 1.0.0 mit {len(new_kills)} bekannten und {unknown_kills} unbekannten Kills erledigt")
  end
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>PWT</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>PWT_init</name>
				<packageName></packageName>
				<script>function PWT_init()
  return PWT or MundronClassMethods:new{
    _name = "PWT",
    _module = "EK_Tracker",
    _version = "1.0.0",
    files = {
      profile = {
        history = {}
      },
      game = {
        thieves = {},
        remap = {}
      }
    },
    temp = "",
    state = {
      continue = 0
    }
  }
end

PWT = PWT or PWT_init()

function PWT:post_load_data()
  disableTrigger("Weihnachtsdieb")
  local pos_map, id_map = {}, {}
  for _, thief in pairs(self.data.thieves) do
    for _, desc in pairs(thief.descriptions) do
      pos_map[normalized_text(desc)] = thief
    end
    id_map[thief._id] = thief
  end
  self.data.thief_by_desc = pos_map
  self.data.thief_by_id = id_map
  self:info(
    f"{len(self.data.thieves)} Diebe mit {len(pos_map)} Beschreibungen geladen" ..
    f" und {len(self.data.history)} Jahre an Daten."
  )
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>PWT_function</name>
				<packageName></packageName>
				<script>function PWT:get_thieves(description)
  local pattern = normalized_text(description)
  local result = {}
  for _, thief in pairs(self.data.thieves) do
    for _, desc in pairs(thief.descriptions) do
      PWT:log(normalized_text(desc))
      if string.find(normalized_text(desc), pattern) then
        PWT:log(" ---&gt; match!")
        table.insert(result, thief)
      end
    end
  end
  return result
end

function PWT:reset()
  self.state.continue = 0
  self.temp = ""
  disableTrigger("Weihnachtsdieb")
end

function PWT:next_id()
  return self.data.thieves[len(self.data.thieves)]._id + 1
end

function PWT:progress()
  local killed = 0
  for _, thief_ref in pairs(self.data.history[PWT:year()]) do
    if thief_ref.done then
      killed = killed + 1
    end
  end
  local result = f"Fortschritt: {killed} erledigt / " ..
    f"{len(self.data.history[PWT:year()])} bekannt / {self:days()} möglich"
  return result
end

function PWT:days()
  local year = os.date("%Y", os.time())
  local month = os.date("%m", os.time())
  if month &lt; "12" then
    return 24
  else
    return math.min(24, tonumber(os.date("%d", os.time())))
  end
end

function PWT:year()
  local year = os.date("%Y", os.time())
  local month = os.date("%m", os.time())
  if month &lt; "12" then
    return ""..(tonumber(year)-1)
  else
    return year
  end
end

function PWT:display_ek(npc_ids)
  if npc_ids == nil then
    return ""
  elseif type(npc_ids) == "table" then
    local text = ""
    for _, npc_id in ipairs(npc_ids) do
        text = text.."\n"..self:print_ek(npc_id)
    end
    return text
  else
    return self:print_ek(npc_ids)
  end
end

function PWT:print_ek(ek)
  local result = f"{EK.data.npcs[ek].name}\n   -&gt; EK Nummer {ek}, killed = {EK.data.known_kills[ek] ~= nil}"
  return result
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>PWT_analyse_told_thief</name>
				<packageName></packageName>
				<script>function PWT:add_input(input)
  self.temp = f'{self.temp or ""}{input}' 
end

local function announce(known_thief, new_thief, thief)
  local result = ""
  if known_thief then
    result = f"Bereits genannter Dieb fuer {PWT:year()}."
  else
    result = f"Neuen Dieb fuer {PWT:year()} gefunden!"
  end
  result = f"{result}\n{PWT:progress()}"
  if new_thief then
    result = f"{result}\nUnbekannter Dieb! Id: {thief._id}"
  elseif thief.npc_id then
    result = f"{result}\nBekannter Dieb und EK:\n{PWT:display_ek(thief.npc_id)}"
  else
    result = f"{result}\nBekannter Dieb, aber EK-Zuweisung fehlt."
  end
  PWT:info(result)
end

function PWT:analyse_told_thief()
  local desc = self.temp
  local norm_desc = normalized_text(desc)
  local this_year = table.get(self.data.history, self:year(), {})
  local thief = self.data.thief_by_desc[norm_desc]
  
  local change_to_save = false
  if thief then
    -- there is such a thief registered. But still have to check if it was seen this year!
    local seen=false
    for _, thief_ref in pairs(this_year) do
      if thief_ref._id == thief._id then
        seen = true
        break
      end
    end
    if not seen then
      table.insert(this_year, {_id=thief._id, done=false})
      change_to_save = true
    end
    announce(seen, false, thief)
  else
    -- new description, new thief which was never tracked!
    local new_thief = {_id=self:next_id(), descriptions={desc}}
    table.insert(self.data.thieves, new_thief)
    table.insert(this_year, {_id=new_thief._id, done=false})
    self.data.thief_by_desc[norm_desc] = new_thief
    change_to_save = true
    announce(false, true, new_thief)
  end
  
  if change_to_save then
    self:save_data()
  end
  --------------------------------------------------
  -- input processed. Ask for next thief?
  --------------------------------------------------
  self.temp = ""
  self.state.continue = math.max(self.state.continue - 1, 0)
  if self.state.continue &gt; 0 and len(this_year) &lt; 24 then
  --if self.state.continue &gt; 0 and len(this_year) &lt; self:days() then
    tempTimer(0.5, [[ send("frage troll nach dieb") ]])
  else
    self:reset()
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>PWT_generic_migration</name>
				<packageName></packageName>
				<script>function PWT:migrate_game(saved_version)
  if saved_version &lt; "1.0.0" then
    local details = mload_json("EK_pwt_diebe_liste", mload_json("EK_diebe_list"))
    local ids = mload_json("EK_pwt_diebe_ids", mload_json("EK_diebe_ids"))
    local thieves = {}
    local index = 1
    for detail, npc_id in pairs(ids) do
      table.insert(thieves, {
        _id=index,
        name = EK.data.npcs[_id],
        npc_id = npc_id,
        descriptions = {detail}
      })
      index = index + 1
      table.remove_value(details, detail)
    end
    for _, detail in ipairs(details) do
      table.insert(thieves, {
        _id=index,
        descriptions = {detail}
      })
      index = index + 1
    end
    msave_json(thieves, self:name("thieves"))
    mremove_json("EK_pwt_diebe_liste")
    mremove_json("EK_diebe_list")
    mremove_json("EK_pwt_diebe_ids")
    mremove_json("EK_diebe_ids")
    self:info(f"Migration der Spieldaten auf Version 1.0.0 mit {len(thieves)} Dieben erledigt")
  end
end

function PWT:migrate_profile(saved_version)
  if saved_version &lt; "1.0.0" then
    local old_history = pload_json("EK_pwt_diebe_trace", pload_json("EK_diebe_trace"))
    if len(old_history) == 0 then
      return
    end
    local history = {}
    for year, old_thieves in pairs(old_history) do
      for _, old_thief in pairs(old_thieves) do
        local found_thieves = self:get_thieves(old_thief.detail)
        local _id
        if len(found_thieves) &gt; 1 then
          printError(f"Detail {old_thief.detail} found to many thieves!")
        end
        if len(found_thieves) == 0 then
          _id = self.next_id()
          table.insert(self.data.thieves, {_id=_id, descriptions={old_thief.detail}})
        else
          _id = found_thieves[1]._id
        end
        table.insert(table.get(history, year, {}), {_id=_id, done=old_thief.done})
      end
    end
    psave_json(history, self:name("history"))
    msave_json(self.data.thieves, self:name("thieves"))
    self:info(f"Migration der Profildaten auf Version 1.0.0 mit einer History von {len(history)} Eintraegen erledigt")
  end
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
