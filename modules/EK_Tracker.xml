<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>EKs lesen</name>
			<script>EK.data.plate_number = tonumber(matches[2])
MainGUI:update_label("kills")</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>(\d+)\s+verschiedene Monster getoetet,</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Gag</name>
			<script>selectCurrentLine()
deleteLine()</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Traeger dieser ehrenvollen Plakette,</string>
				<string>hat, unter absolut heroischem Einsatz</string>
				<string>seines wertvollen Lebens</string>
				<string>fuer deren Hinscheiden er mit Stufenpunkten</string>
				<string>belohnt wurde.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Plakette zurueckrichten!</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>(\w+) richtet (seine|ihre) Plakette auf Dich.$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Auslesen Teil 1</name>
			<script>if matches[2] == "ein" then
  EK.data.competitor_hasnt = 1
else
  EK.data.competitor_hasnt = tonumber(matches[2])
end
EK:save_plakettenabgleich(matches[4])</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Du hast (\w+) Monster getoetet, (das|die) (\w+) noch nicht getoetet hat.$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Auslesen Teil 2</name>
			<script>if matches[3] == "ein" then
  EK.data.player_hasnt = 1
else
  EK.data.player_hasnt = tonumber(matches[3])
end
EK:save_plakettenabgleich(matches[2])</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(\w+) hat (\w+) Monster getoetet, (das|die) Du noch nicht getoetet hast.$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Einloggen</name>
			<script>if EK and table.get(EK, "data.tracking") then
  tempTimer(1, function() send("lies plakette") end)
end</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Verwende Deine alte sterbliche Huelle ...</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>temp</name>
			<script>
local trigger_name = "Kerbholz"

if not TRIGGER[trigger_name] or not TRIGGER[trigger_name].isOpen then   -- this checks for the first line, and initializes your variables
  TRIGGER[trigger_name] = {text="", len=1, isOpen=true}
end

TRIGGER[trigger_name].text = TRIGGER[trigger_name].text .. line .. " "   -- this appends each line, with a space added in so that you don't get words running together
TRIGGER[trigger_name].len = TRIGGER[trigger_name].len + 1   -- this keeps track of how many lines the trigger is capturing


if line:match("nichts\..*$") or line:match("stark\..*$") or line:match("leicht\..*$") then   -- this checks to see if the current line ends with "gross.", and closes things out
  TRIGGER[trigger_name].len = 0
  TRIGGER[trigger_name].isOpen = false
  tempTimer(1, function() display(TRIGGER[trigger_name].text) end)
  TRIGGER[trigger_name].text = ""
  -- do other stuff here to actually work with all the text you just captured
  -- name, place, region, creator, hint, world

  -- EK.suggestion = {matches[3], gmcp.MG.room.info.short, gmcp.MG.room.info.domain, nil, nil, 0}

  --local find_result = EK:find({name=matches[3]})
  --if not find_result or find_result == 0  then
    --iprint("Kein Eintrag gefunden. Vorschlag:", "EK-Tracker")
    --local npc_table = {
    --  {"&lt;0,255,0:0,0,0&gt;Name:", "&lt;0,255,0:0,0,0&gt;Ort:", "&lt;0,255,0:0,0,0&gt;Region:", "&lt;0,255,0:0,0,0&gt;Welt:"},
      --{EK.suggestion[1], EK.suggestion[2], EK.suggestion[3], EK.suggestion[6]}
    --}
    --echo("\n")
    --print_table(norm_table(npc_table, -1, 1))
  --end
end

--display(TRIGGER[trigger_name].len)

setTriggerStayOpen(trigger_name, TRIGGER[trigger_name].len)   -- this sets the number of lines for the trigger to capture

--setTriggerStayOpen("Kerbholz", 0)
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Du richtest Dein Kerbholz auf</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>EK</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Tracking ein/ausschalten</name>
				<script>---@pattern #EKtrack
---@desc Falls das Tracking eingeschaltet ist, 
---@desc wird es ausgeschaltet und umgekehrt.

EK.data.tracking = not EK.data.tracking
EK:save_profile("tracking")
local msg = f"Das Tracking von EKs ist jetzt {EK.data.tracking and 'eingeschaltet' or 'ausgeschaltet}"
EK:info(msg)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKtrack$</regex>
			</Alias>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Infos&amp;Details</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Suche EK nach Namen</name>
					<script>---@pattern #EKfind &lt;Name&gt;
---@desc Man erhaelt alle EKs, dessen Name die Eingabe enthalten.
---@desc Beispiel: #EKfind Santa -&gt; "Santa Claus" oder "Santa Maria"

EK:find_by_prop({name=matches[2]})</script>
					<command></command>
					<packageName></packageName>
					<regex>^#EKfind (\w+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Komplexe Suche nach EK über Eigenschaften</name>
					<script>---@pattern #EKfind &lt;Feld&gt;:&lt;Wert&gt;(&amp;&lt;Feld&gt;:&lt;Wert&gt;)*
---@desc Man kann beliebig viele &lt;Feld&gt;:&lt;Wert&gt; Kombinationen durch &amp; getrennt
---@desc angeben um die Suche zu spezifieren. Die Ergebnisse muessen ALLE
---@desc Kriterien erfuellen!

local prop = {}

for _,pattern in pairs(matches[2]:split("&amp;")) do
  field, value = unpack(pattern:split(":"))
  prop[field:lower()] = value
end

EK:find_by_prop(prop)</script>
					<command></command>
					<packageName></packageName>
					<regex>^#EKfind (\w+:\w+(\&amp;\w+:\w+)*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Liste Attribute</name>
					<script>---@pattern #EKlist &lt;Feld&gt;:&lt;Wert&gt;
---@desc Listet alle Werte auf, die das Feld &lt;Feld&gt; haben kann und 
---@desc &lt;Wert&gt; beinhalten. Dabei kann &lt;Wert&gt; auch leer sein.
---@desc Bsp: #EKlist ort: -&gt; Listet ALLE Werte auf, die in Ort stehen
---@desc      #EKlist ort:insel -&gt; Listet alle Werte auf, die in Ort stehen
---@desc                           und "insel" beinhalten.
EK:find_attr(matches[2], matches[3])</script>
					<command></command>
					<packageName></packageName>
					<regex>^#EKlist (\w+):(.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Liste EKs von einem Tag auf</name>
					<script>---@pattern #EKam &lt;Tag&gt;.&lt;Monat&gt;.&lt;Jahr&gt;
---@desc Listet alle EKs auf, die an !!diesem!! Tag erledigt wurden
---@desc Tag und Monat kann ein oder zweistellig sein.
---@desc Das Jahr ist vierstellig oder ab 2000 auch wahlweise zweistellig.

EK:zeige(matches[2], matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^#EKam (\d+\.\d+.\d+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Liste EKs ab einem Tag auf</name>
					<script>---@pattern #EKam &lt;Tag&gt;.&lt;Monat&gt;.&lt;Jahr&gt;
---@desc Listet alle EKs auf, die !!ab diesem!! Tag erledigt wurden
---@desc Tag und Monat kann ein oder zweistellig sein.
---@desc Das Jahr ist vierstellig oder ab 2000 auch wahlweise zweistellig.

EK:zeige(matches[2], nil)</script>
					<command></command>
					<packageName></packageName>
					<regex>^#EKab (\d+\.\d+.\d+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Liste EKs bis einem Tag auf</name>
					<script>---@pattern #EKam &lt;Tag&gt;.&lt;Monat&gt;.&lt;Jahr&gt;
---@desc Listet alle EKs auf, die !!bis zu diesem!! Tag erledigt wurden
---@desc Tag und Monat kann ein oder zweistellig sein.
---@desc Das Jahr ist vierstellig oder ab 2000 auch wahlweise zweistellig.

EK:zeige(nil, matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^#EKbis (\d+\.\d+.\d+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Liste EKs zwischen zwei Daten</name>
					<script>---@pattern #EKzwischen &lt;Start&gt; und &lt;Ende&gt;
---@desc &lt;Start&gt; und &lt;Ende&gt; sind dabei ein Datum im Format &lt;Tag&gt;.&lt;Monat&gt;.&lt;Jahr&gt;
---@desc Tag und Monat kann ein oder zweistellig sein.
---@desc Das Jahr ist vierstellig oder ab 2000 auch wahlweise zweistellig.

EK:zeige(matches[2], matches[3])</script>
					<command></command>
					<packageName></packageName>
					<regex>^#EKzwischen (\d+\.\d+.\d+) und (\d+\.\d+.\d+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Liste nicht erledigte EKs</name>
					<script>---@pattern #EKmiss

EK:missing()</script>
					<command></command>
					<packageName></packageName>
					<regex>^#EKmiss$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Details zum EK</name>
					<script>---@pattern #EK &lt;id&gt;

EK:find_by_id(tonumber(matches[2]))</script>
					<command></command>
					<packageName></packageName>
					<regex>^#EK (\d+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Details zu einer Liste von EK</name>
					<script>---@pattern #EK &lt;von-ID&gt; bis &lt;bis-ID&gt; &lt;Feld&gt;
---@desc Eine Eingabe von einem Feld fuer eine kompakte Darstellung ist noetig

EK:find_by_range(tonumber(matches[2]), tonumber(matches[3]), matches[4])</script>
					<command></command>
					<packageName></packageName>
					<regex>^#EK (\d+) bis (\d+) (\w+)$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Markieren</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Markiere EK als geholt</name>
					<script>---@pattern #EKcheck &lt;id&gt; &lt;date&gt;? -f?
---@desc Falls optionales Datum nicht gegeben, benutze heutiges Datum
if #matches==2 then
	EK:check(tonumber(matches[2]))
elseif #matches==5 then
  EK:check(tonumber(matches[2]), matches[4], true)
else
  if matches[4]=="-f" then
    EK:check(tonumber(matches[2]), nil, true)
  else
    EK:check(tonumber(matches[2]), matches[4])
  end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^#EKcheck (\d+)(\s([^\s]+))?(\s-f)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Entferne Markierung des EKs</name>
					<script>---@pattern #EKuncheck &lt;id&gt;
EK:uncheck(tonumber(matches[2]))</script>
					<command></command>
					<packageName></packageName>
					<regex>^#EKuncheck (\d+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Pass Anzahl unbekannter EKs an</name>
					<script>---@pattern #EKunknown &lt;number&gt;
---@desc Die Zahl besagt, was zu den unbekannten EKs addiert werden soll.
---@desc Bsp: #EKunknown 1 -&gt; Erhöht die Anzahl unbekannter EKs um 1.
---@desc      #EKunknown -1 -&gt; Verringert die Anzahl um 1.
EK:unknown(tonumber(matches[2]))</script>
					<command></command>
					<packageName></packageName>
					<regex>^#EKunknown (-?\d+)?$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Bearbeitung</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>EK hinzufuegen</name>
					<script>---@pattern #EKadd &lt;Name&gt;|&lt;Ort&gt;|&lt;Region&gt;|&lt;Magier&gt;|&lt;Hinweis&gt;|&lt;Welt&gt;
---@desc Name: Moeglichst ausfuehrlich, kann auch mehrere Namen kombiniert sein.
---@desc Ort: Welches Dort, Hoehle, Questgebiet?
---@desc Region: Welches der Morgengrauen Regionen? Wald, Ebene, Anfaenger, ...
---@desc Magier: Name des erschaffenden Magiers, sofern durch Hoerrohr bekannt
---@desc Hinweis: Tipps beim Kampf oder wie sich der NPC rausforschen laesst
---@desc Welt: Normalwelt=0, ansonsten die Nummer der Parallelwelt
---@desc -- bis auf Name und Welt koennen die Felder auch leer bleiben, aber
---@desc    die trennenden | muessen vorhanden sein.

EK:add(matches[2], matches[3], matches[4],matches[5], matches[6], tonumber(matches[7]) or 0)</script>
					<command></command>
					<packageName></packageName>
					<regex>^#EKadd ([^\|]+)\|([^\|]*)\|([^\|]*)\|([^\|]*)\|([^\|]*)\|(\d)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Nicht-EK hinzufuegen</name>
					<script>---@pattern #NEKadd &lt;Name&gt;|&lt;Ort&gt;|&lt;Region&gt;|&lt;Magier&gt;|&lt;Hinweis&gt;|&lt;Welt&gt;
---@desc Name: Moeglichst ausfuehrlich, kann auch mehrere Namen kombiniert sein.
---@desc Ort: Welches Dort, Hoehle, Questgebiet?
---@desc Region: Welches der Morgengrauen Regionen? Wald, Ebene, Anfaenger, ...
---@desc Magier: Name des erschaffenden Magiers, sofern durch Hoerrohr bekannt
---@desc Hinweis: Tipps beim Kampf oder wie sich der NPC rausforschen laesst
---@desc Welt: Normalwelt=0, ansonsten die Nummer der Parallelwelt
---@desc -- bis auf Name und Welt koennen die Felder auch leer bleiben, aber
---@desc    die trennenden | muessen vorhanden sein.
EK:add(matches[2], matches[3], matches[4],matches[5], matches[6], tonumber(matches[7]) or 0, true)</script>
					<command></command>
					<packageName></packageName>
					<regex>^#NEKadd ([^\|]+)\|([^\|]*)\|([^\|]*)\|([^\|]*)\|([^\|]*)\|(\d)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>NPC loeschen</name>
					<script>---@pattern #NPCdel &lt;id&gt;

EK:delete(tonumber(matches[2]))</script>
					<command></command>
					<packageName></packageName>
					<regex>^#NPCdel (\d+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>NPC verschieben</name>
					<script>---@pattern (wird demnaechst entfernt) #EKmove &lt;alte ID&gt; &lt;neue ID&gt;
EK:sort(tonumber(matches[2]), tonumber(matches[3]))</script>
					<command></command>
					<packageName></packageName>
					<regex>#NPCmove (\d+) (\d+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Nicht-EK schnell hinzufuegen</name>
					<script>---@pattern #NEKsadd &lt;Name&gt;
---@desc Fuegt einen NPC (fuer EK muss #EKsadd genutzt werden) "schnell" hinzu.
---@desc Schnell heisst hier, dass nur der Name benoetigt wird.
---@desc Ort und Region wird versucht aus den gmcp-Werten zu belegen
---@desc Magier und Hinweis bleiben leer
---@desc Welt wird aus den gespeicherten Spielerdaten gesetzt. Dies ist jedoch
---@desc      ein Flag, welches durch den Portalbesuch gesetzt wird. Ist der 
---@desc      NPC in einem regulaeren Normalraum, so sollte der Wert nachtraeglich
---@desc      auf 0 korrigiert werden.

if matches[2] then
  EK:add(
    matches[2], -- name
    gmcp.MG.room.info.short, -- place
    gmcp.MG.room.info.domain, -- region
    nil, -- mage
    nil, -- hint
    PLAYER.world(), 
    true) -- simple NPC, no first kill points
elseif EK.suggestion then
  table.insert(EK.suggestion, true)
  EK:add(unpack(EK.suggestion))
  EK.suggestion = nil
else
  eprint("Name oder Vorschlag fehlt fuer die schnelle Eintragung", "EK-Tracker")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^#NEKsadd(\s.+)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>EK schnell hinzufuegen</name>
					<script>---@pattern #EKsadd &lt;Name&gt;
---@desc Fuegt einen EK "schnell" hinzu.
---@desc Schnell heisst hier, dass nur der Name benoetigt wird.
---@desc Ort und Region wird versucht aus den gmcp-Werten zu belegen
---@desc Magier und Hinweis bleiben leer
---@desc Welt wird aus den gespeicherten Spielerdaten gesetzt. Dies ist jedoch
---@desc      ein Flag, welches durch den Portalbesuch gesetzt wird. Ist der 
---@desc      NPC in einem regulaeren Normalraum, so sollte der Wert nachtraeglich
---@desc      auf 0 korrigiert werden.

if matches[2] then
  EK:add(matches[2], gmcp.MG.room.info.short, gmcp.MG.room.info.domain, nil, nil, 0)
elseif EK.suggestion then
  EK:add(unpack(EK.suggestion))
  EK.suggestion = nil
else
  eprint("Name oder Vorschlag fehlt fuer die schnelle Eintragung", "EK-Tracker")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^#EKsadd(\s.+)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>NPC bearbeiten</name>
					<script>---@pattern #NPC &lt;ID&gt; change &lt;Feld&gt;:&lt;Wert&gt;
---@desc Aendert der Wert des Feldes. Dabei kann &lt;Wert&gt; auch leer sein um 
---@desc den Inhalt des Feldes zu loeschen.

EK:change(tonumber(matches[2]), matches[3], matches[4])</script>
					<command></command>
					<packageName></packageName>
					<regex>^#NPC (\d+) change (\w+):(.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>NPCs (ID Range) bearbeiten</name>
					<script>---@pattern #NPC &lt;ID-Range&gt; multichange &lt;Feld&gt;:&lt;Wert&gt;
---@desc &lt;ID-Range&gt; ist eine durch Leerzeichen getrennte Abfolge von
---@desc            &lt;ID&gt; und &lt;Start-ID&gt; bis &lt;End-ID&gt;
---@desc &lt;Wert&gt; kann auch leer sein um den Inhalt vom Feld zu loeschen
---@desc Beispiel: #NPC 12 14 16 multichange ort:Orkhausen
---@desc                Aendert Ort zu Orkhausen bei den NPCs mit der ID 12, 14 und 16
---@desc           #NPC 1 3 bis 5 7 9 bis 11 ort:Orkhausen
---@desc                Aendert Ort zu Orkhausen bei den NPCs mit der ID
---@desc                1, 3, 4, 5, 7, 9, 10, 11

EK:multichange(matches[2], matches[5], matches[6])
</script>
					<command></command>
					<packageName></packageName>
					<regex>^#NPC (\d+(\s(bis\s)?\d+)*) multichange (\w+):(.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>NPCs (Filter) bearbeiten</name>
					<script>---@pattern #NPCfilter &lt;Feld1&gt;?:&lt;Wert1&gt; change &lt;Feld2&gt;:&lt;Wert2&gt;
---@desc Nutze den Filter aller NPCs, dessen Feld &lt;Feld1&gt; den Wert &lt;Wert1&gt;
---@desc hat um das Feld &lt;Feld2&gt; auf den Wert &lt;Wert2&gt; zu setzen, wobei
---@desc &lt;Wert2&gt; auch leer sein kann. Falls &lt;Feld1&gt; fehlt, wird der Name genommen.

if matches[3] == "" then
  EK:multichange(EK:find_by_prop("name", matches[4]), matches[5], matches[6])
else
  EK:multichange(EK:find_by_prop(matches[3], matches[4]), matches[5], matches[6])
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^#NPCfilter ((\w+):)?([^:]*) change (\w+):(.*)$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Plakettenvergleich</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Eintraege zeigen</name>
					<script>---@pattern #EKP &lt;Spielername&gt;
---@desc Zeigt, welche Plakettenvergleiche zu einem anderen Spieler gespeichert
---@desc wurden und wie sich die Werte zum davorigen Vergleich geaendert haben.

EK:show_friend(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^#EKP (\w+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Eintrag loeschen</name>
					<script>---@pattern #EKPdel &lt;Eintragsnummer&gt;
---@desc Mit #EKP &lt;Spielername&gt; koennen Eintraege mit einer Nummer gezeigt werden
---@desc und entsprechend der Nummer kann ein Eintrag geloescht werden.
---@desc Diese Nummern sind ueber alle Spieler hinweg eindeutig.

EK:del_abgleich(tonumber(matches[2]))</script>
					<command></command>
					<packageName></packageName>
					<regex>^#EKPdel (\d+)$</regex>
				</Alias>
			</AliasGroup>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>EK_Help</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>EK_high_help</name>
				<script>GOR:show_help("EK")</script>
				<command></command>
				<packageName></packageName>
				<regex>^\?EK$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>EK_deep_help</name>
				<script>GOR:show_help("EK", matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^\?EK (\d+(.\d+)*)$</regex>
			</Alias>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>EK_init</name>
			<packageName></packageName>
			<script>EK = EK or MundronClassMethods:new{
  _name = "EK",
  _shortname = "EK",
  _module = "EK_Tracker",
  _version = "1.0.0",
  data = {
    player_hasnt = -1, 
    competitor_hasnt = -1
  },
  files = {
    profile = {
      known_kills = {}, 
      unknown_kills = 0, 
      competitions={},
      tracking = true,
    },
    game = {
      npcs={}
    }
  },
  state = {},
  _fixed_version={MundronClassMethods="1.1.0"}
}
  
function EK:post_load_data()
  self:info(f"{len(self.data.npcs)} NPCs und {len(self.data.known_kills)} Kills geladen")
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>EK_helpers</name>
			<packageName></packageName>
			<script>------------------------------------------------------
--
------------------------------------------------------

function EK:kill_count()
  return len(self.data.known_kills) + self.data.unknown_kills
end

------------------------------------------------------
--
------------------------------------------------------

function EK:print_npc(position, npc)
  if not npc then
    self:error("Unzulaessiger NPC zur Anzeige uebergeben.")
  end
  if len(npc) == 0 then
    self:info("Keinen NPC gefunden.")
    return
  end
  local world = tonumber(npc["para"]) or 0
  local npc_table = {
    {{"Nr:", "ly"}, position},
    {{"Name:", "ly"}, npc["name"] or ""},
    {{f"Ort ({world})", world &gt; 0 and "ly" or "lg"}, npc["ort"] or ""},
    {{"Region:", "ly"}, npc["region"] or ""},
    {{"Magier:", "ly"}, npc["magier"] or ""}
  }
  local hintlines = break_lines(npc["hinweis"] or "")
  table.insert(npc_table, {{"Hinweis:", "y"}, hintlines[1]})
  for i = 2, len(hintlines) do
    table.insert(npc_table, {"", hintlines[i]})
  end
  if npc.ek then
    local kdetail = {"Nein", "r"}
    local kill = self.data.known_kills[npc._id]
    if kill then
      kdetail = kill.datum &gt; 0 and os.date("%d.%m.%y", kill.datum) or "unbekannt"
    end
    table.insert(npc_table, {{"Geholt:", "ly"}, kdetail})
  else
    table.insert(npc_table, {{"Kein EK", "ly"}, ""})
  end
  echo("\n")
  print_table(npc_table, -1)
end

------------------------------------------------------
--
------------------------------------------------------

function EK:print_npc_list(npcs, prop, no_killer)
  if len(npcs) == 0 then
    iprint("Keine NPCs gefunden.", "EK-Tracker")
    return
  end
  local npc_table = {}
  prop = prop or "ort"
  positions = table.keys(npcs)
  table.sort(positions)
  for _, position in pairs(positions) do
    local npc = npcs[position]
    local kill = self.data.known_kills[npc._id]
    if no_killer or (kill and kill.datum &gt; -1) then
      position = "&lt;0,255,0:0,0,0&gt;" .. position
    else
      position = "&lt;255,255,0:0,0,0&gt;" .. position
    end
    local prop_title = string.title(prop)
    if prop == "ort" then
      prop_title = prop_title .. "(" .. npc["para"] .. "):"
      if npc["para"] &gt; 0 then
        prop_title = "&lt;255,200,0:0,0,0&gt;" .. prop_title
      else
        prop_title = "&lt;0,255,0:0,0,0&gt;" .. prop_title
      end
    else
      prop_title = "&lt;0,255,0:0,0,0&gt;" .. prop_title
    end
    table.insert(
      npc_table, 
      {position, npc["name"]:sub(1, 30), prop_title, npc[prop]:sub(1, 30)}
    )
  end
  echo("\n")
  print_table(npc_table, {1, -1, -1, -1}, 1)
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>EK_list_handling</name>
			<packageName></packageName>
			<script>------------------------------------------------------
--
------------------------------------------------------

function EK:missing()
  local npcs = {}
  for position, npc in ipairs(self.data.npcs) do
    if not self.data.known_kills[npc._id] then
      npcs[position] = npc
    end
  end
  self:print_npc_list(npcs, "ort", false)
  iprint({"Es sind", {len(npcs), "ly"}, "fehlende EKs eingetragen."}, "EK-Tracker")
end

------------------------------------------------------
--
------------------------------------------------------
function EK:find_by_id(search_id)
  local npc = self.data.npcs[search_id]
  self:print_npc(search_id, npc)
end

function EK:find_by_range(start_id, end_id, prop_filter)
  if start_id &gt; end_id then
    eprint("Start ID muss kleiner sein als End ID.", "EK-Tracker")
    return
  end
  local npcs = {}
  for position, npc in ipairs(self.data.npcs) do
    if start_id &lt;= npc.position and npc.position &lt;= end_id then
      npcs[position] = npc
    end
  end
  self:print_npc_list(npcs, prop_filter)
end

function EK:find_by_prop(pattern_dict)
  local npcs = {}
  for position, npc in ipairs(self.data.npcs) do
    npc_condition = true
    for attr, value in pairs(pattern_dict) do
      if not substring(string.lower(npc[attr]), string.lower(value)) then
        npc_condition = false
        break
      end
    end
    if npc_condition then
      npcs[position]= npc
    end
  end
  self:print_npc_list(npcs)
  return npcs
end

------------------------------------------------------
--
------------------------------------------------------

function EK:check(nr, date, overwrite)
  local npc = self.data.npcs[nr]
  if npc == nil then
    eprint({"Kein NPC mit der Nummer ", {id, "y"}, " gefunden."}, "EK-Tracker")
    return
  end
  local kill = self.data.known_kills[npc._id]
  if kill then
    if overwrite then
      if date then
        local d, m, y = date:match("(%d+)\.(%d+)\.(%d+)")
        kill.date = os.time({year = 2000 + y, month = m, day = d})
      else
        kill.date = os.time()
      end
      iprint({"EK mit der Nummer ", {nr, "y"}, " hat Datumskorrektur erhalten."}, "EK-Tracker")
    else
      wprint("EK bereits erworben! Zum Ueberschreiben -f benutzen.", "EK-Tracker")
    end
  else
    if date then
      if string.lower(date) == "x" then
        date = 0
      else
        local d, m, y = date:match("(%d+)\.(%d+)\.(%d+)")
        date = os.time({year = 2000 + y, month = m, day = d})
      end
    else
      date = os.time()
    end
    self.data.known_kills[npc._id] = {name=npc.name, date=date, _id=npc._id}
    self:save_data()
    iprint({"EK mit der Nummer ", {nr, "y"}, " ist nun abgehakt."}, "EK-Tracker")
    if EK.data.tracking then
      send("lies plakette")
    else
      MainGUI.ekanzahl:echo("EK-Anzahl: " .. self:kill_count(), "black")
    end
  end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:uncheck(nr)
  local npc = self.data.npcs[nr]
  if npc == nil then
    eprint({"Kein NPC mit der Nummer ", {nr, "y"}, " gefunden."}, "EK-Tracker")
    return
  end
  if self.data.known_kills[npc._id] then
    self.data.known_kills[npc._id] = nil
    self:save_kills()
    iprint({"Der EK mit der Nummer ", {nr, "y"}, " ist nun nicht mehr abgehakt."}, "EK-Tracker")
  else
    wprint("Der EK wurde noch nicht erworben.", "EK-Tracker")
    return
  end
  if self.data.tracking then
    send("lies plakette")
  else
    MainGUI.ekanzahl:echo("EK-Anzahl: " .. self:kill_count(), "black")
  end
end

------------------------------------------------------
--
------------------------------------------------------


function EK:add(name, place, region, creator, hint, world, nonkillpoints)
  if not name then
    eprint("Der Eintrag muss wenigstens einen Namen haben.", "EK-Tracker")
  end
  max_id = -1
  for _, npc in pairs(self.data.npcs) do
    max_id = math.max(next_id, npc._id)
  end
  local doc = {name = name, _id = max_id + 1}
  local function add(field, value)
    if value and len(value) &gt; 0 then 
      doc[field] = value
    end
  end
  add("ort", place)
  add("region", region)
  add("magier", creator)
  add("hinweis", hint)
  doc["para"] = world or 0
  doc["ek"] = not nonkillpoints
  table.insert(self.data.npcs, doc)
  iprint({{"Neu eingetragener EK:", "y"}}, "EK-Tracker")
  self:print_npc(len(self.data.npcs), doc)
  self:save_game()
end

------------------------------------------------------
--
------------------------------------------------------

function EK:find_attr(attr, sub)
  local matches = {}
  local _attr = string.lower(attr)
  local _sub = string.lower(sub)
  for _, npc in pairs(self.data.npcs) do
    if npc[_attr] and substring(string.lower(npc[_attr]), _sub) then
      matches[npc[_attr]] = true
    end
  end
  if len(matches) == 0 then
    self:info({"Keine", {string.title(attr), "ly"}, " gefunden."})
  else
    matches = table.keys(matches)
    table.sort(matches)
    self:info({
      "Zum", {f"'{attr}'", "ly"}, "mit", {f"'{sub}'", "ly"}, "gefunden:"
    })
    local tab = {}
    for i, v in ipairs(matches) do 
      table.insert(tab, {{f"{i}:", "lg"}, v})
    end
    print_table(tab)
  end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:unknown(x)
  if not x then
    iprint(
      {"Die Anzahl unbekannter EKs ist ", {self.data.unknown_kills, "ly"}, "."},
      "EK-Tracker"
    )
    return
  end
  local ausgabe =
    {
      "Die Anzahl unbekannter EKs aendert sich von ",
      {self.data.unknown_kills, "lg"},
      " zu ",
    }
  self.data.unknown_kills = self.data.unknown_kills + x
  table.insert(ausgabe, {self.data.unknown_kills, "lg"})
  table.insert(ausgabe, ".")
  self:save_data()
  iprint(ausgabe, "EK-Tracker")
  if self.config.tracking then
    send("lies plakette")
  else
    MainGUI.ekanzahl:echo("EK-Anzahl: " .. self:kill_count(), "black")
  end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:zeige(von, bis)
  von = von and parse_date(von) or 0
  -- we like to get all kill entries even
  -- for the chosen day. So, the upper limit
  -- has to be extended for a day
  bis = (bis and parse_date(bis) or os.time()) + 24 * 60 * 60
  display(von, bis)
  local npcs = {}
  for position, npc in ipairs(self.data.npcs) do
    date = (self.data.known_kills[npc._id] or {}).datum
    if date and von &lt;= date and date &lt;= bis then
      npcs[position] = npc
    end
  end
  self:print_npc_list(npcs)
  iprint({"Es wurden ", {len(npcs), "ly"}, " NPCs gefunden."}, "EK-Tracker")
end

------------------------------------------------------
--
------------------------------------------------------

function EK:delete(nr)
  if self.state.del_flag and self.state.del_flag.nr == nr then
    table.remove(self.data.npcs, nr)
    for pos, npc in ipairs(self.data.npcs) do
      if pos &gt;= nr then
        npc.position = pos
      end
    end
    self.state.del_flag = nil
    self:save_game()
    iprint("Der EK wurde geloescht.", "EK-Tracker")
  else
    local npc = self.data.npcs[nr]
    if not npc then
      iprint("Es wurde kein NPC mit der Nummer " .. nr .. " gefunden.", "EK-Tracker")
      return
    end
    iprint(
      "Moechtest du folgenden EK aus der Liste loeschen? Falls ja, wiederhole den Befehl!",
      "EK-Tracker"
    )
    self:print_npc(nr, npc)
    self.state.del_flag = {nr = nr}
  end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:sort(old_nr, new_nr)
  if old_nr &lt; 1 or old_nr &gt; len(self.data.npcs) or new_nr &lt; 1 or new_nr &gt; len(self.data.npcs) then
    eprint("Unzulaessige Positionen " .. old_nr .. " oder " .. new_nr .. ".", "EK-Tracker")
    return
  end
  local temp = self.data.npcs[old_nr]
  if old_nr &gt; new_nr then
    for i = old_nr, new_nr + 1, -1 do
      self.data.npcs[i] = self.data.npcs[i - 1]
      self.data.npcs[i].position = i
    end
  else
    for i = old_nr, new_nr - 1, 1 do
      self.data.npcs[i] = self.data.npcs[i + 1]
      self.data.npcs[i].position = i
    end
  end
  temp.position = new_nr
  self.data.npcs[new_nr] = temp
  self:save_game()
  iprint(
    "Der NPC an der Stelle " .. old_nr .. " wurde nun an die Stelle " .. new_nr .. " gesteckt.",
    "EK-Tracker"
  )
end

------------------------------------------------------
--
------------------------------------------------------

function EK:change(nr, attr, content)
  local position = tonumber(nr)
  attr = string.lower(attr)
  if not position then
    eprint({"Die Eingabe", {nr, "y"}, "ist keine Zahl."}, "EK-Tracker")
    return
  end
  if self.state.change_flag and self.state.change_flag.npc.position == position then
    self.state.change_flag.npc[attr] = self.state.change_flag.change
    echo("\nDas Attribut ")
    decho("&lt;0,255,0:0,0,0&gt;" .. string.title(attr))
    echo(" wurde zu \n")
    decho("&lt;0,255,0:0,0,0&gt;" .. content)
    echo("\ngeaendert.\n\n")
    self:print_npc(self.state.change_flag.position, self.state.change_flag.npc)
    self.state.change_flag = nil
    self:save_game()
  else
    if attr == "para" then
      local num = tonumber(content)
      if num and num &gt; -1 then
        content = num
      else
        eprint(
          "Die Welt/Parallelwelt muss eine ganze Zahl groesser oder gleich 0 sein.", "EK-Tracker"
        )
      end
    end
    local npc = self.data.npcs[nr]
    if npc == nil then
      iprint({"Es konnte kein NPC mit der ID", {id, "y"}, "gefunden werden."}, "EK-Tracker")
      return
    end
    echo("Willst du bei ...\n\n")
    self:print_npc(nr, npc)
    echo("\n... wirklich das Attribut ")
    decho("&lt;0,255,0:0,0,0&gt;" .. string.title(attr))
    echo(" zu \n")
    decho("&lt;0,255,0:0,0,0&gt;" .. content)
    echo("\naendern? Falls ja, dann wiederhole den Befehl.\n\n")
    self.state.change_flag = {npc = npc, position=nr, change = content}
  end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:multichange(ids, attr, content)
  attr = string.lower(attr)
  if self.state.mchange_flag and self.state.mchange_flag.ids == ids then
    for _, npc in pairs(self.state.mchange_flag.npcs) do
      npc[attr] = self.state.mchange_flag.change
    end
    echo("\nDas Attribut ")
    decho("&lt;0,255,0:0,0,0&gt;" .. string.title(attr))
    echo(" wurde zu \n")
    decho("&lt;0,255,0:0,0,0&gt;" .. content)
    echo("\ngeaendert:\n")
    self:print_npc_list(self.state.mchange_flag.npcs, attr)
    self.state.mchange_flag = nil
    self:save_game()
  else
    if attr == "para" then
      local num = tonumber(content)
      if num and num &gt; -1 then
        content = num
      else
        eprint(
          "Die Welt/Parallelwelt muss eine ganze Zahl groesser oder gleich 0 sein.", "EK-Tracker"
        )
      end
    end
    local id_list = {}
    for von, bis in ids:gmatch("(%d+) bis (%d+)") do
      for i = von, bis, 1 do
        table.insert(id_list, i)
      end
    end
    shorten_ids = ids:gsub("(%d+) bis (%d+)", "")
    for id in shorten_ids:gmatch("%d+") do
      table.insert(id_list, tonumber(id))
    end
    local npcs = {}
    for _, id in pairs(id_list) do
      npcs[id] = self.data.npcs[id]
    end
    if len(npcs) == 0 then
      iprint({"Es konnte kein NPCs mit den IDs", {ids, "y"}, "gefunden werden."}, "EK-Tracker")
      return
    end
    echo("Willst du bei ...\n\n")
    self:print_npc_list(npcs, attr)
    echo("\n... wirklich das Attribut ")
    decho("&lt;0,255,0:0,0,0&gt;" .. string.title(attr))
    echo(" zu \n")
    decho("&lt;0,255,0:0,0,0&gt;" .. content)
    echo("\naendern? Falls ja, dann wiederhole den Befehl.\n\n")
    self.state.mchange_flag = {ids = ids, npcs = npcs, change = content}
  end
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>EK_plaketten_handling</name>
			<packageName></packageName>
			<script>------------------------------------------------------
--
------------------------------------------------------

function EK:save_plakettenabgleich(name)
  echo(
    "\n\nCompetitor: " ..
    name ..
    " is missing " ..
    self.data.player_hasnt ..
    " and has " ..
    self.data.competitor_hasnt ..
    "\n\n"
  )
  if self.data.player_hasnt &gt; -1 and self.data.competitor_hasnt &gt; -1 then
    name = name:lower()
    table.insert(
      self.data.competitions,
      {
        player_count = self:kill_count(),
        player_hasnt = self.data.player_hasnt,
        date = os.time(),
        competitor_name = name,
        competitor_count = self:kill_count() - self.data.competitor_hasnt + self.data.player_hasnt,
        competitor_hasnt = self.data.competitor_hasnt,
      }
    )
    self.data.player_hasnt = -1
    self.data.competitor_hasnt = -1
    self:save_data()
    self:show_friend(name)
  end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:del_abgleich(nr)
  if nr &lt; 1 or nr &gt; len(self.data.competitions) then
    eprint("Ungueltige Nummer " .. nr .. ".", "EK-Tracker")
    return
  end
  if self.state.pdel_flag and self.state.pdel_flag.nr == nr then
    table.remove(self.data.competitions, nr)
    self.state.pdel_flag = nil
    self:save_data()
    iprint("Plakettenvergleichseintrag geloescht.", "EK-Tracker")
  else
    iprint({"Willst du wirklich den Eintrag mit der Nummer ", {nr, "y"}, "loeschen?"}, "EK-Tracker")
    self:show_friend(nr)
    iprint("Falls ja, dann wiederhole den Befehl.", "EK-Tracker")
    self.state.pdel_flag = {nr = nr}
  end
end

------------------------------------------------------
--
------------------------------------------------------
local function diff(base, reference)
  if not reference then
    return ""
  end
  local difference = base - reference
  local sign = "+"
  local diff_color = "&lt;0,255,0:0,0,0&gt;"
  if difference &lt; 0 then
    sign = ""
    -- don't change to "-", because the negative value has already the sign
    diff_color = "&lt;255,255,0:0,0,0&gt;"
  end
  return f"{diff_color}({sign}{difference})"
end

function EK:show_friend(arg)
  local entries = {}
  local name = arg
  if type(arg) == "number" then
    if arg &lt; 1 or arg &gt; len(self.data.competitions) then
      eprint("Ungueltige Nummer " .. nr .. ".", "EK-Tracker")
      return
    end
    entries = {self.data.competitions[arg]}
    entries[1]._row_id = arg
    if len(entries) &gt; 0 then
      name = string.title(entries[1]["competitor_name"])
    end
  else
    arg = string.lower(arg)
    local cnt = 3
    local entry
    for i = len(self.data.competitions), 1, -1 do
      entry = self.data.competitions[i]
      if entry.competitor_name == arg then
        entry._row_id = i
        table.insert(entries, 1, entry)
        cnt = cnt - 1
      end
      if cnt == 0 then
        break
      end
    end
  end
  if len(entries) == 0 then
    iprint("Es wurden keine Eintraege gefunden.", "EK-Tracker")
    return
  end
  echo("\n\n")
  local tab = {{
    "ID", 
    "Zeitstempel",
    "Deine EKs", "",
    f"EKs von {name}", "", 
    "Dir fehlen", "",
    f"{name} fehlen", ""
  }}
  local keys = {
    "player_count", "competitor_count", 
    "player_hasnt", "competitor_hasnt"
  }
  for i, entry in ipairs(entries) do
    local line = {entry["_row_id"], os.date("%d.%m.%y - %H:%M", entry["date"])}
    for _, key in pairs(keys) do
      table.insert(line, tostring(entry[key]))
      table.insert(line, diff(entry[key], entries[i-1][key]))
    end
  end
  print_table(tab, 1)
  echo("\n")
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>EK_no_badge_for_small_players</name>
			<packageName></packageName>
			<script>function EK_no_badge_for_small_players()
  -- nicht-Seher haben eh keine Plakette und damit muessen
  -- Spielanfaenger erstmal sich nicht um diese
  -- Einstellung kuemmern
  EK.data.tracking = gmcp.MG.char.base.wizlevel ~= 0
end</script>
			<eventHandlerList>
				<string>gmcp.MG.char.base</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>EK_migration</name>
			<packageName></packageName>
			<script>function EK:migrate_game(saved_version)
  if self.version_lt(saved_version, "1.0.0") then
    local npcs = mload_jsonl("EK_NPC_liste")
    msave_json(npcs, self:name("npcs"))
    mremove_jsonl("EK_NPC_liste")
    self:info(f"Migration von Spieldaten auf Version 1.0.0 mit {len(npcs)} NPCs erledigt")
    MundronClassMethods.migrate_game(EK)
    saved_version = "1.0.0"
  end
  return saved_version
end

function EK:migrate_profile(saved_version)
  if self.version_lt(saved_version, "1.0.0") then
    pmove_json("EK_pwt_diebe_trace", self:name("diebe.trace"))
    local competitions = pload_jsonl("EK_Plakettenvergleich")
    psave_json(competitions, self:name("competitions"))
    premove_jsonl("EK_Plakettenvergleich")
    
    local kills = pload_jsonl("EK_Kills")
    local new_kills = {}
    local unknown_kills = 0
    for _, kill in pairs(kills) do
      if kill._id then
        new_kills[kill._id] = kill
      else
        unknown_kills = unknown_kills + 1
      end
    end
    psave_json(new_kills, self:name("known_kills"))
    psave_json(unknown_kills, self:name("unknown_kills"))
    premove_jsonl("EK_Kills")
    self:info(f"Migration von Profildaten auf Version 1.0.0 mit {len(new_kills)} bekannten und {unknown_kills} unbekannten Kills erledigt")
    MundronClassMethods.migrate_profile(EK)
    saved_version = "1.0.0"
  end
  return saved_version
end</script>
			<eventHandlerList />
		</Script>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
