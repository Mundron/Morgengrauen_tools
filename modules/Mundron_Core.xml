<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage />
	<TimerPackage />
	<AliasPackage />
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>MC_init_colors</name>
			<packageName></packageName>
			<script>function MC_init_colors()
  return farben or  {
    vg = {
      komm = "cyan", 
      ebenen = "red", 
      info = "green", 
      alarm = "white", 
      script = "dark_green"
    },
    bg = {
      komm = "black", 
      ebenen = "black", 
      info = "black", 
      alarm = "red", 
      script = "black"
    },
  }
end

farben = MC_init_colors()</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>helper_functions</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>json_helper</name>
				<packageName></packageName>
				<script>--[[
  Converter of serializable Lua objects to JSON strings and backwards
  Usage:
  json.encode({42, 23, 12}) --&gt; "[42, 23, 12]"
  json.decode('{"apple": 13, "tree": true}') --&gt; {["apple"] = 13, ["tree"] = true}
]]--

json = {
  _version = "1.0.0",
  _author = "Mundron",
  _contact = "https://github.com/Mundron",
  _repository = "https://github.com/Mundron/Morgengrauen_tools"
}

local escape_char_map = {
  ["/"] = "\\/",
  ['"'] = '\\"',
  ["\b"] = "\\b",
  ["\f"] = "\\f",
  ["\n"] = "\\n",
  ["\r"] = "\\r",
  ["\t"] = "\\t",
}

local escape_char_map_inv = {["\\\\"]="\\"}
for k, v in pairs(escape_char_map) do
  escape_char_map_inv[v] = k
end

local function escaped_string(value)
  -- Escape backslash first to avoid double-escaping
  value = value:gsub("\\", "\\\\")
  for k, v in pairs(escape_char_map) do
    if k ~= "\\" then  -- Already handled
      value = value:gsub(k, v)
    end
  end
  return '"' .. value .. '"'
end

local function isArray(value)
  local count = 0
  for k, v in pairs(value) do
    count = count + 1
    if type(k) ~= "number" or k ~= count then
      return false
    end
  end
  return true
end

function json.encode(value, indent)
  indent = indent or 0
  local indentStr = string.rep("  ", indent)
  local nextIndentStr = string.rep("  ", indent + 1)
    
  local valueType = type(value)
  if value == nil then
    return "null"
  elseif valueType == "boolean" then
    return tostring(value)
  elseif valueType == "number" then
    return tostring(value)
  elseif valueType == "string" then
    return escaped_string(value)        
  end
  
  if valueType == "table" then
    if isArray(value) then
      if #value == 0 then
        return "[]"
      else
        local parts = {}
        for i = 1, #value do  -- FIX: was using undefined 'count'
          table.insert(parts, nextIndentStr .. json.encode(value[i], indent + 1))
        end
        return "[\n" .. table.concat(parts, ",\n") .. "\n" .. indentStr .. "]"
      end
    else
      local parts = {}
      for k, v in pairs(value) do
        local key
        if type(k) == "string" then
          key = escaped_string(k)
        elseif type(k) == "number" then
          key = f'"{k}"'
        else
          error(f"Invalid key type: {type(k)}")
        end
        table.insert(parts, f"{nextIndentStr}{key}: {json.encode(v, indent + 1)}")
      end
      -- Sort for consistent output
      table.sort(parts)
      return "{\n" .. table.concat(parts, ",\n") .. "\n" .. indentStr .. "}"
    end
  end
  
  error("Unsupported type: " .. valueType)
end

-- JSON to Lua table parser
function json.decode(str)
  local pos, error_flag = 1, false
  
  local function decode_error(msg)
    error(f"JSON decode error at position {pos}: {msg} - {str:sub(pos-10,pos+10)}")
    error_flag = true
  end
  
  local whitespace = {" ", "\t", "\n", "\r"}
  
  local function skip_whitespace()
    while table.contains(whitespace, str:sub(pos, pos)) and pos &lt;= #str do
      pos = pos + 1
    end
  end
  
  local function parse_string()
    if str:sub(pos, pos) ~= '"' then
      decode_error("Expected string")
    end
    pos = pos + 1  -- Skip opening quote
    
    local result = {}
    while pos &lt;= #str do
      local c = str:sub(pos, pos)
      
      if c == '"' then
        pos = pos + 1  -- Skip closing quote
        return table.concat(result)
      elseif c == "\\" then
        -- Handle escape sequences
        local escape = str:sub(pos, pos + 1)
        if escape_char_map_inv[escape] then
          table.insert(result, escape_char_map_inv[escape])
          pos = pos + 2
        elseif str:sub(pos + 1, pos + 1) == "u" then
          -- Unicode escape \uXXXX - simplified handling
          local hex = str:sub(pos + 2, pos + 5)
          local codepoint = tonumber(hex, 16)
          if codepoint then
            table.insert(result, string.char(codepoint))
          end
          pos = pos + 6
        else
          decode_error("Invalid escape sequence")
        end
      else
        table.insert(result, c)
        pos = pos + 1
      end
    end
    
    decode_error("Unterminated string")
  end -- function parse_string
  
  local function parse_number()
    local start_pos = pos
    local has_decimal = false
    local has_exponent = false
    
    -- Optional minus sign
    if str:sub(pos, pos) == "-" then
      pos = pos + 1
    end
    
    -- Digits before decimal point
    if not str:sub(pos, pos):match("%d") then
      decode_error("Invalid number")
    end
    
    while pos &lt;= #str and str:sub(pos, pos):match("%d") do
      pos = pos + 1
    end
    
    -- Optional decimal part
    if pos &lt;= #str and str:sub(pos, pos) == "." then
      has_decimal = true
      pos = pos + 1
      if not str:sub(pos, pos):match("%d") then
        decode_error("Invalid number")
      end
      while pos &lt;= #str and str:sub(pos, pos):match("%d") do
        pos = pos + 1
      end
    end
    
    -- Optional exponent
    if pos &lt;= #str and (str:sub(pos, pos) == "e" or str:sub(pos, pos) == "E") then
      has_exponent = true
      pos = pos + 1
      if str:sub(pos, pos) == "+" or str:sub(pos, pos) == "-" then
        pos = pos + 1
      end
      if not str:sub(pos, pos):match("%d") then
        decode_error("Invalid number")
      end
      while pos &lt;= #str and str:sub(pos, pos):match("%d") do
        pos = pos + 1
      end
    end
    
    return tonumber(str:sub(start_pos, pos - 1))
  end -- function parse_number
  
  local function parse_value()
    skip_whitespace()
    
    local c = str:sub(pos, pos)
    
    if str:sub(pos, pos + 3) == "null" then
      pos = pos + 4
      return nil
    elseif str:sub(pos, pos + 3) == "true" then
      pos = pos + 4
      return true
    elseif str:sub(pos, pos + 4) == "false" then
      pos = pos + 5
      return false
    elseif c == '"' then
      return parse_string()
    elseif c == "-" or c:match("%d") then
      return parse_number()
    elseif c == "[" then
      pos = pos + 1
      skip_whitespace()
      
      local arr = {}
      
      -- Empty array
      if str:sub(pos, pos) == "]" then
        pos = pos + 1
        return arr
      end
      
      while pos &lt;= #str do
        table.insert(arr, parse_value())
        skip_whitespace()
        
        local next_char = str:sub(pos, pos)
        if next_char == "]" then
          pos = pos + 1
          return arr
        elseif next_char == "," then
          pos = pos + 1
          skip_whitespace()
        else
          decode_error("Expected ',' or ']' in array")
        end
      end
    end
    
    -- object
    if c == "{" then
      pos = pos + 1
      skip_whitespace()
      
      local obj = {}
      
      -- Empty object
      if str:sub(pos, pos) == "}" then
        pos = pos + 1
        return obj
      end
      
      while pos &lt;= #str do
        skip_whitespace()
        
        -- Parse key
        local key = parse_value()
        skip_whitespace()
        
        if str:sub(pos, pos) ~= ":" then
          decode_error("Expected ':' after object key")
        end
        pos = pos + 1
        
        -- Parse value
        obj[key] = parse_value()
        skip_whitespace()
        
        local next_char = str:sub(pos, pos)
        if next_char == "}" then
          pos = pos + 1
          return obj
        elseif next_char == "," then
          pos = pos + 1
        else
          decode_error("Expected ',' or '}' in object")
        end
      end -- while
    end -- object parsing
    
    decode_error("Unexpected character: " .. c)
  end -- function parse_value
  
  local result = parse_value()
  skip_whitespace()
  
  if pos &lt;= #str then
    decode_error("Unexpected content after JSON value")
  end
  
  return result
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>pathes_helper</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------


function getRepoPath(extension)
  local path_table = string.split(getModulePath("Mundron_Core"), "/")
  local result = table.concat(path_table, "/", 1, #path_table - 2)
  if extension then
    result = f"{result}/{extension}"
  end
  return result
end

function getRepoDataPath(extension)
  local result = getRepoPath(f"data")
  if not io.exists(result) then
    lfs.mkdir(path)
  end
  if extension then
    result = f"{result}/{extension}"
  end
  return result
end

function getRepoPicturePath(extension)
  local result = getRepoPath("pictures")
  if extension then
    result = f"{result}/{extension}"
  end
  if not io.exists(result) then
    local msg = f"Die Datei {result} wurde nicht gefunden"
  end
  return result
end


function getProfileDataPath(extension)
  local result = f"{getMudletHomeDir()}/data"
  if not io.exists(result) then
    lfs.mkdir(result)
  end
  if extension then
    result = f"{result}/{extension}"
  end
  return result
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>colored_print_helper</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Here are three colored echos        --
--                                             --
-------------------------------------------------

function print_help(filename, verbose)
  for _, line in ipairs(mload_jsonl(filename)) do
    for _, txt in ipairs(line) do
      print(txt)
      if not verbose then
        break
      end
    end
  end
end

local function get_prefix(keyword, reference)
  local result = ""
  if reference then
    result = f("{keyword} ({reference}): ")
  else
    result = f("{keyword}: ")
  end
  return result
end

function wprint(text, reference)
  echo("\n")
  print(text, {get_prefix("WARNUNG", reference), "&lt;255,255,0:0,0,0&gt;"})
  echo("\n")
end

function eprint(text, reference)
  echo("\n")
  print(text, {get_prefix("FEHLER", reference), "&lt;255,155,0:0,0,0&gt;"})
  echo("\n")
end

function iprint(text, reference)
  print(text, {get_prefix("INFO", reference), "&lt;120,170,255:0,0,0&gt;"})
end

local text_farben =
  {
    r = "&lt;235,80,80:0,0,0&gt;",
    g = "&lt;155,255,0:0,0,0&gt;",
    b = "&lt;120,170,255:0,0,0&gt;",
    lb = "&lt;120,170,255:0,0,0&gt;",
    o = "&lt;255,155,55:0,0,0&gt;",
    l = "&lt;155,155,255:0,0,0&gt;",
    y = "&lt;205,205,0:0,0,0&gt;",
    ly = "&lt;205,205,0:0,0,0&gt;",
    c = "&lt;0,255,255:0,0,0&gt;",
    m = "&lt;255,0,255:0,0,0&gt;",
  }
  
local function print_with_breaks(text, pre)
  pre = pre or {"", ""}
  decho(f("{pre[2]}{pre[1]}"))
  local pre_len = len(pre[1])
  local pseudo_pre = ""
  for i = 1, pre_len, 1 do
    pseudo_pre = f("{pseudo_pre} ")
  end
  local line_size = pre_len
  for _, text_part in ipairs(text) do
    woerter = text_part[1]
    farbe = text_farben[text_part[2]] or ""
    for _, word in ipairs(string.split(woerter)) do
      -- check if word contains line break symbols
      local word_tab = string.split(word, "\n")
      if len(word_tab) == 1 then
        if line_size + #word &lt; 78 then
          decho(f("{farbe}{word} "))
          line_size = line_size + #word + 1
        else
          decho(f("\n{pseudo_pre}{farbe}{word} "))
          line_size = pre_len + #word + 1
        end
      else
        if line_size + #word_tab[1] &lt; 78 then
          decho(f("{farbe}{word_tab[1]}"))
        else
          decho(f("\n{pseudo_pre}{farbe}{word_tab[1]}"))
        end
        for i=2,len(word_tab),1 do
          if len(word_tab[i]) == 0 then
            decho(f("\n{pseudo_pre}"))
            line_size = pre_len
          else
            decho(f("\n{pseudo_pre}{farbe}{word_tab[i]} "))
            line_size = pre_len + len(word_tab[1]) + 1
          end
        end
      end
    end
  end
  echo("\n")
end

function print(text, pre)
  if type(pre) == "string" then
    pre = {pre, nil}
  end
  if type(text) == "string" then
    print_with_breaks({{text, nil}}, pre)
  elseif type(text) == "table" then
    new_text = {}
    for _, t in pairs(text) do
      if type(t) == "string" then
        table.insert(new_text, {t, nil})
      elseif type(t) == "table" then
        table.insert(new_text, t)
      end
    end
    print_with_breaks(new_text, pre)
  end
end

function print_table(tab)
  local temp = {}
  for i = 1, #tab do
    for j = 1, #tab[i] do
      if temp[j] then
        table.insert(temp[j], tab[i][j])
      else
        temp[j] = {tab[i][j]}
      end
    end
  end
  for i = 1, #temp do
    for j = 1, #temp[i] do
      decho(temp[i][j])
    end
    echo("\n")
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>io_helper</name>
				<packageName></packageName>
				<script>-------------------------------------------------
-- generel load/save functions
-------------------------------------------------

function load_csv(path)
  if path == nil then
    eprint("Kein Dateiname zum Laden gegeben.")
    return
  end
  if io.exists(path) then
    local result = {}
    for line in io.lines(path) do
      table.insert(result, string.split(line, ";"))
    end
    return result
  elseif is_first_call(path) then
    save_csv(path, {})
    return {}
  else
    local msg = f"Datei {path} zum Laden nicht gefunden"
    eprint(msg, "MundronCore")
    return nil
  end
end

function load_tlines(path)
  if path == nil then
    eprint("Kein Dateiname zum Laden gegeben.")
    return
  end
  if io.exists(path) then
    local lines = {}
    for sline in io.lines(path) do
      sline = sline:gsub("\r", "")
      table.insert(lines, sline)
    end
    return lines
  elseif is_first_call(path) then
    save_tlines(path, {})
    return {}
  else
    local msg = f"Datei {path} zum Laden nicht gefunden"
    eprint(msg, "MundronCore")
    return nil
  end
end

function load_json(path, default)
  default = default or {}
  if path == nil then
    eprint("Kein Dateiname zum Laden gegeben.")
    return
  end
  local file = io.open(path, "r")
  if file then
    local content = file:read("*all")
    file:close()
    return json.decode(content)
  elseif is_first_call(path) then
    save_json(path, default)
    return default
  else
    local msg = f"Datei {path} zum Laden nicht gefunden"
    eprint(msg, "MundronCore")
    return nil
  end
end

function load_jsonl(path)
  if path == nil then
    eprint("Kein Dateiname zum Laden gegeben.")
    return
  end
  if io.exists(path) then
    local lines = {}
    for sline in io.lines(path) do
      table.insert(lines, json.decode(sline))
    end
    return lines
  elseif is_first_call(path) then
    save_jsonl(path, {})
    return {}
  else
    local msg = f"Datei {path} zum Laden nicht gefunden"
    eprint(msg, "MundronCore")
    return nil
  end
end


function save_csv(path, lines, setting)
  -- delimiter is ; because , are used in descriptions
  if #lines == 0 and io.exists(path) then
    eprint(f"Versuch die Datei {path} leer zu ueberschreiben verhindert!")
    return
  end
  local file = io.open(path, "w+")
  local temp
  if setting then
    if type(setting) == 'table' then
      file:write(table.concat(setting, ";"), "\n")
    else
      file:write(setting, "\n")
    end
  end
  for k, v in ipairs(lines) do
    if type(v) == 'table' then
      file:write(table.concat(v, ";") .. "\n")
    else
      file:write(v, "\n")
    end
  end
  file:close()
end

function save_tlines(path, lines)
  if #lines == 0 and io.exists(path) then
    eprint(f"Versuch die Datei {path} leer zu ueberschreiben verhindert!")
    return 
  end
  local file = io.open(path, "w+")
  for _, v in ipairs(lines) do
    file:write(v, "\n")
  end
  file:close()
end


function save_json(path, tab)
  if len(tab) == 0 and io.exists(path) then
    eprint(f"Versuch die Datei {path} leer zu ueberschreiben verhindert!")
    return
  end
  local file = io.open(path, "w+")
  file:write(json.encode(tab))
  file:close()
end

function save_jsonl(path, tab)
  if len(tab) == 0 and io.exists(path) then
    eprint(f"Versuch die Datei {path} leer zu ueberschreiben verhindert!")
    return
  end
  local file = io.open(path, "w+")
  for _, line in spairs(tab) do
    print(f"Speicher: {line}")
    file:write(json.encode(line), "\n")
  end
  file:close()
end


-------------------------------------------------
-- module load/save functions
-------------------------------------------------

function mload_csv(filename)
  -- this function loads a csv file from the modules folder
  return load_csv(getRepoDataPath(f"{filename}.csv"))
end

function mload_tlines(filename)
  -- this function loads a text file from the modules folder
  return load_tlines(getRepoDataPath(f"{filename}.txt"))
end

function mload_json(filename, default)
  return load_json(getRepoDataPath(f"{filename}.json"), default)
end

function mload_jsonl(filename)
  return load_jsonl(getRepoDataPath(f"{filename}.jsonl"))
end

function msave_csv(filename, lines)
  return save_csv(getRepoDataPath(f"{filename}.csv"), lines)
end

function msave_tlines(filename, lines)
  return save_tlines(getRepoDataPath(f"{filename}.txt"), lines)
end

function msave_json(filename, tab)
  return save_json(getRepoDataPath(f"{filename}.json"), tab)
end

function msave_jsonl(filename, tab)
  return save_jsonl(getRepoDataPath(f"{filename}.jsonl"), tab)
end

-------------------------------------------------
-- profile load/save functions
-------------------------------------------------

function pload_csv(filename)
  -- this function loads a csv file from the profiles folder
  return load_csv(getProfileDataPath(f"{filename}.csv"))
end

function pload_tlines(filename)
  -- this function loads a text file from the profiles folder
  return load_tlines(getProfileDataPath(f"{filename}.txt"))
end

function pload_json(filename, default)
  return load_json(getProfileDataPath(f"{filename}.json"), default)
end

function pload_jsonl(filename)
  return load_jsonl(getProfileDataPath(f"{filename}.jsonl"))
end

function psave_csv(filename, lines, setting)
  -- this function saves a text file from the profiles folder
  --
  return save_csv(getProfileDataPath(f"{filename}.csv"), lines, setting)
end

function psave_tlines(filename, lines)
  -- this function saves a csv file from the profiles folder
  --
  return save_tlines(getProfileDataPath(f"{filename}.txt"), lines)
end

function psave_json(filename, tab)
  return save_json(getProfileDataPath(f"{filename}.json"), tab)
end

function psave_jsonl(filename, tab)
  return save_jsonl(getProfileDataPath(f"{filename}.jsonl"), tab)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>formatting_text_helper</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

function normalized_text(text) 
  return string.lower(string.gsub(text, "[%c%s]+", ""))
end

function norm_length(strings, orientation, extra)
  local max_len = 0
  if type(orientation) == "number" then
    if (not (orientation == -1)) and (not (orientation == 1)) then
      eprint(
        "Fehler bei der Formatierung: Orientierung muss -1 (rechtsbuendig) oder 1 (linksbuendig) sein."
      )
      return
    end
  else
    orientation = -1
  end
  local len = 0
  for i, v in ipairs(strings) do
    if type(v) == "number" then
      v = tostring(v)
      strings[i] = v
    end
    len = #v
    for m in v:gmatch("&lt;%d+,%d+,%d+:%d+,%d+,%d+&gt;") do
      len = len - #m
    end
    if len &gt; max_len then
      max_len = len
    end
  end
  extra = extra or 0
  local temp
  for i = 1, #strings do
    temp = ""
    len = #strings[i]
    for m in strings[i]:gmatch("&lt;%d+,%d+,%d+:%d+,%d+,%d+&gt;") do
      len = len - #m
    end
    for i = 1, max_len - len + extra do
      temp = temp .. " "
    end
    if orientation == -1 then
      strings[i] = strings[i] .. temp
    else
      strings[i] = temp .. strings[i]
    end
  end
  return strings
end

function norm_table(tab, orientations, extras)
  if type(orientations) == "nil" then
    orientation = {}
    for i = 1, len(tab) do
      table.insert(orientation, -1)
    end
  elseif type(orientations) == "number" then
    local orient = orientations
    orientations = {}
    for i = 1, len(tab) do
      table.insert(orientations, orient)
    end
  end
  if type(extras) == "nil" then
    extras = {}
    for i = 1, len(tab) do
      table.insert(extras, 0)
    end
  elseif type(extras) == "number" then
    local extra = extras
    extras = {}
    for i = 1, len(tab) do
      table.insert(extras, extra)
    end
  end
  for i = 1, len(tab) do
    tab[i] = norm_length(tab[i], orientations[i], extras[i])
  end
  return tab
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>extensions</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>table_extensions</name>
				<packageName></packageName>
				<script>function table.remove_at(tab, index)
  local table_size = len(tab)
  if index &lt; 0 then
    index = table_size + index
    if index &lt; 1 then
      eprint(f("The table has just {table_size} elements, can't remove at position {index}."))
      return false
    end
  end
  if index == 0 or index &gt; len(tab) then
    eprint(f("The table has just {table_size} elements, can't remove at position {index}."))
    return false
  end
  -- shift values
  for i=index+1,len(tab),1 do
    tab[i-1] = tab[i]
  end
  -- remove last element
  table.remove(tab)
  return true
end

function table.add(tab, value)
  if not table.contains(tab, value) then
    table.insert(tab, value)
  end
end

function table.remove_value(tab, value)
  local index = table.index_of(tab, value)
  if not index then
    eprint(f("The table has no value '{value}' to remove."))
    return false
  else
    table.remove_at(tab, index)
    return true
  end
end

function table.values(tab)
  local result = {}
  for _, value in pairs(tab) do
    table.insert(result, value)
  end
  return result
end

function table.get(tab, key, default_value)
  for k, v in pairs(tab) do
    if k == key then
      return v
    end
  end
  return default_value
end

function table.fold(tab, field_name)
  -- transform a table such that the keys 
  -- part of the values.
  -- {st={title="Sandtiger"}} with 
  -- field_name == "name" will return
  -- { {name="st", title="Sandtiger"} }

  local result = {}
  for id, props in pairs(tab) do
    local data = {}
    data[field_name] = id
    for pkey, pvalue in pairs(props) do
      data[pkey] = pvalue
    end
    table.insert(result, data)
  end
  return result
end

function table.unfold(tab, field_name)
  -- inverse to table.fold we move a value
  -- out of the data as a key of the result
  
  local result = {}
  for _, data in spairs(tab) do
    local id = nil
    local props = {}
    for pkey, pvalue in pairs(data) do
      if pkey == field_name then
        id=pvalue
      else
        props[pkey] = pvalue
      end
    end
    result[id] = props
  end
  return result
end

function table.apply(tab, func)
  local result = {}
  for _, v in pairs(tab) do
    table.insert(result, func(v))
  end
  return result
end

function table.subtable(tab, start_index, end_index)
  local result = {}
  for i=start_index,end_index,1 do
    table.insert(result, tab[i])
  end 
  return result
end

function table.indent_lines(tab, indent)
  local new_line = f("\n{indent}")
  local result = f("{indent}{table.concat(tab, new_line)}") 
  return result
end

function table.indent_lines_with_breaks(tab, indent)
  local result = {}
  for _,line in ipairs(tab) do
    table.insert(result, string.indent_lines(line, indent))
  end
  return table.concat(result, "\n")
end

function table.append_table(tab_a, tab_b)
  for _,item in ipairs(tab_b) do
    table.insert(tab_a, item)
  end
end

function table.update(base_table, updates, keep)
  for key, value in pairs(updates) do
    if type(value) == "table" and type(base_table[key]) == "table" then
      table.update(base_table[key], value, keep)
    elseif (base_table[key] == nil) or not keep then
      base_table[key] = value
    end
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>string_extensions</name>
				<packageName></packageName>
				<script>function break_lines(text, length)
  length = length or 59
  local result = {""}
  local index = 1
  for s in text:gmatch("[^%s]+") do
    if len(result[index] .. s) &lt; length then
      if len(result[index]) &gt; 0 then
        result[index] = result[index] .. " " .. s
      else
        result[index] = s
      end
    else
      index = index + 1
      table.insert(result, s)
    end
  end
  return result
end

function substring(text, subtext)
  return string.match(text, subtext)
end

function string.startswith(text, subtext)
  return text:sub(1, #subtext) == subtext
end

function string.endswith(text, subtext)
  return text:sub(-#subtext) == subtext
end

function string.strip(text)
  local start_index = 1
  local end_index = text:len()
  for i=1,text:len(),1 do
    local c=text:sub(i,i)
    if c == " " then
      start_index = i+1
    else
      break
    end
  end
  for i=text:len(),1,-1 do
    local c=text:sub(i,i)
    if c == " " then
      end_index = i-1
    else
      break
    end
  end
  if end_index &lt;= start_index then
    return ""
  else
    return text:sub(start_index, end_index)
  end
end

function string.indent_lines(text, indent)
  local result = {}
  for word in text:gmatch("[^%s]+") do
    local prev = result[len(result)]
    if prev and len(prev) + 1 + len(word) &lt; 78 then
      result[len(result)] = f("{prev} {word}")
    else
      table.insert(result, f("{indent}{word}"))
    end
  end
  return table.concat(result, "\n")
end

function string.rep(txt, size)
  local result = ""
  for _=1,size,1 do
    result = f"{result}{txt}"
  end
  return result
end

function string.fill(text, filler)
  filler = filler or " "
  local left = 76 - len(text)
  local rem = left % 2
  local fill_text = string.rep(filler, ((left-rem) / 2) -1)
  local result = f"{fill_text} {text} {fill_text}"
  if rem &gt; 0 then
    result = f"{result}{filler}"
  end
  return result
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>table_as_class_extension</name>
				<packageName></packageName>
				<script>------------------------------------
---  Meta-table for class objects.
------------------------------------

MundronClassMethods = {["_name"]="MundronClassMethods"}

local function is_meta(key)
  return key:sub(1,1) == "_" and key:sub(1,2) ~= "__"
end

local function is_simple_value(value)
  local t = type(value)
  return t == "string" or t == "number" or t == "boolean"
end

local function add_pair(target, keys, value)
  local pivot = keys[1]
  if #keys ==  1 then
    target[pivot] = value
  else
    if not target[pivot] then
      target[pivot] = {}
    end
    table.remove(keys, 1)
    add_pair(target[pivot], keys, value) 
  end
end

local function add_data(key, data)
  if not MundronClassMethods.data then
    MundronClassMethods.data = {}
  end
  add_pair(MundronClassMethods.data, key:split("%."), data)
end

local function deep_get(source, keys)
  local pivot = keys[1]
  if #keys == 1 then
    return source[pivot]
  else
    table.remove(keys, 1)
    return deep_get(source[pivot], keys)
  end
end

local function get_data(key)
  return deep_get(MundronClassMethods.data, key:split("%."))
end

function MundronClassMethods:version()
  return self._version
end

function MundronClassMethods:meta()
  for k,v in pairs(self) do
    if is_meta(k) then
      print(f"{k}: {v}")
    end
  end
end

function MundronClassMethods:keys(parent)
  local base = self
  if parent ~= nil then
    base = self[parent]
  end
  for k, v in pairs(base) do
    local var_type = type(v)
    if not (is_meta(k) or var_type == "function") then
      if var_type == "table" then
        print(f"{k}: table -&gt; length {len(v)}")
      elseif is_simple_value(v) then
        print(f"{k}: type {var_type} -&gt; {v}")
      end  
    end
  end
end

function MundronClassMethods:load_config()
  self.config = pload_json(self._name, self.config)
end

function MundronClassMethods:load_data()
  if not MundronClassMethods.files then
    return
  end
  -- load profile data
  for _, field in pairs(MundronClassMethods.files.profile or {}) do
    local file_id = field:gsub("%.", "_")
    add_data(field, pload_json(f"{self._name}_{file_id}"))
  end
  -- load game data
  for _, field in pairs(MundronClassMethods.files.game or {}) do
    local file_id = field:gsub("%.", "_")
    add_data(field, mload_json(f"{self._name}_{file_id}"))
  end
end

function MundronClassMethods:save_config()
  psave_json(self._name, self.config)
end

function MundronClassMethods:save_data()
  if not MundronClassMethods.files then
    return
  end
  -- save profile data
  for _, field in pairs(MundronClassMethods.files.profile or {}) do
    local file_id = field:gsub("%.", "_")
    psave_json(f"{self._name}_{file_id}", get_data(field))
  end
  -- save game data
  for _, field in pairs(MundronClassMethods.files.game or {}) do
    local file_id = field:gsub("%.", "_")
    msave_json(f"{self._name}_{file_id}", get_data(field))
  end
end

function MundronClassMethods:compare_meta()

end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>FirstCall</name>
			<packageName></packageName>
			<script>--[[ 
this allows to check if an object is loaded the first time to give 
some initial values and create the save file
]]--

FirstCall = FirstCall or {loaded=false}

local function get_path()
  -- IMPORTANT: Don't use getRepoDataPath with argument to avoid infinite stack!
  -- with an argument, it falls is_first_call where this function is called
  -- from.
  local result = f"{getRepoDataPath()}/first_call_map.json"
  return result
end

function is_first_call(name)
  if not FirstCall.loaded then
    local file = io.open(get_path(), "r")
    if not file then
      FirstCall.loaded = true
      file = io.open(get_path(), "w")
      file:write(json.encode({}))
      file:close()
    else
      FirstCall = json.decode(file:read("*all"))
      file:close()
    end
  end
  return not FirstCall[name]
end

function complete_first_call(name)
  FirstCall[name] = true
  local file = io.open(get_path(), "w")
  file:write(json.encode(FirstCall))
  file:close()
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>initGMCP</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--   Sagt gmcp, dass er alle Daten senden soll --
-------------------------------------------------

function initGMCP()
  if not gmpc_is_initialized then
    sendGMCP([[Core.Supports.Set [ "MG.char 1", "MG.room 1", "comm.channel 1" ] ]])
    if deleteOldProfiles then
      deleteOldProfiles(7)
    end
    gmcp_is_initialized = true
  end
end

function test_gmcp(...)
  if not gmcp or not gmcp.MG then
    return false
  end
  local reference = gmcp.MG
  for _, key in ipairs(arg) do
    if reference[key] then
      reference = reference[key]
    else
      return false
    end
  end
  return true
end</script>
			<eventHandlerList>
				<string>gmcp.Char</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>color_communication</name>
			<packageName></packageName>
			<script>farben = {
  vg = {
    komm = "cyan", 
    ebenen = "red", 
    info = "green", 
    alarm = "white", 
    script = "dark_green"
  },
  bg = {
    komm = "black", 
    ebenen = "black", 
    info = "black", 
    alarm = "red", 
    script = "black"
  },
}
function set_text_color(fg_type, bg_type)
  local fg_color = farben.vg[fg_type] or fg_type
  local bg_color = farben.bg[bg_type] or bg_type or farben.bg[fg_type] or fg_color
  fg(fg_color)
  bg(bg_color)
end

function color_communication()
  set_text_color("ebenen")
  echo(gmcp.comm.channel.msg)
  resetFormat()
end

function set_line_color(fg_type, bg_type)
  select_line_color(fg_type, bg_type)
  resetFormat()
end

function select_line_color(fg_type, bg_type)
  selectCurrentLine()
  set_text_color(fg_type, bg_type)
end</script>
			<eventHandlerList>
				<string>gmcp.comm.channel</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>Trigger</name>
			<packageName></packageName>
			<script>TRIGGER = TRIGGER or {}</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>misc</name>
			<packageName></packageName>
			<script>function log(text)
  local timestamp = os.date("%Y-%m-%d#%H-%M", os.time())
  local file = io.open(getProfileDataPath("debug.log"), "a")
  file:write(f"{timestamp} - {text}\n")
  file:close()
end

function len(obj)
  if type(obj) == "string" then
    return string.len(obj)
  elseif type(obj) == "table" then
    return table.size(obj)
  else
    return 0
  end
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>test</name>
			<packageName></packageName>
			<script>local test = setmetatable({
  _name = "test",
}, {__index=MundronClassMethods})

print("Start")
display(test)

print("Regular")
test:keys()
print("done")
</script>
			<eventHandlerList />
		</Script>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
