<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage />
	<TimerPackage />
	<AliasPackage>
		<Alias isActive="yes" isFolder="no">
			<name>globale_Hilfe</name>
			<script>GOR:show_global_help()</script>
			<command></command>
			<packageName></packageName>
			<regex>^\?$</regex>
		</Alias>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>MC_init_colors</name>
			<packageName></packageName>
			<script>function MC_init_colors()
  return farben or  {
    vg = {
      komm = "cyan", 
      ebenen = "red", 
      info = "green", 
      alarm = "white", 
      script = "dark_green"
    },
    bg = {
      komm = "black", 
      ebenen = "black", 
      info = "black", 
      alarm = "red", 
      script = "black"
    },
  }
end

farben = MC_init_colors()</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>misc</name>
			<packageName></packageName>
			<script>function log(text)
  local timestamp = os.date("%Y-%m-%d#%H-%M", os.time())
  local file = io.open(getProfileDataPath("debug.log"), "a")
  file:write(f"{timestamp} - {text}\n")
  file:close()
end

function len(obj)
  if type(obj) == "string" then
    local slen = string.len(obj)
    for match in obj:gmatch("&lt;%d+,%d+,%d+:%d+,%d+,%d+&gt;") do
      slen = slen - #match
    end
    for match in obj:gmatch("&lt;%d+,%d+,%d+&gt;") do
      slen = slen - #match
    end
    return slen
  elseif type(obj) == "table" then
    return table.size(obj)
  else
    return 0
  end
end

function colored_text(text)
  if type(text) == "table" then
    local farbe = TEXT_FARBEN[text[2]]
    text = f"{farbe or text[2]}{text[1]}"
  elseif type(text) == "number" then
    text = tostring(text)
  end
  return text
end

function text_len(text)
  text = colored_text(text)
  local slen = string.len(text)
  for match in text:gmatch("&lt;%d+,%d+,%d+:%d+,%d+,%d+&gt;") do
    slen = slen - #match
  end
  for match in text:gmatch("&lt;%d+,%d+,%d+&gt;") do
    slen = slen - #match
  end
  return slen
end

function zip(...)
  local lists = { ... }
  local i = 0

  return function()
    i = i + 1

    local out = {}
    for _, list in pairs(lists) do
      if not list[i] then
        return nil
      end
      table.insert(out, list[i])
    end
    return unpack(out)
  end
end

function parse_date(date)
  local d, m, y = date:match("(%d+)\.(%d+)\.(%d+)")
  d, m, y = tonumber(d), tonumber(m), tonumber(y)
  y = y &lt; 100 and 2000+y or y
  display(d, m, y)
  return os.time({year = y, month = m, day = d})  
end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>html_unescape</name>
			<packageName></packageName>
			<script>-- Decodes a subset of common HTML entities.
-- Safe for typical MUD/Mudlet use-cases where you mainly see &amp;lt; &amp;gt; &amp;amp; &amp;quot; &amp;#39; etc.
function html_unescape(s)
  if type(s) ~= "string" then return s end

  -- Numeric entities first (&amp;#...; and &amp;#x...;)
  s = s:gsub("&amp;#x(%x+);", function(hex)
    local n = tonumber(hex, 16)
    if not n then return "&amp;#x" .. hex .. ";" end
    return utf8 and utf8.char(n) or string.char(n)
  end)

  s = s:gsub("&amp;#(%d+);", function(dec)
    local n = tonumber(dec, 10)
    if not n then return "&amp;#" .. dec .. ";" end
    return utf8 and utf8.char(n) or string.char(n)
  end)

  -- Named entities (order matters: &amp;amp; last)
  s = s:gsub("&amp;quot;", '"')
       :gsub("&amp;#39;", "'")
       :gsub("&amp;apos;", "'")
       :gsub("&amp;lt;", "&lt;")
       :gsub("&amp;gt;", "&gt;")
       :gsub("&amp;nbsp;", " ")
       :gsub("&amp;amp;", "&amp;")

  return s
end

-- Example:
-- print(html_unescape("a &amp;lt; b &amp;amp;&amp;amp; c &amp;gt; d"))  --&gt; a &lt; b &amp;&amp; c &gt; d
</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>GlobalObjectRegister</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>GOR_init</name>
				<packageName></packageName>
				<script>GOR = GOR or {
  objects={}, 
  modules={}, 
  aliases={},
  short_to_long={}
}

function GOR:add_object(obj)
  self.objects[obj._name] = obj
  self.short_to_long[obj:shortname()] = obj:name()
  self:add_module(obj._module)  
end

function GOR:add_module(mname)
  if table.get(self, {"modules", mname}) then
    return
  end
  table.set(self, {"modules", mname}, load_and_parse_xml(getModulePath(mname)))
  self:process_module(mname)
  self:build_help()
end

function GOR:reset()
  self.aliases = {}
  local mname = "EK_Tracker"
  self.modules[mname] = nil
  self:add_module(mname)
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>GOR_process_module</name>
				<packageName></packageName>
				<script>local function color_pattern(pattern)
  local result = ""
  for _, word in pairs(pattern:split(" ")) do
    if string.endswith(word, "?") then
      word = colored_text({word, 'o'})
    elseif string.startswith(word, "&lt;") then
      word = colored_text({word, 'ly'})
    else
      word = colored_text({word, 'g'})    
    end
    result = f"{result} {word}"
  end
  return result
end

local function parse_alias_script_comments(script)
  local result = {pattern="", desc={}}
  for _, line in pairs(script:split("\n")) do
    if line:find("---@desc") then
      line = html_unescape(line:gsub("---@desc ", ""))
      table.insert(result.desc, line)
    end
    if line:find("---@pattern") then
      line = html_unescape(line:gsub("---@pattern ", ""))
      result.pattern = color_pattern(line)
    end
  end
  return result
end

local function process_Alias(alias)
  local result = {tag="Alias"}
  for _, child in pairs(alias) do
    if child.tag == "name" then
      result.name = child.text
    elseif child.tag == "script" then
      table.update(result, parse_alias_script_comments(child.text))
    elseif child.tag == "regex" then
      result.regex = child.text
    end
  end
  return result
end

local function process_AliasGroup(alias_group)
  local name
  local aliases, groups = {}, {}
  local count = 0
  for _, child in pairs(alias_group) do
    if child.tag == "name" then
      name = html_unescape(child.text)
    elseif child.tag == "AliasGroup" then
      local sgroup = process_AliasGroup(child.children)
      if sgroup.count &gt; 0 then
        table.insert(groups, sgroup)
        count = count + sgroup.count
      end
    elseif child.tag == "Alias" then
      table.insert(aliases, process_Alias(child.children))
      count = count + 1
    end
  end
  --
  if name:find("Help") then
    aliases, groups ={}, {}
    count = 0
  end
  return {
    name=name, 
    tag="AliasGroup", 
    aliases=aliases, 
    groups=groups, 
    depth=0,
    count=count
  }
end

local function process_AliasPackage(alias_package)
  local result = {unassigned={}, groups={}}
  for _, child in pairs(alias_package) do
    if child.tag == "Alias" then
      table.insert(result.unassigned, process_Alias(child.children))
    elseif child.tag == "AliasGroup" then
      local group = process_AliasGroup(child.children)
      if group.count &gt; 0 then
        table.insert(result.groups, group)
      end
    end
  end
  return result
end

local function process_MudletPackage(package)
  for _, child in pairs(package.children) do
    if child.tag == "AliasPackage" then
      return process_AliasPackage(child.children)
    end
  end
end

local function merge_aliases(ali1, ali2)
  local names = {}
  for _, alias in pairs(ali1) do names[alias.name] = true end
  for _, alias in pairs(ali2) do
    if not names[alias.name] then
      table.insert(ali1, alias)
      names[alias.name] = true
    end
  end
end

local function combine_tables(tab1, tab2)
  merge_aliases(tab1.aliases, tab2.aliases)
  local new_groups = {}
  for _, group in pairs(tab2.groups) do
    merged = false
    for _, agroup in pairs(tab1.groups) do
      if group.name == agroup.name then
        combine_tables(agroup, group)
        merged = true
        break
      end
    end
    if not merged then
      table.insert(new_groups, group)
      tab1.depth = math.max(tab1.depth, group.depth)
      tab1.count = tab1.count + group.count
    end
  end
  table.append_table(tab1.groups, new_groups)
end

local function compute_metrics(group)
  local count = len(group.aliases)
  local depth = 0

  for _, g in pairs(group.groups) do
    compute_metrics(g)
    count = count + (g.count or 0)
    depth = math.max(depth, (g.depth or 0) + 1)
  end

  group.count = count
  group.depth = depth
end

function GOR:process_module(name)
  local package = process_MudletPackage(self.modules[name])
  merge_aliases(table.get(GOR, "aliases.UNASSIGNED", {}), package.unassigned)
  for _, group in pairs(package.groups) do
    local oname = f"aliases.{group.name}"
    local old_group = table.get(GOR, oname)
    if not old_group then
      compute_metrics(group)
      table.set(GOR, oname, group)
    else
      combine_tables(old_group, group)
      compute_metrics(old_group)    
    end
    local object = self.objects[group.name]
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>GOR_aliases_check</name>
				<packageName></packageName>
				<script>local function count_undescriped_aliases(group)
  local count = 0
  for _, alias in pairs(group.aliases or {}) do
    if not alias.description then
      count = count + 1
    end
  end
  for _, subgroup in pairs(group.groups or {}) do
    count = count + count_undescriped_aliases(subgroup)
  end
  return count
end

function GOR:aliases_check()
  self:info("Unassigned aliases:")
  print(string.rep("=", 50))
  local total = len(GOR.aliases.UNASSIGNED)
  local msg = {"First-level aliases: ", {total, "y"}, "unassigned"}
  print(msg)
  print(string.rep("-",50))
  local tab = {{" Unknown object ", "Count"}}
  for name, group in pairs(GOR.aliases) do
    if name ~= "UNASSIGNED" and not GOR.objects[name] then
      table.insert(tab, {f" '{name}' ", {group.count, "y"}})
      total = total + group.count
    end
  end
  print_table(tab, {0, 1})
  print(string.rep("-",50))
  msg = {"Total unassigned aliases: ", {total, "y"}}
  print(msg)
  print(string.rep("=", 50))
  tab = {{" Object ", "Count"}}
  local undesc = 0
  for name, group in pairs(GOR.aliases) do
    if name ~= "UNASSIGNED" and GOR.objects[name] then
      local subcount = count_undescriped_aliases(group)
      table.insert(tab, {f" '{name}' ", {subcount, "y"}})
      undesc = undesc + subcount
    end
  end
  print_table(tab, {0, 1})
  print(string.rep("-",50))
  msg = f"Total undescriped aliases: {undesc}"
  print(msg)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>GOR_versions</name>
				<packageName></packageName>
				<script>function GOR:versions()
  print(string.rep("=", 50))
  for name, mtab in pairs(self.objects) do
    print(f"{name} -&gt; '{mtab._version}'")
  end
end

function GOR:versions_hist()
  print(string.rep("=", 50))
  for name, mtab in pairs(self.objects) do
    print(name)
    for _, key in pairs({"profile", "game"}) do
      local versions = json.encode_oneline(mtab._versions[key])
      local msg = f"  {key} -&gt; '{versions}'"
      print(msg)
    end
  end
end

function GOR:load_versions(key)
  print(string.rep("=", 50))
  for name, mtab in pairs(self.objects) do
    local fn = mtab:filename("versions")
    local msg = f"{name} -&gt; {json.encode_oneline(mtab:fetch_from_(key, fn))}"
    print(msg)
  end
end

function GOR:reset_versions()
  print(string.rep("=", 50))
  for _, mtab in pairs(self.objects) do
    premove_json(mtab:filename("versions"))
    mremove_json(mtab:filename("versions"))
    local msg = f"{mtab:shortname()} - reset"
    print(msg)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>GOR_log</name>
				<packageName></packageName>
				<script>function GOR:warn_logs()
  local log = {}
  for name, obj in pairs(self.objects) do
    for _, line in pairs(obj.log_buffer) do
      local level = string.upper(line[2])
      if level == "WARN" then
        table.insert(log, {line[1], {level, "y"}, name, line[3]})    
      end
    end
  end
  if len(log) == 0 then
    GOR:info("No warning logs found")
  else
    print_table(log)
  end
end

function GOR:error_logs()
  local log = {}
  for name, obj in pairs(self.objects) do
    for _, line in pairs(obj.log_buffer) do
      local level = string.upper(line[2])
      if level == "ERROR" then
        table.insert(log, {line[1], {level, "lr"}, name, line[3]})    
      end
    end
  end
  if len(log) == 0 then
    GOR:info("No warning logs found")
  else
    print_table(log)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>GOR_misc</name>
				<packageName></packageName>
				<script>function GOR:keys()
  print(string.rep("=", 50))
  for key, value in pairs(self) do
    if type(value) == "table" then
      print(f"{key} -&gt; {type(value)} - size={len(value)}")
    else
      print(f"{key} -&gt; {type(value)}")
    end 
  end
end

function GOR:shortnames()
  print(string.rep("=", 50))
  for name, mtab in pairs(self.objects) do
    print(f"{name} -&gt; '{mtab._shortname or '~ no short name~'}'")
  end
end

function GOR:info(text)
  iprint(text, "GOR")
end

function GOR:warn(text)
  wprint(text, "GOR")
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>GOR_help</name>
				<packageName></packageName>
				<script>function GOR:show_global_help()
  local msg = {{{"  Befehl", "ly"}, {"Name", "ly"}, {"Vorhanden", "ly"}}}
  for name, group in pairs(self.aliases) do 
    local obj = GOR.objects[name]
    if obj then
      table.insert(msg, {
        {f"  ?{obj:shortname()}", "b"}, 
        obj:name(),
        f"{group.count} Aliase"
      })
    end
  end
  self:info("Hilfe-Aliase f√ºr Module")
  print(string.rep("=", 50))
  print_table(msg, {-1, -1, 1})
end

local function build_specific_help(object)
  local _help_group = object:shortname("Help")
  if exists(_help_group, "alias") &gt; 0 then
    return
  end
  GOR:info(f"Build help {_help_group}")
  permGroup(_help_group, "alias", object._module)
  permAlias(
    object:shortname("high_help"), 
    _help_group, 
    f"^\\?{object:shortname()}$", 
    f'GOR:show_help("{object:shortname()}")')
  permAlias(
    object:shortname("deep_help"), 
    _help_group, 
    f"^\\?{object:shortname()} (\\d+(.\\d+)*)$", 
    f'GOR:show_help("{object:shortname()}", matches[2])')
end

function GOR:build_help()
  for name, group in pairs(self.aliases) do
    if self.objects[name] then
      build_specific_help(self.objects[name])
    end
  end
end

local function get_item(group, keys, idx)
  if group == nil then
    return nil
  end
  idx = idx or 1
  local pivot = keys[idx]
  if idx == #keys then
    if pivot &lt;= len(group.aliases) then
      return group.aliases[pivot]
    elseif pivot &lt;= len(group.aliases)+len(group.groups) then
      return group.groups[pivot - len(group.aliases)]
    else
      return nil
    end
  elseif pivot &lt; len(group.aliases) then
    return nil
  elseif pivot &lt;= len(group.aliases)+len(group.groups) then
    return get_item(group.groups[pivot - len(group.aliases)], keys, idx + 1)
  else
    return nil
  end
end

function GOR:show_help(name, key)
  local item = self.aliases[name] or self.aliases[self.short_to_long[name]]
  if not item then
    self:warn(f"Ungueltiger Objektname {name}")
    return
  end
  local orig_key = key
  if key then
    key = table.apply(key:split("%."), tonumber)
    item = get_item(item, key)
  end
  if not item then
    self:warn(f"Ungueltiger Pfad '{orig_key}'")
    return
  end
  if item.tag == "AliasGroup" then
    GOR:describe_aliasgroup(item)
    print(string.rep("-", 50))
    local msg = {"   Details mit"}
    if orig_key then
      table.insert(msg, {f"?{name} {orig_key}.&lt;Nummer&gt;", "ly"})
    else
      table.insert(msg, {f"?{name} &lt;Nummer&gt;", "ly"})
    end
    print(msg)
  else
    GOR:describe_alias(item)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>GOR_describe</name>
				<packageName></packageName>
				<script>function GOR:describe_alias(item)
  self:info("Details zum Alias")
  local tab = {
    {{"Pattern: ", "g"}, item.pattern or ""},
    {{"Regex: ", "g"}, item.regex or ""},
    {{"Beschreibung: ", "g"}, item.name or ""},
  }
  for _, line in pairs(item.desc or {}) do
    table.insert(tab, {"", line})
  end
  print(string.rep("-", 50))
  print_table(tab)
end

function GOR:describe_aliasgroup(item)
  self:info({
    "In ", {f"'{item.name}'", "y"},
    "gibt es \n",
    f"{len(item.aliases)} Aliase und {len(item.groups)} Alias-Gruppen"
  })
  local tab = {}
  for _, alias in pairs(item.aliases) do
    table.insert(tab, {len(tab)+1, {" Alias ", "g"}, alias.pattern or ""})
  end
  for _, group in pairs(item.groups) do
    table.insert(tab, {len(tab)+1, {" Gruppe ", "ly"}, group.name})  
  end
  print(string.rep("-", 50))
  print_table(tab, {1, -1,-1})
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>helper_functions</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>ensure_folder</name>
				<packageName></packageName>
				<script>-- Ensures that `path` exists as a directory.
-- Always halts execution via printError(..., true, true) on failure.
function ensure_folder(path)
  if type(path) ~= "string" or path == "" then
    printError(f"Invalid path {path} of type {type(path)}.", true, true)
    return false
  end

  -- Normalize: strip trailing slashes (except root "/")
  path = path:gsub("/+$", "")
  if path == "" then path = "/" end

  -- Compute parent directory
  local parent = path:match("^(.*)/[^/]+$")
  if not parent then
    printError(f"Invalid path: {path}")
  end

  -- 1) Parent must exist and be a directory
  local p_attr = lfs.attributes(parent)
  if not p_attr then
    printError(f"Parent path does not exist: {parent} from {path}", true, true)
    return false
  end
  if p_attr.mode ~= "directory" then
    printError(f"Parent path is not a directory: {parent} from {path}", true, true)
    return false
  end

  -- 2) Check target path
  local attr = lfs.attributes(path)
  if attr then
    if attr.mode == "directory" then
      return true
    else
      printError(f"Path exists but is not a directory: {path}", true, true)
      return false
    end
  end

  -- 3) Create target directory (single-level; parent must already exist)
  local ok, err = lfs.mkdir(path)
  if not ok then
    printError(f"Failed to create directory '{path}': {tostring(err)}", true, true)
    return false
  end

  return true
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>json_helper</name>
				<packageName></packageName>
				<script>--[[
  Converter of serializable Lua objects to JSON strings and backwards
  Usage:
  json.encode_oneline({42, 23, 12}) --&gt; "[42, 23, 12]"
  json.encode({42, 23, 12}) --&gt;
  [
    42,
    23,
    12
  ]
  json.decode('{"apple": 13, "tree": true}') --&gt; {["apple"] = 13, ["tree"] = true}
]]--

json = {
  _version = "1.0.0",
  _author = "Mundron",
  _contact = "https://github.com/Mundron",
  _repository = "https://github.com/Mundron/Morgengrauen_tools"
}

local escape_char_map = {
  ["/"] = "\\/",
  ['"'] = '\\"',
  ["\b"] = "\\b",
  ["\f"] = "\\f",
  ["\n"] = "\\n",
  ["\r"] = "\\r",
  ["\t"] = "\\t",
}

local escape_char_map_inv = {["\\\\"]="\\"}
for k, v in pairs(escape_char_map) do
  escape_char_map_inv[v] = k
end

local function escaped_string(value)
  -- Escape backslash first to avoid double-escaping
  value = value:gsub("\\", "\\\\")
  for k, v in pairs(escape_char_map) do
    if k ~= "\\" then  -- Already handled
      value = value:gsub(k, v)
    end
  end
  return '"' .. value .. '"'
end

local function isArray(value)
  local count = 0
  for k, v in pairs(value) do
    count = count + 1
    if type(k) ~= "number" or k ~= count then
      return false
    end
  end
  return true
end

function json.encode(value, indent)
  indent = indent or 0
  local indentStr = string.rep("  ", indent)
  local nextIndentStr = string.rep("  ", indent + 1)
    
  local valueType = type(value)
  if value == nil then
    return "null"
  elseif valueType == "boolean" then
    return tostring(value)
  elseif valueType == "number" then
    return tostring(value)
  elseif valueType == "string" then
    return escaped_string(value)        
  end
  
  if valueType == "table" then
    if isArray(value) then
      if #value == 0 then
        return "[]"
      else
        local parts = {}
        for i = 1, #value do  -- FIX: was using undefined 'count'
          table.insert(parts, nextIndentStr .. json.encode(value[i], indent + 1))
        end
        return "[\n" .. table.concat(parts, ",\n") .. "\n" .. indentStr .. "]"
      end
    else
      local parts = {}
      for k, v in pairs(value) do
        local key
        if type(k) == "string" then
          key = escaped_string(k)
        elseif type(k) == "number" then
          key = tostring(k)
        else
          error(f"Invalid key type: {type(k)}")
        end
        table.insert(parts, f"{nextIndentStr}{key}: {json.encode(v, indent + 1)}")
      end
      -- Sort for consistent output
      table.sort(parts)
      return "{\n" .. table.concat(parts, ",\n") .. "\n" .. indentStr .. "}"
    end
  end
  
  error("Unsupported type: " .. valueType)
end

function json.encode_oneline(value)
  local result = json.encode(value)
  result = result:gsub("[\r\n]+", "")
  return result
end

-- JSON to Lua table parser
function json.decode(str)
  local pos, error_flag = 1, false
  
  local function decode_error(msg)
    printError(f"JSON decode error at position {pos}: {msg} - {str:sub(pos-10,pos+10)}", true, true)
    error_flag = true
  end
  
  local whitespace = {" ", "\t", "\n", "\r"}
  
  local function skip_whitespace()
    while table.contains(whitespace, str:sub(pos, pos)) and pos &lt;= #str do
      pos = pos + 1
    end
  end
  
  local function parse_string()
    if str:sub(pos, pos) ~= '"' then
      decode_error("Expected string")
    end
    pos = pos + 1  -- Skip opening quote
    
    local result = {}
    while pos &lt;= #str do
      local c = str:sub(pos, pos)
      
      if c == '"' then
        pos = pos + 1  -- Skip closing quote
        return table.concat(result)
      elseif c == "\\" then
        -- Handle escape sequences
        local escape = str:sub(pos, pos + 1)
        if escape_char_map_inv[escape] then
          table.insert(result, escape_char_map_inv[escape])
          pos = pos + 2
        elseif str:sub(pos + 1, pos + 1) == "u" then
          -- Unicode escape \uXXXX - simplified handling
          local hex = str:sub(pos + 2, pos + 5)
          local codepoint = tonumber(hex, 16)
          if codepoint then
            table.insert(result, string.char(codepoint))
          end
          pos = pos + 6
        else
          decode_error("Invalid escape sequence")
        end
      else
        table.insert(result, c)
        pos = pos + 1
      end
    end
    
    decode_error("Unterminated string")
  end -- function parse_string
  
  local function parse_number()
    local start_pos = pos
    local has_decimal = false
    local has_exponent = false
    
    -- Optional minus sign
    if str:sub(pos, pos) == "-" then
      pos = pos + 1
    end
    
    -- Digits before decimal point
    if not str:sub(pos, pos):match("%d") then
      decode_error("Invalid number")
    end
    
    while pos &lt;= #str and str:sub(pos, pos):match("%d") do
      pos = pos + 1
    end
    
    -- Optional decimal part
    if pos &lt;= #str and str:sub(pos, pos) == "." then
      has_decimal = true
      pos = pos + 1
      if not str:sub(pos, pos):match("%d") then
        decode_error("Invalid number")
      end
      while pos &lt;= #str and str:sub(pos, pos):match("%d") do
        pos = pos + 1
      end
    end
    
    -- Optional exponent
    if pos &lt;= #str and (str:sub(pos, pos) == "e" or str:sub(pos, pos) == "E") then
      has_exponent = true
      pos = pos + 1
      if str:sub(pos, pos) == "+" or str:sub(pos, pos) == "-" then
        pos = pos + 1
      end
      if not str:sub(pos, pos):match("%d") then
        decode_error("Invalid number")
      end
      while pos &lt;= #str and str:sub(pos, pos):match("%d") do
        pos = pos + 1
      end
    end
    
    return tonumber(str:sub(start_pos, pos - 1))
  end -- function parse_number
  
  local function parse_value()
    skip_whitespace()
    
    local c = str:sub(pos, pos)
    
    if str:sub(pos, pos + 3) == "null" then
      pos = pos + 4
      return nil
    elseif str:sub(pos, pos + 3) == "true" then
      pos = pos + 4
      return true
    elseif str:sub(pos, pos + 4) == "false" then
      pos = pos + 5
      return false
    elseif c == '"' then
      return parse_string()
    elseif c == "-" or c:match("%d") then
      return parse_number()
    elseif c == "[" then
      pos = pos + 1
      skip_whitespace()
      
      local arr = {}
      
      -- Empty array
      if str:sub(pos, pos) == "]" then
        pos = pos + 1
        return arr
      end
      
      while pos &lt;= #str do
        table.insert(arr, parse_value())
        skip_whitespace()
        
        local next_char = str:sub(pos, pos)
        if next_char == "]" then
          pos = pos + 1
          return arr
        elseif next_char == "," then
          pos = pos + 1
          skip_whitespace()
        else
          decode_error("Expected ',' or ']' in array")
        end
      end
    end
    
    -- object
    if c == "{" then
      pos = pos + 1
      skip_whitespace()
      
      local obj = {}
      
      -- Empty object
      if str:sub(pos, pos) == "}" then
        pos = pos + 1
        return obj
      end
      
      while pos &lt;= #str do
        skip_whitespace()
        
        -- Parse key
        local key = parse_value()
        skip_whitespace()
        
        if str:sub(pos, pos) ~= ":" then
          decode_error("Expected ':' after object key")
        end
        pos = pos + 1
        
        -- Parse value
        obj[key] = parse_value()
        skip_whitespace()
        
        local next_char = str:sub(pos, pos)
        if next_char == "}" then
          pos = pos + 1
          return obj
        elseif next_char == "," then
          pos = pos + 1
        else
          decode_error("Expected ',' or '}' in object")
        end
      end -- while
    end -- object parsing
    
    decode_error("Unexpected character: " .. c)
  end -- function parse_value
  
  local result = parse_value()
  skip_whitespace()
  
  if pos &lt;= #str then
    decode_error("Unexpected content after JSON value")
  end
  
  return result
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>pathes_helper</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
local folder_pattern, file_pattern = "^[%w_]+$", "^[%w_]+%.%w+$"

function ensure_extension(root, extension)
  if len(extension) == 0 then
    return root
  end
  local folder, ext = extension:match("^(.-)/(.*)$")
  if folder then
    if not folder:match(folder_pattern) then
      printError(f"Invalid path {root} with extension {extension}", true, true)
    end
    root = f"{root}/{folder}"
    ensure_folder(root)
    return ensure_extension(root, ext)
  end
  root = f"{root}/{extension}"
  if extension:match(folder_pattern) then
    ensure_folder(root)
    return root
  end
  if extension:match(file_pattern) then
    return root 
  end
  printError(f"Invalid path {root} because '{extension}' doesn't fit folder/file naming.", true, true)
end

function getRepoPath(extension)
  return ensure_extension(getModulePath("Mundron_Core"):match("(.*)/[^/]*/[^/]"), extension)
end

function getRepoDataPath(extension)
  extension = extension and f"/{extension}" or ""
  return getRepoPath(f"data{extension}")
end

function getRepoPicturePath(extension)
  extension = extension and f"/{extension}" or ""
  return getRepoPath(f"pictures{extension}")
end


function getProfileDataPath(extension)
  extension = extension and f"/{extension}" or ""
  return ensure_extension(getMudletHomeDir(), f"data{extension}")
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>colored_print_helper</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Here are three colored echos        --
--                                             --
-------------------------------------------------

TEXT_FARBEN = {
  r = "&lt;235,80,80:0,0,0&gt;",
  g = "&lt;155,255,0:0,0,0&gt;",
  b = "&lt;120,170,255:0,0,0&gt;",
  lr = "&lt;255,140,140:0,0,0&gt;",
  lg = "&lt;0,255,0:0,0,0&gt;",
  lb = "&lt;200,230,255:0,0,0&gt;",
  o = "&lt;255,155,55:0,0,0&gt;",
  l = "&lt;155,155,255:0,0,0&gt;",
  y = "&lt;255,255,0:0,0,0&gt;",
  ly = "&lt;255,255,0:0,0,0&gt;",
  c = "&lt;0,255,255:0,0,0&gt;",
  m = "&lt;255,0,255:0,0,0&gt;",
}
  
function print_help(filename, verbose)
  for _, line in ipairs(mload_jsonl(filename)) do
    for _, txt in ipairs(line) do
      print(txt)
      if not verbose then
        break
      end
    end
  end
end

local function get_prefix(keyword, reference)
  local result = ""
  if reference then
    result = f("{keyword} ({reference}): ")
  else
    result = f("{keyword}: ")
  end
  return result
end

function wprint(text, reference)
  echo("\n")
  print(text, {get_prefix("WARNUNG", reference), "&lt;255,255,0:0,0,0&gt;"})
  echo("\n")
end

function eprint(text, reference)
  echo("\n")
  print(text, {get_prefix("FEHLER", reference), "&lt;255,155,0:0,0,0&gt;"})
  echo("\n")
end

function iprint(text, reference)
  print(text, {get_prefix("INFO", reference), "&lt;120,170,255:0,0,0&gt;"})
end

  
local function print_with_breaks(text, pre)
  pre = pre or {"", ""}
  decho(f("{pre[2]}{pre[1]}"))
  local pre_len = len(pre[1])
  local pseudo_pre = ""
  for i = 1, pre_len, 1 do
    pseudo_pre = f("{pseudo_pre} ")
  end
  local line_size = pre_len
  for _, text_part in ipairs(text) do
    woerter = text_part[1]
    farbe = TEXT_FARBEN[text_part[2]] or ""
    for _, word in ipairs(string.split(woerter)) do
      -- check if word contains line break symbols
      local word_tab = string.split(word, "\n")
      if len(word_tab) == 1 then
        if line_size + #word &lt; 78 then
          decho(f("{farbe}{word} "))
          line_size = line_size + #word + 1
        else
          decho(f("\n{pseudo_pre}{farbe}{word} "))
          line_size = pre_len + #word + 1
        end
      else
        if line_size + #word_tab[1] &lt; 78 then
          decho(f("{farbe}{word_tab[1]}"))
        else
          decho(f("\n{pseudo_pre}{farbe}{word_tab[1]}"))
        end
        for i=2,len(word_tab),1 do
          if len(word_tab[i]) == 0 then
            decho(f("\n{pseudo_pre}"))
            line_size = pre_len
          else
            decho(f("\n{pseudo_pre}{farbe}{word_tab[i]} "))
            line_size = pre_len + len(word_tab[1]) + 1
          end
        end
      end
    end
  end
  echo("\n")
end

function print(text, pre)
  if type(pre) == "string" then
    pre = {pre, nil}
  end
  if type(text) == "string" then
    print_with_breaks({{text, nil}}, pre)
  elseif type(text) == "table" then
    new_text = {}
    for _, t in pairs(text) do
      if type(t) == "string" then
        table.insert(new_text, {t, nil})
      elseif type(t) == "table" then
        table.insert(new_text, t)
      end
    end
    print_with_breaks(new_text, pre)
  end
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>formatting_text_helper</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

function normalized_text(text) 
  return string.lower(string.gsub(text, "[%c%s]+", ""))
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>print_table</name>
				<packageName></packageName>
				<script>local function format_text(text, size, orient, margin)
  orient = orient or -1
  if type(text) == "number" then
    text = tostring(text)
  elseif type(text) == "table" then
    local farbe = TEXT_FARBEN[text[2]]
    if farbe then
      text = f"{farbe}{text[1]}"
    else
      text = f"{text[2]}{text[1]}"
    end
  end
  size = size - len(text)
  local lsize, rsize = margin, size+margin -- for right oriented text
  if orient == 0 then
    lsize = math.floor(size / 2) + margin
    rsize = size - lsize + margin
  elseif orient == 1 then
    lsize, rsize = size+margin, margin
  end
  local result = f"{string.rep(' ', lsize)}{text}{string.rep(' ', rsize)}"
  return result
end

local function table_sizes(tab)
  local sizes = {}
  for _, line in pairs(tab) do
    for i, cell in ipairs(line) do
      sizes[i] = math.max(sizes[i] or 0, text_len(cell))
    end
  end
  return sizes
end

local function norm_meta(tab, value, default)
  if type(value) == "table" then
    if len(value) &lt; len(tab) then
      table.append_table(value, table.rep(default, len(tab)-len(value)))
    end
    return value
  end
  local result = {}
  for i = 1, len(tab[1]) do
    table.insert(result, value or default)
  end
  return result
end

local function norm_table(tab, orients, margins)
  orients = norm_meta(tab, orients, -1)
  margins = norm_meta(tab, margins, 1)
  sizes = table_sizes(tab)
  local result = {}
  for _, line in pairs(tab) do
    local new_line = {}
    for cell, size, orient, margin in zip(line, sizes, orients, margins) do
      table.insert(new_line, format_text(cell, size, orient, margin))
    end
    table.insert(result, new_line)
  end
  return result
end


function print_table(tab, orient, margin)
  tab = norm_table(tab, orient, margin)
  for _, line in pairs(tab) do
    for _, cell in pairs(line) do
      decho(cell)
    end
    echo("\n")
  end
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>io_helper</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>io_load_base</name>
				<packageName></packageName>
				<script>-------------------------------------------------
-- generel load/save functions
-------------------------------------------------
local function generic_load(path, read, save, default)
  if not path then
    printError("Kein Dateiname zum Laden gegeben.", true, true)
  end
  if io.exists(path) then
    local file = io.open(path, "r")
    local result = read(file, path)
    if not FirstCall:is_first_call(path) then
      FirstCall:complete_first_call(path)
    end
    return result
  elseif FirstCall:is_first_call(path) then
    save(default, path)
    FirstCall:complete_first_call(path)
    return default
  else
    local msg = f"Datei {path} zum Laden nicht gefunden"
    printError(msg, true, true)
  end
end



function load_csv(path)
  local read = function(_, path)
    local result = {}
    for line in io.lines(path) do
      table.insert(result, string.split(line, ";"))
    end
    return result
  end
  return generic_load(path, read, save_csv, {})
end

function load_tlines(path)
  local read = function(_, path)
    local lines = {}
    for sline in io.lines(path) do
      sline = sline:gsub("\r", "")
      table.insert(lines, sline)
    end
    return lines
  end
  return generic_load(path, read, save_tlines, {})
end

function load_json(path, default)
  local read = function(file)
    local content = file:read("*all")
    return json.decode(content)
  end
  return generic_load(path, read, save_json, default or {})
end

function load_jsonl(path)
  local read = function(_, path)
    local lines = {}
    for sline in io.lines(path) do
      table.insert(lines, json.decode(sline))
    end
    return lines
  end
  return generic_load(path, read, save_jsonl, {})  
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>io_save_base</name>
				<packageName></packageName>
				<script>-------------------------------------------------
-- generel load/save functions
-------------------------------------------------

function save_csv(lines, path, setting)
  -- delimiter is ; because , are used in descriptions
  if #lines == 0 and io.exists(path) then
    eprint(f"Versuch die Datei {path} leer zu ueberschreiben verhindert!")
    return
  end
  local file = io.open(path, "w")
  local temp
  if setting then
    if type(setting) == 'table' then
      file:write(table.concat(setting, ";"), "\n")
    else
      file:write(setting, "\n")
    end
  end
  for k, v in ipairs(lines) do
    if type(v) == 'table' then
      file:write(table.concat(v, ";") .. "\n")
    else
      file:write(v, "\n")
    end
  end
  file:close()
end

function save_tlines(lines, path)
  if #lines == 0 and io.exists(path) then
    eprint(f"Versuch die Datei {path} leer zu ueberschreiben verhindert!")
    return 
  end
  local file = io.open(path, "w+")
  for _, v in ipairs(lines) do
    file:write(v, "\n")
  end
  file:close()
end


function save_json(tab, path)
  if type(tab) == "table" and len(tab) == 0 and io.exists(path) then
    printError(f"Versuch die Datei {path} leer zu ueberschreiben verhindert!")
    return
  end
  local file = io.open(path, "w")
  file:write(json.encode(tab))
  file:close()
end

function save_jsonl(tab, path, modifier)
  if len(tab) == 0 and io.exists(path) then
    eprint(f"Versuch die Datei {path} leer zu ueberschreiben verhindert!")
    return
  end
  modifier = modifier or "w"
  local file = io.open(path, modifier)
  for _, line in spairs(tab) do
    file:write(json.encode_oneline(line), "\n")
  end
  file:close()
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>io_profile_load_save</name>
				<packageName></packageName>
				<script>-------------------------------------------------
-- profile load/save functions
-------------------------------------------------

function pload_csv(filename)
  -- this function loads a csv file from the profiles folder
  return load_csv(getProfileDataPath(f"{filename}.csv"))
end

function pload_tlines(filename)
  -- this function loads a text file from the profiles folder
  return load_tlines(getProfileDataPath(f"{filename}.txt"))
end

function pload_json(filename, default)
  return load_json(getProfileDataPath(f"{filename}.json"), default)
end

function pload_jsonl(filename)
  return load_jsonl(getProfileDataPath(f"{filename}.jsonl"))
end

function psave_csv(lines, filename, setting)
  -- this function saves a text file from the profiles folder
  --
  return save_csv(lines, getProfileDataPath(f"{filename}.csv"), setting)
end

function psave_tlines(lines, filename)
  -- this function saves a csv file from the profiles folder
  --
  return save_tlines(lines, getProfileDataPath(f"{filename}.txt"))
end

function psave_json(tab, filename)
  return save_json(tab, getProfileDataPath(f"{filename}.json"))
end

function psave_jsonl(tab, filename, modifier)
  return save_jsonl(tab, getProfileDataPath(f"{filename}.jsonl"), modifier)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>io_module_load_save</name>
				<packageName></packageName>
				<script>-------------------------------------------------
-- module load/save functions
-------------------------------------------------

function mload_csv(filename)
  -- this function loads a csv file from the modules folder
  return load_csv(getRepoDataPath(f"{filename}.csv"))
end

function mload_tlines(filename)
  -- this function loads a text file from the modules folder
  return load_tlines(getRepoDataPath(f"{filename}.txt"))
end

function mload_json(filename, default)
  return load_json(getRepoDataPath(f"{filename}.json"), default)
end

function mload_jsonl(filename)
  return load_jsonl(getRepoDataPath(f"{filename}.jsonl"))
end

function msave_csv(lines, filename)
  return save_csv(lines, getRepoDataPath(f"{filename}.csv"))
end

function msave_tlines(lines, filename)
  return save_tlines(lines, getRepoDataPath(f"{filename}.txt"))
end

function msave_json(tab, filename)
  return save_json(tab, getRepoDataPath(f"{filename}.json"))
end

function msave_jsonl(tab, filename)
  return save_jsonl(tab, getRepoDataPath(f"{filename}.jsonl"))
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>io_remove</name>
				<packageName></packageName>
				<script>-------------------------------------------------
-- remove file functions
-------------------------------------------------

local function remove(path)
  if io.exists(path) then
    os.remove(path)
    FirstCall:remove_first_call(path)
  end
end

function mremove_csv(filename)
  remove(getRepoDataPath(f"{filename}.csv"))
end

function mremove_tlines(filename)
  remove(getRepoDataPath(f"{filename}.txt"))
end

function mremove_json(filename)
  remove(getRepoDataPath(f"{filename}.json"))
end

function mremove_jsonl(filename)
  remove(getRepoDataPath(f"{filename}.jsonl"))
end

function premove_csv(filename)
  remove(getProfileDataPath(f"{filename}.csv"))
end

function premove_tlines(filename)
  remove(getProfileDataPath(f"{filename}.txt"))
end

function premove_json(filename)
  remove(getProfileDataPath(f"{filename}.json"))
end

function premove_jsonl(filename)
  remove(getProfileDataPath(f"{filename}.jsonl"))
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>io_move</name>
				<packageName></packageName>
				<script>-------------------------------------------------
-- move file functions
-------------------------------------------------

local function move(old_file, new_file)
  if io.exists(new_file) then
    return
  end
  if not io.exists(old_file) then
    printError(f"Missing file to move {old_file}", true, true)
  end
  os.rename(old_file, new_file)
  FirstCall:remove_first_call(old_file)
end

function mmove_csv(old_filename, new_filename)
  move(getRepoDataPath(f"{old_filename}.csv"), getRepoDataPath(f"{new_filename}.csv"))
end

function mmove_tlines(old_filename, new_filename)
  move(getRepoDataPath(f"{old_filename}.txt"), getRepoDataPath(f"{new_filename}.txt"))
end

function mmove_json(old_filename, new_filename)
  move(getRepoDataPath(f"{old_filename}.json"), getRepoDataPath(f"{new_filename}.json"))
end

function mmove_jsonl(old_filename, new_filename)
  move(getRepoDataPath(f"{old_filename}.jsonl"), getRepoDataPath(f"{new_filename}.jsonl"))
end

function pmove_csv(old_filename, new_filename)
  move(getProfileDataPath(f"{old_filename}.csv"), getProfileDataPath(f"{new_filename}.csv"))
end

function pmove_tlines(old_filename, new_filename)
  move(getProfileDataPath(f"{old_filename}.txt"), getProfileDataPath(f"{new_filename}.txt"))
end

function pmove_json(old_filename, new_filename)
  move(getProfileDataPath(f"{old_filename}.json"), getProfileDataPath(f"{new_filename}.json"))
end

function pmove_jsonl(old_filename, new_filename)
  move(getProfileDataPath(f"{old_filename}.jsonl"), getProfileDataPath(f"{new_filename}.jsonl"))
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>parse_xml</name>
				<packageName></packageName>
				<script>--[[ Very small XML-to-tree parser (simple well-formed XML).
  Ignores attributes/metadata, keeps text content, supports self-closing tags.
  Returns: { tag=..., text=..., children={...} } (root node)
  Example: "&lt;html&gt;&lt;name&gt;XXX&lt;/name&gt;&lt;/html&gt;" 
    returns { tag="html", text="", children={{tag="name", text="XXX", children={}}}}
]]-- 
function load_and_parse_xml(path)
  -- read file
  local chunks = {}
  for line in io.lines(path) do chunks[#chunks+1] = line end
  local xml = table.concat(chunks, "\n")

  -- remove comments and processing instructions (basic)
  xml = xml:gsub("&lt;!%-%-.-%-%-&gt;", "")
  xml = xml:gsub("&lt;%?.-%?&gt;", "")

  local doc = { tag = "_doc", text = "", children = {} }
  local stack = { doc }

  local function addText(s)
    -- keep only meaningful text (ignore pure whitespace between tags)
    if s:match("%S") then
      local cur = stack[#stack]
      cur.text = (cur.text or "") .. s
    end
  end

  local i = 1
  while true do
    local lt = xml:find("&lt;", i, true)
    if not lt then
      addText(xml:sub(i))
      break
    end

    addText(xml:sub(i, lt - 1))

    local gt = xml:find("&gt;", lt, true)
    if not gt then break end -- malformed

    local raw = xml:sub(lt, gt)
    i = gt + 1

    -- skip &lt;!DOCTYPE ...&gt; and other &lt;! ... &gt;
    if raw:match("^&lt;!") then
      -- ignore
    else
      local closeTag = raw:match("^&lt;/%s*([%w_:%-%.]+)")
      if closeTag then
        local top = stack[#stack]
        if top and top.tag == closeTag then
          table.remove(stack)
        else
          error(("XML mismatch: closing &lt;/%s&gt; but top is &lt;%s&gt;"):format(closeTag, top and top.tag or "nil"))
        end
      else
        local openTag = raw:match("^&lt;%s*([%w_:%-%.]+)")
        if openTag then
          local selfClosing = raw:match("/%s*&gt;%s*$") ~= nil
          local node = { tag = openTag, text = "", children = {} }
          local parent = stack[#stack]
          parent.children[#parent.children + 1] = node
          if not selfClosing then
            stack[#stack + 1] = node
          end
        end
      end
    end
  end

  return doc.children[1]
end

-- Example:
-- local tree = parseXmlFileToTree(getMudletHomeDir() .. "/myfile.xml")
-- echo(tree.tag .. "\n")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>list_files</name>
				<packageName></packageName>
				<script>function list_files(source_path, pattern)
  local result = {}
  local ok, iter, state, var = pcall(lfs.dir, source_path)
  if not ok then
    printError(f"lfs.dir failed: {tostring(iter)}", true, true)
  end
  
  for entry in iter, state, var do
    if entry ~= "." and entry ~= ".." and entry:find(pattern) then
      local full = f"{dir}/{entry}"
      local info = lfs.attributes(full) -- includes mode = "file" / "directory"
      if info and info.mode == "file" then
        result[full] = entry
      end
    end
  end
  return result
end
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>string_extensions</name>
			<packageName></packageName>
			<script>function break_lines(text, length)
  length = length or 59
  local result = {""}
  local index = 1
  for s in text:gmatch("[^%s]+") do
    if len(result[index] .. s) &lt; length then
      if len(result[index]) &gt; 0 then
        result[index] = result[index] .. " " .. s
      else
        result[index] = s
      end
    else
      index = index + 1
      table.insert(result, s)
    end
  end
  return result
end

function substring(text, subtext)
  return string.match(text, subtext)
end

function string.startswith(text, subtext)
  return text:sub(1, #subtext) == subtext
end

function string.endswith(text, subtext)
  return text:sub(-#subtext) == subtext
end

function string.strip(text)
  local start_index = 1
  local end_index = text:len()
  for i=1,text:len(),1 do
    local c=text:sub(i,i)
    if c == " " then
      start_index = i+1
    else
      break
    end
  end
  for i=text:len(),1,-1 do
    local c=text:sub(i,i)
    if c == " " then
      end_index = i-1
    else
      break
    end
  end
  if end_index &lt;= start_index then
    return ""
  else
    return text:sub(start_index, end_index)
  end
end

function string.indent_lines(text, indent)
  local result = {}
  for word in text:gmatch("[^%s]+") do
    local prev = result[len(result)]
    if prev and len(prev) + 1 + len(word) &lt; 78 then
      result[len(result)] = f("{prev} {word}")
    else
      table.insert(result, f("{indent}{word}"))
    end
  end
  return table.concat(result, "\n")
end

function string.rep(txt, size)
  local result = ""
  size = size or 0
  for _=1,size do result = f"{result}{txt}" end
  return result
end

function string.fill(text, filler)
  filler = filler or " "
  local left = 76 - len(text)
  local rem = left % 2
  local fill_text = string.rep(filler, ((left-rem) / 2) -1)
  local result = f"{fill_text} {text} {fill_text}"
  if rem &gt; 0 then
    result = f"{result}{filler}"
  end
  return result
end</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>table_extensions</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>table_get_set</name>
				<packageName></packageName>
				<script>local function deep_set(target, keys, value, idx)
  idx = idx or 1
  local pivot = keys[idx]
  if idx == #keys then
    target[pivot] = value
  else
    if not target[pivot] then
      target[pivot] = {}
    end
    deep_set(target[pivot], keys, value, idx + 1) 
  end
end

function table.set(tab, key, value)
  if type(key) == "string" then
    deep_set(tab, key:split("%."), value)
  elseif type(key) == "table" then
    deep_set(tab, key, value)
  else
    tab[key] = value
  end
end

local function deep_get(source, keys, idx)
  idx = idx or 1
  local pivot = keys[idx]
  if source == nil then
    return nil
  end
  if idx == #keys then
    return source[pivot]
  else
    return deep_get(source[pivot], keys, idx + 1)
  end
end

function table.get(tab, key, default_value)
  local result = nil
  if type(key) == "string" then
    result = deep_get(tab, key:split("%."))
  elseif type(key) == "table" then
    result = deep_get(tab, key)
  else
    result = tab[key]
  end
  if result == nil and default_value ~= nil then
    table.set(tab, key, default_value)
    result = default_value
  end
  return result
end
















</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>table_add_append_update</name>
				<packageName></packageName>
				<script>function table.add(tab, value)
  if not table.contains(tab, value) then
    table.insert(tab, value)
  end
end

function table.append_table(tab_a, tab_b)
  for _,item in ipairs(tab_b) do
    table.insert(tab_a, item)
  end
end

function table.update(base_table, updates, keep)
  for key, value in pairs(updates) do
    if type(value) == "table" and type(base_table[key]) == "table" then
      table.update(base_table[key], value, keep)
    elseif (base_table[key] == nil) or not keep then
      base_table[key] = value
    end
  end
  return base_table
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>table_remove_pop</name>
				<packageName></packageName>
				<script>function table.remove_at(tab, index)
  local table_size = len(tab)
  if index &lt; 0 then
    index = table_size + index
    if index &lt; 1 then
      eprint(f("The table has just {table_size} elements, can't remove at position {index}."))
      return false
    end
  end
  if index == 0 or index &gt; len(tab) then
    eprint(f("The table has just {table_size} elements, can't remove at position {index}."))
    return false
  end
  -- shift values
  for i=index+1,len(tab),1 do
    tab[i-1] = tab[i]
  end
  -- remove last element
  table.remove(tab)
  return true
end

function table.remove_value(tab, value)
  local index = table.index_of(tab, value)
  if not index then
    eprint(f("The table has no value '{value}' to remove."))
    return false
  else
    table.remove_at(tab, index)
    return true
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>table_misc</name>
				<packageName></packageName>
				<script>function table.values(tab)
  local result = {}
  for _, value in pairs(tab) do
    table.insert(result, value)
  end
  return result
end

function table.fold(tab, field_name)
  -- transform a table such that the keys 
  -- part of the values.
  -- {st={title="Sandtiger"}} with 
  -- field_name == "name" will return
  -- { {name="st", title="Sandtiger"} }

  local result = {}
  for id, props in pairs(tab) do
    local data = {}
    data[field_name] = id
    for pkey, pvalue in pairs(props) do
      data[pkey] = pvalue
    end
    table.insert(result, data)
  end
  return result
end

function table.unfold(tab, field_name)
  -- inverse to table.fold we move a value
  -- out of the data as a key of the result
  
  local result = {}
  for _, data in spairs(tab) do
    local id = nil
    local props = {}
    for pkey, pvalue in pairs(data) do
      if pkey == field_name then
        id=pvalue
      else
        props[pkey] = pvalue
      end
    end
    result[id] = props
  end
  return result
end

function table.apply(tab, func)
  local result = {}
  for _, v in pairs(tab) do
    table.insert(result, func(v))
  end
  return result
end

function table.subtable(tab, start_index, end_index)
  local result = {}
  for i=start_index,end_index,1 do
    table.insert(result, tab[i])
  end 
  return result
end

function table.indent_lines(tab, indent)
  local new_line = f("\n{indent}")
  local result = f("{indent}{table.concat(tab, new_line)}") 
  return result
end

function table.indent_lines_with_breaks(tab, indent)
  local result = {}
  for _,line in ipairs(tab) do
    table.insert(result, string.indent_lines(line, indent))
  end
  return table.concat(result, "\n")
end

function table.rep(value, size)
  local result = {}
  size = size or 0
  for _=1,size do table.insert(result, value) end
  return result
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>MundronClassMethods</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>MCM_init</name>
				<packageName></packageName>
				<script>------------------------------------
---  Meta-table for class objects.
------------------------------------

MundronClassMethods = MundronClassMethods or {
  _name = "MundronClassMethods",
  _module = "Mundron_Core",
  _version = "1.1.0",
  pload = pload_json,
  mload = mload_json,
  psave = psave_json, 
  msave = msave_json,
  premove = premove_json,
  mremove = mremove_json,
  pmove = pmove_json,
  mmove = mmove_json,
  files = {profile={}, game={}}
}

function MundronClassMethods:new(t)
  assert(type(t) == "table", "MundronClassMethods: Incoming object is no table")
  
  -- create object and add inferrences
  local object = setmetatable(t, self)
  self.__index = self
  GOR:add_object(object)
  
  for _, field in pairs({"log_buffer", "_versions"}) do
    object[field] = table.get(object, field, {})
  end
  -- assert fields
  for _, field in ipairs({"_name", "_version", "_module"}) do
    object:assert(t[field], f"Missing required field: '{field}'")
  end
  
  if not object._fixed_version then
    object:warn("Missing _fixed_version for version control")
  else
    object:verify_fixed_versions()
  end
  
  object:register_event_functions()
  object.__call = self.__call
  
  return object
end

function MundronClassMethods:extend(child)
  child = child or {}
  child.__index = child
  child.__call = self.__call
  return setmetatable(child, self)   -- inherits methods + metamethods (e.g., __call) from base
end

function MundronClassMethods:verify_fixed_versions()
  for _, mtab in pairs(self:inheritance()) do
    local fixed_version = self._fixed_version[mtab._name]
    if mtab._name ~= self._name then
      self:assert(fixed_version, f"Missing fixed version for {mtab._name}", false)
      if fixed_version ~= mtab._version then
        self:warn(f"Fixed version '{fixed_version}' for {mtab._name} doesn't match '{mtab._version}'")      
      end
    end
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>MCM_event_handling</name>
				<packageName></packageName>
				<script>local function init_data(object)
  return function(event_name, module_name)
    if module_name ~= object._module then
      return
    end
    object:log(f"Triggered init_data function by event {event_name} from module {module_name}")
    object:reset()
  end
end

local function reload_game_data(object)
  return function(event_name, field, profile)
    object:log(f[[Triggered reload_game_data: 
event='{event_name}', sender_profile='{profile}', field='{field}']])
    object:generic_load_data("game", field)
    if object.post_load_data then
      object:post_load_data()
    end
  end
end


function MundronClassMethods:register_event_functions() 
  -- once the module is loaded, check for migration and if
  -- there is any data to load, load it initially
  registerAnonymousEventHandler("sysInstall", init_data(self))
  
  if len(table.get(self, "files.game")) &gt; 0 then
    -- if there are game files, registers function to reload game data
    -- whenever any profile saves game data of the same object
    registerAnonymousEventHandler(self:load_event_name(), reload_game_data(self))
  end
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>MCM_names</name>
				<packageName></packageName>
				<script>function MundronClassMethods:name(extra)
  local result = self._name
  if extra then
    extra = extra:gsub("%.", "_")
    result = f"{result}_{extra}" 
  end
  return result
end

function MundronClassMethods:shortname(extra)
  local result = self._shortname or self._name
  if extra then
    extra = extra:gsub("%.", "_")
    result = f"{result}_{extra}"
  end
  return result
end

function MundronClassMethods:filename(extra)
  extra = extra:gsub("%.", "_")
  local result = f"{self:shortname()}/{extra}"
  return result
end

function MundronClassMethods:load_event_name()
  local event_name = f"load_game_data_for_{self:name()}_from_{self:name('module')}"
  return event_name
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>MCM_check_for_migrations</name>
				<packageName></packageName>
				<script>local function call_migration_on_object(self, mtab, key)
  local saved_version = table.get(self, {"_versions", key, mtab._name})
  local msg, err
  
  if mtab._version == saved_version then
    msg = f"{mtab._name} has already version {saved_version}"
    self:log(msg)
    return false, nil
  end
  
  if not (rawget(mtab, "files") and rawget(mtab.files, key)) then
    msg = f"No migration needed for {mtab._name} because no files needed. Update to version '{mtab._version}'"
    self:log(msg)
    table.set(self, {"_versions", key, mtab._name}, mtab._version)
    return true, nil
  end
    
  if self.version_lt(mtab._version, saved_version) then
    err = f"Saved version '{saved_version}' is greater than possible version '{mtab._version}'"
    return false, err
  end
  
  msg = f"Call migration of {mtab._name} from version '{saved_version}' to '{mtab._version}'"
  self:log(msg)
  local fun_name = f"migrate_{key}"
  local migrate_function = rawget(mtab, fun_name)
  msg = f"Migrate functions: {type(migrate_function)}"
  self:log(msg)
  if type(migrate_function) ~= "function" then
    err = f"Missing function {fun_name} for module {mtab._name}"
    return false, err
  end
  
  local result_version = migrate_function(self, saved_version)
  msg = f"Returned: {type(result_version)} - {result_version}"
  self:log(msg)
  table.set(self._versions, {key, mtab._name}, result_version)
  self:log("Stored new version")
  if self.version_lt(result_version, mtab._version) then
    err = f"Migration of {mtab._name} ended in version {result_version} instead of expected {mtab._version}"
  end
  return self.version_lt(saved_version, result_version), err
end

function MundronClassMethods:check_for_migrations(key)
  self._versions[key] = self:fetch_from_(key, self:filename("versions"), {})
  local msg = f"Got saved versions '{json.encode_oneline(self._versions[key])}' for {key}"
  self:log(msg)
  local err, total_change
  for _, mtab in ipairs(self:inheritance()) do 
    change, err = call_migration_on_object(self, mtab, key)
    total_change = total_change or change
    if err then
      break
    end
  end
  msg = f"{key} migration versions: {json.encode_oneline(self._versions[key])} to {self:filename('versions')}"
  self:log(msg)
  if total_change then
    self:store_into_(key, self._versions[key], self:filename("versions"))
  end
  if err then
    self:error(err)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>MCM_own_migration</name>
				<packageName></packageName>
				<script>function MundronClassMethods:migrate_profile(saved_version)
  local meta_fn = f"{self:shortname()}_meta"
  if self.version_lt(saved_version, "1.0.0") then
    local meta_data = self.pload(meta_fn)
    if len(meta_data) &gt; 0 then
      for _, mtab in ipairs(self:inheritance()) do 
        self._versions["profile"][mtab._name] = mtab._version
      end
    end
    saved_version = "1.0.0"
  end
  if self.version_lt(saved_version, "1.1.0") then
    local meta_data = self.pload(meta_fn)
    if meta_data then
      self.premove(meta_fn)
    end
    if self.pload(self:name()) then
      self.premove(self:name())
    end
    local prefix = f"{self._name}_"
    getProfileDataPath(self:shortname()) -- creates path if it doesn't exist
    for path, fn in pairs(list_files(getProfileDataPath(), prefix)) do
      fn = fn:gsub(".json", "")
      local sname = fn:gsub(prefix, "")
      self.pmove(fn, self:filename(sname))
    end
    saved_version = "1.1.0"
  end
  return saved_version
end

function MundronClassMethods:migrate_game(saved_version)
  local meta_fn = f"{self._name}_meta"
  if self.version_lt(saved_version, "1.0.0") then
    local meta_data = self.mload(meta_fn)
    if meta_data then
      for _, mtab in ipairs(self:inheritance()) do 
        self._versions["game"][mtab._name] = mtab._version
      end
    end
    saved_version = "1.0.0"
  end
  if self.version_lt(saved_version, "1.1.0") then
    local meta_data = self.mload(meta_fn)
    if meta_data then
      self.mremove(meta_fn)
    end
    if self.mload(self:name()) then
      self.mremove(self:name())
    end
    local prefix = f"{self._name}_"
    for path, fn in pairs(list_files(getRepoDataPath(), prefix)) do
      fn = fn:gsub(".json", "")
      local sname = fn:gsub(prefix, "")
      self.mmove(fn, self:filename(sname))
    end
    saved_version = "1.1.0"
  end
  return saved_version
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>MCM_reset</name>
				<packageName></packageName>
				<script>function MundronClassMethods:reset()
  for _, key in pairs({"profile", "game"}) do
    self:check_for_migrations(key)
    if table.get(self, {"files", key}) then
      self:generic_load_data(key)
    end
  end
  if self.post_load_data then
    self:post_load_data()
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>MCM_generic_load_data</name>
				<packageName></packageName>
				<script>function MundronClassMethods:fetch_from_(key, filename, default)
  self:log(f"Fetch {key} data from {filename}")
  local result
  if key == "profile" then
    result = self.pload(filename, default)
  else
    result = self.mload(filename, default)
  end
  local msg = f"Got result {type(result)} - {len(result)}"
  self:log(msg)
  return result
end

local function load_field(self, key, field, default)
  local saved_data = self:fetch_from_(key, self:filename(field), default)
  if field == "COMPACT" then
    table.update(table.get(self, "data", {}), saved_data)
  else
    table.set(self, {"data", field}, saved_data)    
  end
end

function MundronClassMethods:generic_load_data(key, this_field)
  if not self.files[key] then
    self:error(f"Tried to load {key} files which doesn't exist")
    return
  end
  
  if this_field and not self.files[key][this_field] then
    self:error(f"Tried to load {key} file with name {this_field} which isn't defined")
    return
  end
  local fields = this_field and {[this_field]=self.files[key][this_field]} or self.files[key] or {}
  
  for field, default in pairs(fields) do
    load_field(self, key, field, default) 
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>MCM_generic_save_data</name>
				<packageName></packageName>
				<script>function MundronClassMethods:store_into_(key, data, filename)
  if type(data) == "table" and len(data) == 0 then
    return
  end
  local save = key == "profile" and self.psave or self.msave
  save(data, filename)
end

local function save_field(self, key, field, default)
  if field == "COMPACT" then
    local data_to_save = {}
    for subfield,subdefault in pairs(default) do
      data_to_save[subfield] = table.get(self, {"data", subfield}, subdefault)
    end
    self:store_into_(key, data_to_save, self:filename(field))
  else
    self:store_into_(key, table.get(self, {"data", field}, default), self:filename(field))
  end
end

function MundronClassMethods:generic_save_data(key, this_field)
  if not self.files[key] then
    self:error(f"Tried to save {key} files which doesn't exist")
    return
  end
  
  if this_field and not self.files[key][this_field] then
      self:error(f"Tried to save {key} file with name {this_field} which isn't defined")
      return
  end
  local fields = this_field and {[this_field]=self.files[key][this_field]} or self.files[key] or {}

  for field, default in pairs(fields) do
    save_field(self, key, field, default)
  end
  
  if key == "game" then
    raiseGlobalEvent(self:load_event_name(), this_field)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>MCM_specific_load_save_data</name>
				<packageName></packageName>
				<script>function MundronClassMethods:load_data()
  if not self.files then
    self:error("No files to load at all")
    return
  end
  self:info("Called load_data")
  for _, target in pairs({"game", "profile"}) do
    if table.get(self, {"files", target}) then
      self:generic_load_data(target)
    end  
  end
end

function MundronClassMethods:load_profile(this_field)
  self:info("Called load_profile")
  self:generic_load_data("profile", this_field)
end

function MundronClassMethods:load_game(this_field)
  self:info("Called load_game")
  self:generic_load_data("game", this_field)
end

function MundronClassMethods:save_data()
  if not self.files then
    self:log("No files to save at all")
    return
  end
  for _, target in pairs({"game", "profile"}) do
    if self.files[target] then
      self:generic_save_data(target)
    end  
  end
end

function MundronClassMethods:save_profile(this_field)
  self:generic_save_data("profile", this_field)
end

function MundronClassMethods:save_game(this_field)
  self:generic_save_data("game", this_field)
end
  
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>MCM_log_and_info</name>
				<packageName></packageName>
				<script>function MundronClassMethods:log(text, level)
  level = level or "info"
  table.insert(self.log_buffer, {os.date("%Y-%m-%dT%H:%M:%S"), level, text})
end

function MundronClassMethods:show_log()
  if len(self.log_buffer) == 0 then
    self:info({"~ Nothing logged yet! ~", "y"})
  end
  local log = {}
  for _, line in pairs(self.log_buffer) do
    local level = string.upper(line[2])
    if level == "INFO" then
      level = {"INFO", "lb"}
    elseif level == "ERROR" then
      level = {"ERROR", "lr"}    
    else
      level = {level, "y"}    
    end
    table.insert(log, {line[1], level, line[3]})
  end
  print_table(log)
end

function MundronClassMethods:info(text)
  iprint(text, self._shortname or self._name)
  self:log(text, "info")
end

function MundronClassMethods:warn(text)
  wprint(text, self._shortname or self._name)
  self:log(text, "warn")
end

function MundronClassMethods:error(text, haltExecution)
  eprint(text, self._shortname or self._name)
  self:log(text, "error")
  -- halt if haltExecution is nil otherwise use haltExecution
  printError(text, true, haltExecution == nil or haltExecution)
end

function MundronClassMethods:assert(condition, text, haltExecution)
  if condition then
    return
  end
  self:error(text, haltExecution)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>MCM_misc</name>
				<packageName></packageName>
				<script>function MundronClassMethods:rabbit()
  self:info("Because my girlfriend likes rabbits as in RabbitMQ or in redwine juice.")
end
------------------------------------------------------
local function is_meta(key)
  return key:sub(1,1) == "_" and key:sub(1,2) ~= "__"
end

local function is_simple_value(value)
  local t = type(value)
  return t == "string" or t == "number" or t == "boolean"
end

local function parseSemver(v)
  if not v or v == "" then return 0, 0, 0 end
  if not v:find("^(%d+)%.(%d+)%.(%d+)$") then
    printError(f"Can't parse version {v}", true, true)
  end
  local a, b, c = v:match("^(%d+)%.(%d+)%.(%d+)$")
  return tonumber(a) or 0, tonumber(b) or 0, tonumber(c) or 0
end

function MundronClassMethods.version_lt(a, b)
  local a1,a2,a3 = parseSemver(a)
  local b1,b2,b3 = parseSemver(b)
  if a1 ~= b1 then return a1 &lt; b1 end
  if a2 ~= b2 then return a2 &lt; b2 end
  return a3 &lt; b3
end
------------------------------------------------------
function MundronClassMethods:__call(parent)
  if not parent then
    mtable = self
  else
    print(string.rep("=", 50))
    print("Metatable hierachy:")
    print(f"{parent}) {self._name}")
    mtable = getmetatable(self)
    if not mtable then
      self:error("No metatable found")
    end
    parent = parent - 1
    while parent &gt; 0 do
      print(f"{parent}) {mtable._name}")
      mtable = getmetatable(mtable)
      if not mtable then
        self:error("Overstepped metatable depth")
      end
      parent = parent - 1
    end
  end
  
  print(string.rep("=", 50))
  print(f"Consider functions of table/metatable {mtable._name}")
  local functions = mtable:functions()
  for _, fn in pairs(functions) do
    print({{fn, "y"}})
  end
    
  print(string.rep("=", 50))
  local meta, level = getmetatable(mtable), 1
  if not meta then
    print("No higher metatables")
  else
    print("Higher metatables:")
    while meta do
      print(f"{level}) {meta._name}")
      meta, level = getmetatable(meta), level + 1
    end
  end
end

function MundronClassMethods:meta()
  local result = {}
  for k,v in pairs(self) do
    if is_meta(k) and type(v) ~= "function" then
      result[k] = v
    end
  end
  return result
end

function MundronClassMethods:inheritance()
  local result, mtable = {}, self
  while mtable do
    table.insert(result, 1, mtable)
    mtable = getmetatable(mtable)
  end
  return result
end

function MundronClassMethods:keys(parent)
  local base = self
  if parent ~= nil then
    base = table.get(self, parent)
  end
  if len(base) == 0 then
    self:info(f"Got empty list for key {parent}")
  end
  for key, value in pairs(base) do
    local var_type = type(value)
    if not (is_meta(key) or var_type == "function") then
      if var_type == "table" then
        print(f"{key}: table -&gt; length {len(value)}")
      elseif is_simple_value(value) then
        print(f"{key}: type {var_type} -&gt; {value}")
      end  
    end
  end
end

function MundronClassMethods:functions()
  local result = {}
  for key, value in pairs(self) do
    if key:sub(1,2) ~= "__" and type(value) == "function" then
      table.insert(result, key)
    end
  end
  table.sort(result)
  return result
end

</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>FirstCall</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>FirstCall_init</name>
				<packageName></packageName>
				<script>
FirstCall = FirstCall or MundronClassMethods:new{
  _name = "FirstCall",
  _module = "Mundron_Core",
  _version = "1.0.0",
  data = {},
  files = {game={created={}}},
  _fixed_version={MundronClassMethods="1.1.0"}
}

function FirstCall:check_for_migrations(key)
  if key == "profile" then
    -- print("Ignore migration check for profile")
  else
    MundronClassMethods.check_for_migrations(self, "game")
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>FirstCall_io_replacement</name>
				<packageName></packageName>
				<script>function FirstCall.mload(filename, default)
  local file = io.open(getRepoDataPath(f"{filename}.json"), "r")
  if file == nil then
    FirstCall.msave(default, filename)
    return default
  end
  local content = file:read("*all")
  file:close()
  return json.decode(content)
end

function FirstCall.msave(tab, filename)
  local file = io.open(getRepoDataPath(f"{filename}.json"), "w")
  file:write(json.encode(tab))
  file:close()
end

function FirstCall.mmove(old_file, new_file)
  if io.exists(new_file) then
    return
  end
  if not io.exists(old_file) then
    printError(f"Missing file to move {old_file}", true, true)
  end
  os.rename(old_file, new_file)
end

function FirstCall.pload(filename, default)
  -- "Ignore load from profile file {filename}"
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>FirstCall_functions</name>
				<packageName></packageName>
				<script>function FirstCall:is_first_call(name)
  return not self.data.created[name]
end

function FirstCall:complete_first_call(name)
  self.data.created[name] = true
  self:save_data()
end

function FirstCall:remove_first_call(name)
  if not self.data.created then
    self:error("FirstCall calles to seen")
  end
  self.data.created[name] = nil
  self:save_data()
end

local function test_file(folder, pattern)
  FirstCall:info(f"Check files in {folder} with {pattern}")
  for path, _ in pairs(FirstCall.data.created) do
    if string.startswith(path, folder) and path:find(pattern) then
      local filename = path:gsub(folder, "")
      print(filename) 
    end
  end
end

function FirstCall:test_pfile(pattern)
  test_file(getProfileDataPath(), pattern)
end

function FirstCall:test_mfile(pattern)
  test_file(getRepoDataPath(), pattern)
end

local function remove_file(folder, pattern)
  FirstCall:info(f"Delete files in {folder} with {pattern}")
  for path, _ in pairs(FirstCall.data.created) do
    if string.startswith(path, folder) and path:find(pattern) then
      print(f"Remove {path}")
      FirstCall:remove_first_call(path)
      print(" -&gt; done") 
    end
  end
end

function FirstCall:remove_pfile(pattern)
  remove_file(getProfileDataPath(), pattern)
end

function FirstCall:remove_mfile(pattern)
  remove_file(getRepoDataPath(), pattern)
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>FirstCall_migrations</name>
				<packageName></packageName>
				<script>function FirstCall:migrate_game(saved_version)
  if self.version_lt(saved_version, "1.0.0") then
    mmove_json("first_call_map", self:name("created"))
    MundronClassMethods.migrate_game(FirstCall)
    saved_version = "1.0.0"
  end
  return saved_version
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>initGMCP</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--   Sagt gmcp, dass er alle Daten senden soll --
-------------------------------------------------

function initGMCP()
  if not gmpc_is_initialized then
    sendGMCP([[Core.Supports.Set [ "MG.char 1", "MG.room 1", "comm.channel 1" ] ]])
    if deleteOldProfiles then
      deleteOldProfiles(7)
    end
    gmcp_is_initialized = true
  end
end

function gmcp_available(path)
  return table.get(gcmp or {}, path) ~= nil
end</script>
			<eventHandlerList>
				<string>gmcp.Char</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>color_communication</name>
			<packageName></packageName>
			<script>farben = {
  vg = {
    komm = "cyan", 
    ebenen = "red", 
    info = "green", 
    alarm = "white", 
    script = "dark_green"
  },
  bg = {
    komm = "black", 
    ebenen = "black", 
    info = "black", 
    alarm = "red", 
    script = "black"
  },
}
function set_text_color(fg_type, bg_type)
  local fg_color = farben.vg[fg_type] or fg_type
  local bg_color = farben.bg[bg_type] or bg_type or farben.bg[fg_type] or fg_color
  fg(fg_color)
  bg(bg_color)
end

function color_communication()
  set_text_color("ebenen")
  echo(gmcp.comm.channel.msg)
  resetFormat()
end

function set_line_color(fg_type, bg_type)
  select_line_color(fg_type, bg_type)
  resetFormat()
end

function select_line_color(fg_type, bg_type)
  selectCurrentLine()
  set_text_color(fg_type, bg_type)
end</script>
			<eventHandlerList>
				<string>gmcp.comm.channel</string>
			</eventHandlerList>
		</Script>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
