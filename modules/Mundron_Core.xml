<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage />
	<TimerPackage />
	<AliasPackage />
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>MC_init_colors</name>
			<packageName></packageName>
			<script>function MC_init_colors()
  return farben or  {
    vg = {
      komm = "cyan", 
      ebenen = "red", 
      info = "green", 
      alarm = "white", 
      script = "dark_green"
    },
    bg = {
      komm = "black", 
      ebenen = "black", 
      info = "black", 
      alarm = "red", 
      script = "black"
    },
  }
end

farben = MC_init_colors()</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>FirstCall</name>
			<packageName></packageName>
			<script>--[[ 
 !!!!!!!!!
  Do NOT use MundronClassMethods! That used mload_json which calls getRepoDataPath with argument!
  Since load_json uses FirstCall, it will loop into itself
 !!!!!!!!!
]]--

FirstCall = FirstCall or {
  _name = "FirstCall",
  _module = "Mundron_Core",
  _version = "1.0.0",
  data = {
    created = {}
  },
  state = {
    loaded = false
  }
}

local function get_path()
  -- IMPORTANT: Don't use getRepoDataPath with argument to avoid infinite stack!
  -- with an argument, it falls is_first_call where this function is called
  -- from.
  local result = f"{getRepoDataPath()}/first_call_map.json"
  return result
end

function FirstCall:is_first_call(name)
  if not self.state.loaded then
    self:load_data()  
    self.state.loaded = true
  end
  return not self.data.created[name]
end

function FirstCall:load_data()
  if io.exists(get_path()) then
    local file = io.open(get_path(), "r")
    local content = file:read("*all")
    file:close()
    self.data.created = json.decode(content)
  else
    local file = io.open(get_path(), "w+")
    file:write(json.encode({}))
    file:close()
  end
end

function FirstCall:save_data()
  local file = io.open(get_path(), "w+")
  file:write(json.encode(self.data.created))
  file:close()
end

function FirstCall:complete_first_call(name)
  FirstCall.data.created[name] = true
  FirstCall:save_data()
end

function FirstCall:remove_first_call(name)
  FirstCall.data.created[name] = nil
  FirstCall:save_data()
end</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>helper_functions</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>json_helper</name>
				<packageName></packageName>
				<script>--[[
  Converter of serializable Lua objects to JSON strings and backwards
  Usage:
  json.encode({42, 23, 12}) --&gt; "[42, 23, 12]"
  json.decode('{"apple": 13, "tree": true}') --&gt; {["apple"] = 13, ["tree"] = true}
]]--

json = {
  _version = "1.0.0",
  _author = "Mundron",
  _contact = "https://github.com/Mundron",
  _repository = "https://github.com/Mundron/Morgengrauen_tools"
}

local escape_char_map = {
  ["/"] = "\\/",
  ['"'] = '\\"',
  ["\b"] = "\\b",
  ["\f"] = "\\f",
  ["\n"] = "\\n",
  ["\r"] = "\\r",
  ["\t"] = "\\t",
}

local escape_char_map_inv = {["\\\\"]="\\"}
for k, v in pairs(escape_char_map) do
  escape_char_map_inv[v] = k
end

local function escaped_string(value)
  -- Escape backslash first to avoid double-escaping
  value = value:gsub("\\", "\\\\")
  for k, v in pairs(escape_char_map) do
    if k ~= "\\" then  -- Already handled
      value = value:gsub(k, v)
    end
  end
  return '"' .. value .. '"'
end

local function isArray(value)
  local count = 0
  for k, v in pairs(value) do
    count = count + 1
    if type(k) ~= "number" or k ~= count then
      return false
    end
  end
  return true
end

function json.encode(value, indent)
  indent = indent or 0
  local indentStr = string.rep("  ", indent)
  local nextIndentStr = string.rep("  ", indent + 1)
    
  local valueType = type(value)
  if value == nil then
    return "null"
  elseif valueType == "boolean" then
    return tostring(value)
  elseif valueType == "number" then
    return tostring(value)
  elseif valueType == "string" then
    return escaped_string(value)        
  end
  
  if valueType == "table" then
    if isArray(value) then
      if #value == 0 then
        return "[]"
      else
        local parts = {}
        for i = 1, #value do  -- FIX: was using undefined 'count'
          table.insert(parts, nextIndentStr .. json.encode(value[i], indent + 1))
        end
        return "[\n" .. table.concat(parts, ",\n") .. "\n" .. indentStr .. "]"
      end
    else
      local parts = {}
      for k, v in pairs(value) do
        local key
        if type(k) == "string" then
          key = escaped_string(k)
        elseif type(k) == "number" then
          key = f'"{k}"'
        else
          error(f"Invalid key type: {type(k)}")
        end
        table.insert(parts, f"{nextIndentStr}{key}: {json.encode(v, indent + 1)}")
      end
      -- Sort for consistent output
      table.sort(parts)
      return "{\n" .. table.concat(parts, ",\n") .. "\n" .. indentStr .. "}"
    end
  end
  
  error("Unsupported type: " .. valueType)
end

-- JSON to Lua table parser
function json.decode(str)
  local pos, error_flag = 1, false
  
  local function decode_error(msg)
    error(f"JSON decode error at position {pos}: {msg} - {str:sub(pos-10,pos+10)}")
    error_flag = true
  end
  
  local whitespace = {" ", "\t", "\n", "\r"}
  
  local function skip_whitespace()
    while table.contains(whitespace, str:sub(pos, pos)) and pos &lt;= #str do
      pos = pos + 1
    end
  end
  
  local function parse_string()
    if str:sub(pos, pos) ~= '"' then
      decode_error("Expected string")
    end
    pos = pos + 1  -- Skip opening quote
    
    local result = {}
    while pos &lt;= #str do
      local c = str:sub(pos, pos)
      
      if c == '"' then
        pos = pos + 1  -- Skip closing quote
        return table.concat(result)
      elseif c == "\\" then
        -- Handle escape sequences
        local escape = str:sub(pos, pos + 1)
        if escape_char_map_inv[escape] then
          table.insert(result, escape_char_map_inv[escape])
          pos = pos + 2
        elseif str:sub(pos + 1, pos + 1) == "u" then
          -- Unicode escape \uXXXX - simplified handling
          local hex = str:sub(pos + 2, pos + 5)
          local codepoint = tonumber(hex, 16)
          if codepoint then
            table.insert(result, string.char(codepoint))
          end
          pos = pos + 6
        else
          decode_error("Invalid escape sequence")
        end
      else
        table.insert(result, c)
        pos = pos + 1
      end
    end
    
    decode_error("Unterminated string")
  end -- function parse_string
  
  local function parse_number()
    local start_pos = pos
    local has_decimal = false
    local has_exponent = false
    
    -- Optional minus sign
    if str:sub(pos, pos) == "-" then
      pos = pos + 1
    end
    
    -- Digits before decimal point
    if not str:sub(pos, pos):match("%d") then
      decode_error("Invalid number")
    end
    
    while pos &lt;= #str and str:sub(pos, pos):match("%d") do
      pos = pos + 1
    end
    
    -- Optional decimal part
    if pos &lt;= #str and str:sub(pos, pos) == "." then
      has_decimal = true
      pos = pos + 1
      if not str:sub(pos, pos):match("%d") then
        decode_error("Invalid number")
      end
      while pos &lt;= #str and str:sub(pos, pos):match("%d") do
        pos = pos + 1
      end
    end
    
    -- Optional exponent
    if pos &lt;= #str and (str:sub(pos, pos) == "e" or str:sub(pos, pos) == "E") then
      has_exponent = true
      pos = pos + 1
      if str:sub(pos, pos) == "+" or str:sub(pos, pos) == "-" then
        pos = pos + 1
      end
      if not str:sub(pos, pos):match("%d") then
        decode_error("Invalid number")
      end
      while pos &lt;= #str and str:sub(pos, pos):match("%d") do
        pos = pos + 1
      end
    end
    
    return tonumber(str:sub(start_pos, pos - 1))
  end -- function parse_number
  
  local function parse_value()
    skip_whitespace()
    
    local c = str:sub(pos, pos)
    
    if str:sub(pos, pos + 3) == "null" then
      pos = pos + 4
      return nil
    elseif str:sub(pos, pos + 3) == "true" then
      pos = pos + 4
      return true
    elseif str:sub(pos, pos + 4) == "false" then
      pos = pos + 5
      return false
    elseif c == '"' then
      return parse_string()
    elseif c == "-" or c:match("%d") then
      return parse_number()
    elseif c == "[" then
      pos = pos + 1
      skip_whitespace()
      
      local arr = {}
      
      -- Empty array
      if str:sub(pos, pos) == "]" then
        pos = pos + 1
        return arr
      end
      
      while pos &lt;= #str do
        table.insert(arr, parse_value())
        skip_whitespace()
        
        local next_char = str:sub(pos, pos)
        if next_char == "]" then
          pos = pos + 1
          return arr
        elseif next_char == "," then
          pos = pos + 1
          skip_whitespace()
        else
          decode_error("Expected ',' or ']' in array")
        end
      end
    end
    
    -- object
    if c == "{" then
      pos = pos + 1
      skip_whitespace()
      
      local obj = {}
      
      -- Empty object
      if str:sub(pos, pos) == "}" then
        pos = pos + 1
        return obj
      end
      
      while pos &lt;= #str do
        skip_whitespace()
        
        -- Parse key
        local key = parse_value()
        skip_whitespace()
        
        if str:sub(pos, pos) ~= ":" then
          decode_error("Expected ':' after object key")
        end
        pos = pos + 1
        
        -- Parse value
        obj[key] = parse_value()
        skip_whitespace()
        
        local next_char = str:sub(pos, pos)
        if next_char == "}" then
          pos = pos + 1
          return obj
        elseif next_char == "," then
          pos = pos + 1
        else
          decode_error("Expected ',' or '}' in object")
        end
      end -- while
    end -- object parsing
    
    decode_error("Unexpected character: " .. c)
  end -- function parse_value
  
  local result = parse_value()
  skip_whitespace()
  
  if pos &lt;= #str then
    decode_error("Unexpected content after JSON value")
  end
  
  return result
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>pathes_helper</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------


function getRepoPath(extension)
  local path_table = string.split(getModulePath("Mundron_Core"), "/")
  local result = table.concat(path_table, "/", 1, #path_table - 2)
  if extension then
    result = f"{result}/{extension}"
  end
  return result
end

function getRepoDataPath(extension)
  local result = getRepoPath(f"data")
  if not io.exists(result) then
    lfs.mkdir(path)
  end
  if extension then
    result = f"{result}/{extension}"
  end
  return result
end

function getRepoPicturePath(extension)
  local result = getRepoPath("pictures")
  if extension then
    result = f"{result}/{extension}"
  end
  if not io.exists(result) then
    local msg = f"Die Datei {result} wurde nicht gefunden"
  end
  return result
end


function getProfileDataPath(extension)
  local result = f"{getMudletHomeDir()}/data"
  if not io.exists(result) then
    lfs.mkdir(result)
  end
  if extension then
    result = f"{result}/{extension}"
  end
  return result
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>colored_print_helper</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Here are three colored echos        --
--                                             --
-------------------------------------------------

function print_help(filename, verbose)
  for _, line in ipairs(mload_jsonl(filename)) do
    for _, txt in ipairs(line) do
      print(txt)
      if not verbose then
        break
      end
    end
  end
end

local function get_prefix(keyword, reference)
  local result = ""
  if reference then
    result = f("{keyword} ({reference}): ")
  else
    result = f("{keyword}: ")
  end
  return result
end

function wprint(text, reference)
  echo("\n")
  print(text, {get_prefix("WARNUNG", reference), "&lt;255,255,0:0,0,0&gt;"})
  echo("\n")
end

function eprint(text, reference)
  echo("\n")
  print(text, {get_prefix("FEHLER", reference), "&lt;255,155,0:0,0,0&gt;"})
  echo("\n")
end

function iprint(text, reference)
  print(text, {get_prefix("INFO", reference), "&lt;120,170,255:0,0,0&gt;"})
end

local text_farben =
  {
    r = "&lt;235,80,80:0,0,0&gt;",
    g = "&lt;155,255,0:0,0,0&gt;",
    b = "&lt;120,170,255:0,0,0&gt;",
    lb = "&lt;120,170,255:0,0,0&gt;",
    o = "&lt;255,155,55:0,0,0&gt;",
    l = "&lt;155,155,255:0,0,0&gt;",
    y = "&lt;205,205,0:0,0,0&gt;",
    ly = "&lt;255,255,0:0,0,0&gt;",
    c = "&lt;0,255,255:0,0,0&gt;",
    m = "&lt;255,0,255:0,0,0&gt;",
  }
  
local function print_with_breaks(text, pre)
  pre = pre or {"", ""}
  decho(f("{pre[2]}{pre[1]}"))
  local pre_len = len(pre[1])
  local pseudo_pre = ""
  for i = 1, pre_len, 1 do
    pseudo_pre = f("{pseudo_pre} ")
  end
  local line_size = pre_len
  for _, text_part in ipairs(text) do
    woerter = text_part[1]
    farbe = text_farben[text_part[2]] or ""
    for _, word in ipairs(string.split(woerter)) do
      -- check if word contains line break symbols
      local word_tab = string.split(word, "\n")
      if len(word_tab) == 1 then
        if line_size + #word &lt; 78 then
          decho(f("{farbe}{word} "))
          line_size = line_size + #word + 1
        else
          decho(f("\n{pseudo_pre}{farbe}{word} "))
          line_size = pre_len + #word + 1
        end
      else
        if line_size + #word_tab[1] &lt; 78 then
          decho(f("{farbe}{word_tab[1]}"))
        else
          decho(f("\n{pseudo_pre}{farbe}{word_tab[1]}"))
        end
        for i=2,len(word_tab),1 do
          if len(word_tab[i]) == 0 then
            decho(f("\n{pseudo_pre}"))
            line_size = pre_len
          else
            decho(f("\n{pseudo_pre}{farbe}{word_tab[i]} "))
            line_size = pre_len + len(word_tab[1]) + 1
          end
        end
      end
    end
  end
  echo("\n")
end

function print(text, pre)
  if type(pre) == "string" then
    pre = {pre, nil}
  end
  if type(text) == "string" then
    print_with_breaks({{text, nil}}, pre)
  elseif type(text) == "table" then
    new_text = {}
    for _, t in pairs(text) do
      if type(t) == "string" then
        table.insert(new_text, {t, nil})
      elseif type(t) == "table" then
        table.insert(new_text, t)
      end
    end
    print_with_breaks(new_text, pre)
  end
end

function print_table(tab)
  local temp = {}
  for i = 1, #tab do
    for j = 1, #tab[i] do
      if temp[j] then
        table.insert(temp[j], tab[i][j])
      else
        temp[j] = {tab[i][j]}
      end
    end
  end
  for i = 1, #temp do
    for j = 1, #temp[i] do
      decho(temp[i][j])
    end
    echo("\n")
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>io_helper</name>
				<packageName></packageName>
				<script>-------------------------------------------------
-- generel load/save functions
-------------------------------------------------

function load_csv(path)
  if path == nil then
    eprint("Kein Dateiname zum Laden gegeben.")
    return
  end
  if io.exists(path) then
    local result = {}
    for line in io.lines(path) do
      table.insert(result, string.split(line, ";"))
    end
    return result
  elseif FirstCall:is_first_call(path) then
    save_csv({}, path)
    FirstCall:complete_first_call(path)
    return {}
  else
    local msg = f"Datei {path} zum Laden nicht gefunden"
    printError(msg, true, true)
    return nil
  end
end

function load_tlines(path)
  if path == nil then
    eprint("Kein Dateiname zum Laden gegeben.")
    return
  end
  if io.exists(path) then
    local lines = {}
    for sline in io.lines(path) do
      sline = sline:gsub("\r", "")
      table.insert(lines, sline)
    end
    return lines
  elseif FirstCall:is_first_call(path) then
    save_tlines({}, path)
    FirstCall:complete_first_call(path)
    return {}
  else
    local msg = f"Datei {path} zum Laden nicht gefunden"
    printError(msg, true, true)
    return nil
  end
end

function load_json(path, default)
  default = default or {}
  if path == nil then
    eprint("Kein Dateiname zum Laden gegeben.")
    return
  end
  local file = io.open(path, "r")
  if file then
    local content = file:read("*all")
    file:close()
    return json.decode(content)
  elseif FirstCall:is_first_call(path) then
    save_json(default, path)
    FirstCall:complete_first_call(path)
    return default
  else
    local msg = f"Datei {path} zum Laden nicht gefunden"
    printError(msg, true, true)
    return nil
  end
end

function load_jsonl(path)
  if path == nil then
    eprint("Kein Dateiname zum Laden gegeben.")
    return
  end
  if io.exists(path) then
    local lines = {}
    for sline in io.lines(path) do
      table.insert(lines, json.decode(sline))
    end
    return lines
  elseif FirstCall:is_first_call(path) then
    save_jsonl({}, path)
    FirstCall:complete_first_call(path)
    return {}
  else
    local msg = f"Datei {path} zum Laden nicht gefunden"
    printError(msg, true, true)
    return nil
  end
end


function save_csv(lines, path, setting)
  -- delimiter is ; because , are used in descriptions
  if #lines == 0 and io.exists(path) then
    eprint(f"Versuch die Datei {path} leer zu ueberschreiben verhindert!")
    return
  end
  local file = io.open(path, "w+")
  local temp
  if setting then
    if type(setting) == 'table' then
      file:write(table.concat(setting, ";"), "\n")
    else
      file:write(setting, "\n")
    end
  end
  for k, v in ipairs(lines) do
    if type(v) == 'table' then
      file:write(table.concat(v, ";") .. "\n")
    else
      file:write(v, "\n")
    end
  end
  file:close()
end

function save_tlines(lines, path)
  if #lines == 0 and io.exists(path) then
    eprint(f"Versuch die Datei {path} leer zu ueberschreiben verhindert!")
    return 
  end
  local file = io.open(path, "w+")
  for _, v in ipairs(lines) do
    file:write(v, "\n")
  end
  file:close()
end


function save_json(tab, path)
  if type(tab) == "table" and len(tab) == 0 and io.exists(path) then
    printError(f"Versuch die Datei {path} leer zu ueberschreiben verhindert!")
    return
  end
  local file = io.open(path, "w+")
  file:write(json.encode(tab))
  file:close()
end

function save_jsonl(tab, path)
  if len(tab) == 0 and io.exists(path) then
    eprint(f"Versuch die Datei {path} leer zu ueberschreiben verhindert!")
    return
  end
  local file = io.open(path, "w+")
  for _, line in spairs(tab) do
    file:write(json.encode(line), "\n")
  end
  file:close()
end


-------------------------------------------------
-- module load/save functions
-------------------------------------------------

function mload_csv(filename)
  -- this function loads a csv file from the modules folder
  return load_csv(getRepoDataPath(f"{filename}.csv"))
end

function mload_tlines(filename)
  -- this function loads a text file from the modules folder
  return load_tlines(getRepoDataPath(f"{filename}.txt"))
end

function mload_json(filename, default)
  return load_json(getRepoDataPath(f"{filename}.json"), default)
end

function mload_jsonl(filename)
  return load_jsonl(getRepoDataPath(f"{filename}.jsonl"))
end

function msave_csv(lines, filename)
  return save_csv(lines, getRepoDataPath(f"{filename}.csv"))
end

function msave_tlines(lines, filename)
  return save_tlines(lines, getRepoDataPath(f"{filename}.txt"))
end

function msave_json(tab, filename)
  return save_json(tab, getRepoDataPath(f"{filename}.json"))
end

function msave_jsonl(tab, filename)
  return save_jsonl(tab, getRepoDataPath(f"{filename}.jsonl"))
end

-------------------------------------------------
-- profile load/save functions
-------------------------------------------------

function pload_csv(filename)
  -- this function loads a csv file from the profiles folder
  return load_csv(getProfileDataPath(f"{filename}.csv"))
end

function pload_tlines(filename)
  -- this function loads a text file from the profiles folder
  return load_tlines(getProfileDataPath(f"{filename}.txt"))
end

function pload_json(filename, default)
  return load_json(getProfileDataPath(f"{filename}.json"), default)
end

function pload_jsonl(filename)
  return load_jsonl(getProfileDataPath(f"{filename}.jsonl"))
end

function psave_csv(lines, filename, setting)
  -- this function saves a text file from the profiles folder
  --
  return save_csv(lines, getProfileDataPath(f"{filename}.csv"), setting)
end

function psave_tlines(lines, filename)
  -- this function saves a csv file from the profiles folder
  --
  return save_tlines(lines, getProfileDataPath(f"{filename}.txt"))
end

function psave_json(tab, filename)
  return save_json(tab, getProfileDataPath(f"{filename}.json"))
end

function psave_jsonl(tab, filename)
  return save_jsonl(tab, getProfileDataPath(f"{filename}.jsonl"))
end

-------------------------------------------------
-- remove file functions
-------------------------------------------------

local function remove(path)
  if io.exists(path) then
    os.remove(path)
    FirstCall:remove_first_call(path)
  end
end

function mremove_csv(filename)
  remove(getRepoDataPath(f"{filename}.csv"))
end

function mremove_tlines(filename)
  remove(getRepoDataPath(f"{filename}.txt"))
end

function mremove_json(filename)
  remove(getRepoDataPath(f"{filename}.json"))
end

function mremove_jsonl(filename)
  remove(getRepoDataPath(f"{filename}.jsonl"))
end

function premove_csv(filename)
  remove(getProfileDataPath(f"{filename}.csv"))
end

function premove_tlines(filename)
  remove(getProfileDataPath(f"{filename}.txt"))
end

function premove_json(filename)
  remove(getProfileDataPath(f"{filename}.json"))
end

function premove_jsonl(filename)
  remove(getProfileDataPath(f"{filename}.jsonl"))
end

-------------------------------------------------
-- move file functions
-------------------------------------------------

local function move(old_file, new_file)
  if io.exists(new_file) then
    return
  end
  if not io.exists(old_file) then
    printError(f"Missing file to move {old_file}")
  end
  os.rename(old_file, new_file)
  FirstCall:remove_first_call(path)
end

function mmove_csv(old_filename, new_filename)
  move(getRepoDataPath(f"{old_filename}.csv"), getRepoDataPath(f"{new_filename}.csv"))
end

function mmove_tlines(old_filename, new_filename)
  move(getRepoDataPath(f"{old_filename}.txt"), getRepoDataPath(f"{new_filename}.txt"))
end

function mmove_json(old_filename, new_filename)
  move(getRepoDataPath(f"{old_filename}.json"), getRepoDataPath(f"{new_filename}.json"))
end

function mmove_jsonl(old_filename, new_filename)
  move(getRepoDataPath(f"{old_filename}.jsonl"), getRepoDataPath(f"{new_filename}.jsonl"))
end

function pmove_csv(old_filename, new_filename)
  move(getProfileDataPath(f"{old_filename}.csv"), getProfileDataPath(f"{new_filename}.csv"))
end

function pmove_tlines(old_filename, new_filename)
  move(getProfileDataPath(f"{old_filename}.txt"), getProfileDataPath(f"{new_filename}.txt"))
end

function pmove_json(old_filename, new_filename)
  move(getProfileDataPath(f"{old_filename}.json"), getProfileDataPath(f"{new_filename}.json"))
end

function pmove_jsonl(old_filename, new_filename)
  move(getProfileDataPath(f"{old_filename}.jsonl"), getProfileDataPath(f"{new_filename}.jsonl"))
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>formatting_text_helper</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

function normalized_text(text) 
  return string.lower(string.gsub(text, "[%c%s]+", ""))
end

function norm_length(strings, orientation, extra)
  local max_len = 0
  if type(orientation) == "number" then
    if (not (orientation == -1)) and (not (orientation == 1)) then
      eprint(
        "Fehler bei der Formatierung: Orientierung muss -1 (rechtsbuendig) oder 1 (linksbuendig) sein."
      )
      return
    end
  else
    orientation = -1
  end
  local len = 0
  for i, v in ipairs(strings) do
    if type(v) == "number" then
      v = tostring(v)
      strings[i] = v
    end
    len = #v
    for m in v:gmatch("&lt;%d+,%d+,%d+:%d+,%d+,%d+&gt;") do
      len = len - #m
    end
    if len &gt; max_len then
      max_len = len
    end
  end
  extra = extra or 0
  local extra_space = ""
  for i = 1,extra,1 do
    extra_space = extra_space.." "
  end
  local temp
  for i = 1, #strings do
    temp = ""
    len = #strings[i]
    for m in strings[i]:gmatch("&lt;%d+,%d+,%d+:%d+,%d+,%d+&gt;") do
      len = len - #m
    end
    for i = 1, max_len - len do
      temp = temp .. " "
    end
    if orientation == -1 then
      strings[i] = extra_space .. strings[i] .. temp .. extra_space
    else
      strings[i] = temp .. extra_space .. strings[i] .. extra_space
    end
  end
  return strings
end

function norm_table(tab, orientations, extras)
  if type(orientations) == "nil" then
    orientation = {}
    for i = 1, len(tab) do
      table.insert(orientation, -1)
    end
  elseif type(orientations) == "number" then
    local orient = orientations
    orientations = {}
    for i = 1, len(tab) do
      table.insert(orientations, orient)
    end
  end
  if type(extras) == "nil" then
    extras = {}
    for i = 1, len(tab) do
      table.insert(extras, 0)
    end
  elseif type(extras) == "number" then
    local extra = extras
    extras = {}
    for i = 1, len(tab) do
      table.insert(extras, extra)
    end
  end
  for i = 1, len(tab) do
    tab[i] = norm_length(tab[i], orientations[i], extras[i])
  end
  return tab
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>extensions</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>table_extensions</name>
				<packageName></packageName>
				<script>function table.remove_at(tab, index)
  local table_size = len(tab)
  if index &lt; 0 then
    index = table_size + index
    if index &lt; 1 then
      eprint(f("The table has just {table_size} elements, can't remove at position {index}."))
      return false
    end
  end
  if index == 0 or index &gt; len(tab) then
    eprint(f("The table has just {table_size} elements, can't remove at position {index}."))
    return false
  end
  -- shift values
  for i=index+1,len(tab),1 do
    tab[i-1] = tab[i]
  end
  -- remove last element
  table.remove(tab)
  return true
end

function table.add(tab, value)
  if not table.contains(tab, value) then
    table.insert(tab, value)
  end
end

function table.remove_value(tab, value)
  local index = table.index_of(tab, value)
  if not index then
    eprint(f("The table has no value '{value}' to remove."))
    return false
  else
    table.remove_at(tab, index)
    return true
  end
end

function table.values(tab)
  local result = {}
  for _, value in pairs(tab) do
    table.insert(result, value)
  end
  return result
end

local function deep_set(target, keys, value, idx)
  idx = idx or 1
  local pivot = keys[idx]
  if idx == #keys then
    target[pivot] = value
  else
    if not target[pivot] then
      target[pivot] = {}
    end
    deep_set(target[pivot], keys, value, idx + 1) 
  end
end

function table.set(tab, key, value)
  if type(key) == "string" then
    deep_set(tab, key:split("%."), value)
  else
    tab[key] = value
  end
end

local function deep_get(source, keys, idx)
  idx = idx or 1
  local pivot = keys[idx]
  if source == nil then
    return nil
  end
  if idx == #keys then
    return source[pivot]
  else
    return deep_get(source[pivot], keys, idx + 1)
  end
end

function table.get(tab, key, default_value)
  local result = nil
  if type(key) == "string" then
    result = deep_get(tab, key:split("%."))
  else
    result = tab[key]
  end
  if result == nil and default_value ~= nil then
    table.set(tab, key, default_value)
    result = default_value
  end
  return result
end

function table.fold(tab, field_name)
  -- transform a table such that the keys 
  -- part of the values.
  -- {st={title="Sandtiger"}} with 
  -- field_name == "name" will return
  -- { {name="st", title="Sandtiger"} }

  local result = {}
  for id, props in pairs(tab) do
    local data = {}
    data[field_name] = id
    for pkey, pvalue in pairs(props) do
      data[pkey] = pvalue
    end
    table.insert(result, data)
  end
  return result
end

function table.unfold(tab, field_name)
  -- inverse to table.fold we move a value
  -- out of the data as a key of the result
  
  local result = {}
  for _, data in spairs(tab) do
    local id = nil
    local props = {}
    for pkey, pvalue in pairs(data) do
      if pkey == field_name then
        id=pvalue
      else
        props[pkey] = pvalue
      end
    end
    result[id] = props
  end
  return result
end

function table.apply(tab, func)
  local result = {}
  for _, v in pairs(tab) do
    table.insert(result, func(v))
  end
  return result
end

function table.subtable(tab, start_index, end_index)
  local result = {}
  for i=start_index,end_index,1 do
    table.insert(result, tab[i])
  end 
  return result
end

function table.indent_lines(tab, indent)
  local new_line = f("\n{indent}")
  local result = f("{indent}{table.concat(tab, new_line)}") 
  return result
end

function table.indent_lines_with_breaks(tab, indent)
  local result = {}
  for _,line in ipairs(tab) do
    table.insert(result, string.indent_lines(line, indent))
  end
  return table.concat(result, "\n")
end

function table.append_table(tab_a, tab_b)
  for _,item in ipairs(tab_b) do
    table.insert(tab_a, item)
  end
end

function table.update(base_table, updates, keep)
  for key, value in pairs(updates) do
    if type(value) == "table" and type(base_table[key]) == "table" then
      table.update(base_table[key], value, keep)
    elseif (base_table[key] == nil) or not keep then
      base_table[key] = value
    end
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>string_extensions</name>
				<packageName></packageName>
				<script>function break_lines(text, length)
  length = length or 59
  local result = {""}
  local index = 1
  for s in text:gmatch("[^%s]+") do
    if len(result[index] .. s) &lt; length then
      if len(result[index]) &gt; 0 then
        result[index] = result[index] .. " " .. s
      else
        result[index] = s
      end
    else
      index = index + 1
      table.insert(result, s)
    end
  end
  return result
end

function substring(text, subtext)
  return string.match(text, subtext)
end

function string.startswith(text, subtext)
  return text:sub(1, #subtext) == subtext
end

function string.endswith(text, subtext)
  return text:sub(-#subtext) == subtext
end

function string.strip(text)
  local start_index = 1
  local end_index = text:len()
  for i=1,text:len(),1 do
    local c=text:sub(i,i)
    if c == " " then
      start_index = i+1
    else
      break
    end
  end
  for i=text:len(),1,-1 do
    local c=text:sub(i,i)
    if c == " " then
      end_index = i-1
    else
      break
    end
  end
  if end_index &lt;= start_index then
    return ""
  else
    return text:sub(start_index, end_index)
  end
end

function string.indent_lines(text, indent)
  local result = {}
  for word in text:gmatch("[^%s]+") do
    local prev = result[len(result)]
    if prev and len(prev) + 1 + len(word) &lt; 78 then
      result[len(result)] = f("{prev} {word}")
    else
      table.insert(result, f("{indent}{word}"))
    end
  end
  return table.concat(result, "\n")
end

function string.rep(txt, size)
  local result = ""
  for _=1,size,1 do
    result = f"{result}{txt}"
  end
  return result
end

function string.fill(text, filler)
  filler = filler or " "
  local left = 76 - len(text)
  local rem = left % 2
  local fill_text = string.rep(filler, ((left-rem) / 2) -1)
  local result = f"{fill_text} {text} {fill_text}"
  if rem &gt; 0 then
    result = f"{result}{filler}"
  end
  return result
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>MundronClassMethods</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>MCM_init</name>
				<packageName></packageName>
				<script>------------------------------------
---  Meta-table for class objects.
------------------------------------

MundronClassMethods = {}


local function load(obj, only_game)
  return function(event_name, module_name)
    if module_name ~= obj:name("module") then
      return
    end
    obj:info(f"Go! {event_name} / {module_name}")
    if only_game then
      obj:info("Load game data")
      obj:_load_data("game")
    else
      obj:info("Load all")
      obj:load_config()
      obj:load_data() -- load both: game and profile!
    end
    obj:info("Check for post load")
    display(obj["post_load_data"])
    if obj["post_load_data"] then
      obj:post_load_data()
    end
    obj:info("End")
  end
end

function MundronClassMethods.new(t)
  -- assert test fields
  assert(type(t) == "table", f"MundronClassMethods: Incoming object is no table")
  for _, field in ipairs({"_name", "_version", "_module"}) do
    assert(t[field], f"MundronClassMethods: Missing required field: '{field}'")
  end
  
  -- create object and add inferrences
  local object = setmetatable(t, {__index=MundronClassMethods})
  for _, extra in pairs({"config", "meta"}) do
    object[f"_{extra}_name"] = object:name(extra)
  end
  for _, name in pairs({"trigger", "timer", "alias", "data", "event"}) do
    object[name] = table.get(object, name, {})
  end
  
  -- register function to load data once the module is installed
  local name = object:name()
  --if not registerNamedEventHandler(getProfileName(), name, "sysInstall", load(object)) then
  --  object:error("Error in registering load function for event sysInstall")
  --end
  registerAnonymousEventHandler("sysInstall", load(object))
  object.event["sysInstall"] = "load(object)"
  -- register function to load game data at global event
  --local event_name = object:load_event_name()
  --if not registerNamedEventHandler(getProfileName(), object:name(), event_name, load(object, true)) then
  --  object:error(f"Error in registering load function for event {event_name}")
  --end
  registerAnonymousEventHandler(event_name, load(object, true))
  object.event[event_name] = "load(object)"
  
  return object
end

-- dummy functions to raise NotImplementedError if required but forgotten!
function MundronClassMethods:migrate_profile()
  printError(f"Profile Migration von Dateien des Modules {self:name()} is nicht implementiert!", true, true)
end

function MundronClassMethods:migrate_game()
  printError(f"Spiel Migration von Dateien des Modules {self:name()} is nicht implementiert!", true, true)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>MCM_load_save_data</name>
				<packageName></packageName>
				<script>function MundronClassMethods:load_data()
  if not self.files then
    return
  end
  for _, target in pairs({"game", "profile"}) do
    if self.files[target] then
      self:_load_data(target)
    end  
  end
end

function MundronClassMethods:save_data()
  if not MundronClassMethods.files then
    return
  end
  self:save_game()
  self:save_profile()
end
  
function MundronClassMethods:save_game()
  for field, default in pairs(self.files.game or {}) do
    msave_json(table.get(self.data, field, default), self:name(field))
  end
  local event_name
  raiseGlobalEvent(self:load_event_name())
end

function MundronClassMethods:save_profile()
  for field, default in pairs(self.files.profile or {}) do
    psave_json(table.get(self.data, field, default), self:name(field))
  end
end

function MundronClassMethods:load_event_name()
  local event_name = f"load_game_data_for_{self:name()}_from_{self.name('module')}"
  return event_name
end

function MundronClassMethods:_load_data(key)
  if self.files[key] == nil then
    self:error(f"Keine {key} Daten zum Laden!")
    return
  end
  
  local load_json, save_json = pload_json, psave_json
  if key == "game" then
    load_json, save_json = mload_json, msave_json
  end
  -- check version and call accordingly migration
  local saved_version = load_json(self._meta_name)._version or ""
  if saved_version &lt; self._version then
    if key == "game" then
      self:migrate_game(saved_version)
    else
      self:migrate_profile(saved_version)
    end
    save_json(self:meta(), self._meta_name)
  end
  
  -- load data
  for field, default in pairs(self.files[key] or {}) do
    table.set(self.data, field, load_json(self:name(field), default))
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>MCM_config_meta</name>
				<packageName></packageName>
				<script>------------------------------------------------------
--
-- local functions
--
------------------------------------------------------

function MundronClassMethods:load_config()
  self.config = pload_json(self._config_name, self.config)
end

function MundronClassMethods:save_config()
  psave_json(self.config, self._config_name)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>MCM_misc</name>
				<packageName></packageName>
				<script>------------------------------------------------------
--
-- local functions
--
------------------------------------------------------
local function is_meta(key)
  return key:sub(1,1) == "_" and key:sub(1,2) ~= "__"
end

local function is_simple_value(value)
  local t = type(value)
  return t == "string" or t == "number" or t == "boolean"
end

------------------------------------------------------
--
-- class functions
--
------------------------------------------------------
function MundronClassMethods:name(extra)
  if extra == nil then
    return self._name
  elseif extra == "module" then
    return self._module
  else
    local cleaned_extra = extra:gsub("%.", "_")
    local result = f"{self._name}_{cleaned_extra}"
    return result
  end
end

function MundronClassMethods:meta()
  local result = {}
  for k,v in pairs(self) do
    if is_meta(k) then
      result[k] = v
    end
  end
  return result
end

function MundronClassMethods:keys(parent)
  local base = self
  if parent ~= nil then
    base = table.get(self, parent)
  end
  if len(base) == 0 then
    self:info(f"Got empty list for key {parent}")
  end
  for k, v in pairs(base) do
    local var_type = type(v)
    if not (is_meta(k) or var_type == "function") then
      if var_type == "table" then
        print(f"{k}: table -&gt; length {len(v)}")
      elseif is_simple_value(v) then
        print(f"{k}: type {var_type} -&gt; {v}")
      end  
    end
  end
end

function MundronClassMethods:info(text)
  iprint(text, self:name())
end

function MundronClassMethods:warn(text)
  wprint(text, self:name())
end

function MundronClassMethods:error(text)
  eprint(text, self:name())
  printError(text, true, true)
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>initGMCP</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--   Sagt gmcp, dass er alle Daten senden soll --
-------------------------------------------------

function initGMCP()
  if not gmpc_is_initialized then
    sendGMCP([[Core.Supports.Set [ "MG.char 1", "MG.room 1", "comm.channel 1" ] ]])
    if deleteOldProfiles then
      deleteOldProfiles(7)
    end
    gmcp_is_initialized = true
  end
end

function test_gmcp(...)
  if not gmcp or not gmcp.MG then
    return false
  end
  local reference = gmcp.MG
  for _, key in ipairs(arg) do
    if reference[key] then
      reference = reference[key]
    else
      return false
    end
  end
  return true
end</script>
			<eventHandlerList>
				<string>gmcp.Char</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>color_communication</name>
			<packageName></packageName>
			<script>farben = {
  vg = {
    komm = "cyan", 
    ebenen = "red", 
    info = "green", 
    alarm = "white", 
    script = "dark_green"
  },
  bg = {
    komm = "black", 
    ebenen = "black", 
    info = "black", 
    alarm = "red", 
    script = "black"
  },
}
function set_text_color(fg_type, bg_type)
  local fg_color = farben.vg[fg_type] or fg_type
  local bg_color = farben.bg[bg_type] or bg_type or farben.bg[fg_type] or fg_color
  fg(fg_color)
  bg(bg_color)
end

function color_communication()
  set_text_color("ebenen")
  echo(gmcp.comm.channel.msg)
  resetFormat()
end

function set_line_color(fg_type, bg_type)
  select_line_color(fg_type, bg_type)
  resetFormat()
end

function select_line_color(fg_type, bg_type)
  selectCurrentLine()
  set_text_color(fg_type, bg_type)
end</script>
			<eventHandlerList>
				<string>gmcp.comm.channel</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>Trigger</name>
			<packageName></packageName>
			<script>TRIGGER = TRIGGER or {}</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>misc</name>
			<packageName></packageName>
			<script>function log(text)
  local timestamp = os.date("%Y-%m-%d#%H-%M", os.time())
  local file = io.open(getProfileDataPath("debug.log"), "a")
  file:write(f"{timestamp} - {text}\n")
  file:close()
end

function len(obj)
  if type(obj) == "string" then
    return string.len(obj)
  elseif type(obj) == "table" then
    return table.size(obj)
  else
    return 0
  end
end</script>
			<eventHandlerList />
		</Script>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
