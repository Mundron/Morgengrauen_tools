<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>trigger_dummy</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>xxx</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
	</TriggerPackage>
	<TimerPackage>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>catch_portal_room_ids</name>
			<script>if PathEditor.portal_to_visit &lt; 41 then
  local node = PathData.node[f("p{PathEditor.portal_to_visit}")]
  local room_id = gmcp.MG.room.info.id
  if len(room_id) &gt; 0 and not table.contains(node.ids, room_id) then
    table.insert(node.ids, room_id)
  end
  PathEditor.portal_to_visit = PathEditor.portal_to_visit + 1
  send(f("teleportiere {PathEditor.portal_to_visit}"))
else
  disableTimer("catch_portal_room_ids")
  PathData:save()
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>catch_portal_room_ids</name>
			<script>if PathEditor.portal_to_visit &lt; 41 then
  local node = PathData.node[f("p{PathEditor.portal_to_visit}")]
  local room_id = gmcp.MG.room.info.id
  if len(room_id) &gt; 0 and not table.contains(node.ids, room_id) then
    table.insert(node.ids, room_id)
  end
  PathEditor.portal_to_visit = PathEditor.portal_to_visit + 1
  send(f("teleportiere {PathEditor.portal_to_visit}"))
else
  disableTimer("catch_portal_room_ids")
  PathData:save()
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>catch_portal_room_ids</name>
			<script>if PathEditor.portal_to_visit &lt; 41 then
  local node = PathData.node[f("p{PathEditor.portal_to_visit}")]
  local room_id = gmcp.MG.room.info.id
  if len(room_id) &gt; 0 and not table.contains(node.ids, room_id) then
    table.insert(node.ids, room_id)
  end
  PathEditor.portal_to_visit = PathEditor.portal_to_visit + 1
  send(f("teleportiere {PathEditor.portal_to_visit}"))
else
  disableTimer("catch_portal_room_ids")
  PathData:save()
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>catch_portal_room_ids</name>
			<script>if PathEditor.portal_to_visit &lt; 41 then
  local node = PathData.node[f("p{PathEditor.portal_to_visit}")]
  local room_id = gmcp.MG.room.info.id
  if len(room_id) &gt; 0 and not table.contains(node.ids, room_id) then
    table.insert(node.ids, room_id)
  end
  PathEditor.portal_to_visit = PathEditor.portal_to_visit + 1
  send(f("teleportiere {PathEditor.portal_to_visit}"))
else
  disableTimer("catch_portal_room_ids")
  PathData:save()
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.000</time>
		</Timer>
	</TimerPackage>
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>WayFinder</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Wegaufzeichnung</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Wegaufzeichnung starten</name>
					<script>---@pattern #WAstart
---@desc Der Start einer Wegaufzeichnung muss an einem Knoten beginnen.
---@desc Falls keiner vorhanden muss der mit #WAnode erstellt werden.
WayFinder:start()</script>
					<command></command>
					<packageName></packageName>
					<regex>^#WAstart$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Wegaufzeichnung beenden</name>
					<script>---@pattern #WAstop
---@desc Die Wegaufzeichnung muss an einem Knoten enden.
---@desc Falls keiner vorhanden muss der mit #WAnode erstellt werden.
WayFinder:stop()</script>
					<command></command>
					<packageName></packageName>
					<regex>^#WAstop$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Wegaufzeichnung abbrechen</name>
					<script>---@pattern #WAabort
---@desc Dies loescht die bisherige Aufzeichnunge
WayFinder:abort()</script>
					<command></command>
					<packageName></packageName>
					<regex>^#WAabort$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Knoten erstellen/hinzufuegen</name>
					<script>---@pattern #WAnode &lt;name&gt;:&lt;title&gt;?
---@desc Der Titel kann optional weggelassen werden. 
---@desc Wird waehrend einer Wegaufzeichnung ein Knoten erstellt, wird dies
---@desc automatisch der Aufzeichnung hinzugefuegt. Insbesondere am Ende.
---@desc Beispiele: #WAnode ef
---@desc            #WAnode ef:Elfendort irgendwo im Wald
WayFinder:save_node(matches[2], matches[4])</script>
					<command></command>
					<packageName></packageName>
					<regex>^#WAnode ([\w\d_]+)(:(.+))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Wait hinzufügen</name>
					<script>---@pattern #WAwait &lt;Sekunden&gt;
---@desc Fuege an der Stelle in der Wegaufzeichnung das Warten 
---@desc entsprechend vieler Sekunden ein.
WayFinder:add_wait(tonumber(matches[2]))</script>
					<command></command>
					<packageName></packageName>
					<regex>^#WAwait (\d+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Blocker hinzufügen</name>
					<script>---@pattern #WAblocker &lt;Name&gt;:&lt;Knuddel&gt;:&lt;Tod&gt;
---@desc Fuer &lt;Knuddel&gt; und &lt;Tod&gt; kann jeweils auch nur entsprechender Artikel
---@desc eingesetzt werden fuer die Standard-Meldung. Ansonsten wird der ganze
---@desc Text genommen.
---@desc Beispiele: #WAblocker polartiger:den:der
---@desc               erstellt den Knuddeltext
---@desc               "Du knuddelst den Polartiger."
---@desc               und die Todesmeldung
---@desc               "Der Polartiger faellt tot zu Boden."
---@desc            #WAblocker hase:Huepft um dich herum.:Faellt theatralisch zusammen.
---@desc               uebernimmt exakt die obigen Texte
---@desc               als Knuddeltext und Todesmeldung.

WayFinder:add_blocker(matches[2], matches[3], matches[4])</script>
					<command></command>
					<packageName></packageName>
					<regex>^#WAblocker (\w+):([^:]+):([^:]+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Trigger hinzufügen</name>
					<script>---@pattern #WAtrigger &lt;Triggername&gt;:&lt;Ausloeseaktionen&gt;?
---@desc &lt;trigger_names&gt; ist eine Komma separierte Liste von Triggernamen
---@desc die angelegt sein muessen und an der Stelle im Weg aktiviert werden.
---@desc Dabei ist &lt;actions&gt; eine optionale Komma separierte Liste von Aktionen, 
---@desc die nach Aktivierung der Trigger in der Reihenfolge ausgefuehrt werden,
---@desc damit ein Trigger ausgeloest wird um den Weg dann fortzufuehren.

WayFinder:add_trigger(matches[2], matches[4] and string.split(matches[4], ",") or {})</script>
					<command></command>
					<packageName></packageName>
					<regex>^#WAtrigger ([\w\d\s_,]+)(:(.*))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Aktion hinzufügen</name>
					<script>---@pattern #WAdo &lt;action&gt;
---@desc Fuehrte die Aktion aus und fuegt es gleichzeitig der Wegaufzeichnung hinzu.
---@desc Beispiel: #vor zwaenge durch gebuesch

WayFinder:add_action(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^#WAdo (.+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Bedingung hinzufügen</name>
					<script>---@pattern #WAcond &lt;Feld&gt; &lt;Wert&gt;
---@desc Fuege der Aufzeichnung eine Bedingung hinzu.
---@desc Feld kann ein Wert aus: hp, sp, allowed_world
---@desc oder forbidden_world sein.

WayFinder:add_path_condition(matches[2], matches[4])</script>
					<command></command>
					<packageName></packageName>
					<regex>^#WAcond (\w+)(\s(.+))$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Letzte Schritte loeschen</name>
					<script>---@pattern #WAdel &lt;Anzahl&gt;
---@desc Falls der letzte Eintrag in der Aufzeichnung
---@desc #dopath ist, dann kann man mit Anzahl die 
---@desc entsprechende Anzahl der letzten Schritte
---@desc loeschen. Bei allen anderen Typen muss
---@desc die Anzahl 1 sein, weil sie nur als Ganzes
---@desc zu loeschen sind.

WayFinder:del_steps(tonumber(matches[2]))</script>
					<command></command>
					<packageName></packageName>
					<regex>^#WAdel (\d+)$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Darstellung</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Suche Knoten/Kanten</name>
					<script>---@pattern #WSfind &lt;Suchbegriff&gt;
---@desc Falls der Suchbegriff eine Zahl ist, wird nach entsprechender
---@desc Kante gesucht. Ansonsten wird zuerst einen exakten Match 
---@desc fur einen Knoten mit dem Namen &lt;Suchbegriff&gt; gesucht.
---@desc Anschliessend wird ein pattern Match ausgefuehrt und alle Matches aufgelistet.
if tonumber(matches[2]) then
  WayFinder:show_edge(tonumber(matches[2]))
else
  WayFinder:find_nodes(matches[2])
 end</script>
					<command></command>
					<packageName></packageName>
					<regex>^#WSfind ([^\s]+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Zeige Knoten</name>
					<script>---@pattern #WSshow
---@desc Zeige die Informationen zum Knoten an dem Du stehst.
WayFinder:find_nodes()</script>
					<command></command>
					<packageName></packageName>
					<regex>^#WSshow$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Zeige Aufzeichnung</name>
					<script>---@pattern #WAshow
---@desc Falls eine Wegaufzeichnung aktiv ist, wird die bisherige Aufzeichnung angezeigt

WayFinder:show_recording()</script>
					<command></command>
					<packageName></packageName>
					<regex>^#WAshow$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Portale anzeigen</name>
					<script>---@pattern #WSportal &lt;Key&gt;
---@desc &lt;Key&gt; entweder "all", "enabled" oder "missing" sein.
---@desc "all" -&gt; Liste alle Portale mit Titel auf
---@desc "enabled" -&gt; Liste alle fuer diesen Char verfuegbare Portale auf.
---@desc "missing" -&gt; Liste alle fuer diesen Char fehlende Portale auf.

WayFinder:show_portals(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^#WSportal (.+)$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Bearbeitung</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="no" isFolder="no">
					<name>Raum-ID vom Knoten loeschen</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Knoten/Kante loeschen</name>
					<script>---@pattern #WSdel &lt;Knotennamen oder Kanten-ID&gt;
---@desc Falls der Parameter eine Nummer ist, wird
---@desc entsprechende Kante geloescht, ansonsten
---@desc der Knoten mit dem Namen.
local eid = tonumber(matches[2])

if eid then
  WayFinder:delete_edge(eid)
else
  WayFinder:delete_edge(eid)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^#WSdel (.+)$</regex>
				</Alias>
				<Alias isActive="no" isFolder="no">
					<name>Portal erlauben</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
				</Alias>
				<Alias isActive="no" isFolder="no">
					<name>Portale erfassen</name>
					<script>---@desc Erfasse automatisch die zulaessigen Portale</script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Pfadbedingung bearbeiten</name>
					<script>---@pattern #WScond &lt;ID&gt;? &lt;Feld&gt; &lt;Wert&gt;?
---@desc Aendere die Bedingung eines Pfades mit der ID.
---@desc Feld kann ein Wert aus: hp, sp, allowed_world
---@desc oder forbidden_world sein. Falls der Wert weggelassen
---@desc wird, wird die Bedingung mit dem Feld geloescht.

WayFinder:edit_condition(tonumber(matches[2]), matches[3], matches[4])</script>
					<command></command>
					<packageName></packageName>
					<regex>^#WScond\s(\d+)\s([A-Za-z_]\w*)(?:\s(.+))?$</regex>
				</Alias>
			</AliasGroup>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Editieren</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Titel updaten</name>
				<script>PathCreator:add_node_title(matches[2], matches[3], true)</script>
				<command></command>
				<packageName></packageName>
				<regex>^#addtitle (\w+):(.+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Titel löschen</name>
				<script>PathEditor:delete_title(matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#deletetitle (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>ID hinzufügen</name>
				<script>PathCreator:add_node(matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#addid (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>ID loeschen</name>
				<script>PathEditor:delete_id_from_node(matches[2], matches[4])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#deleteid (\w+)(\s(\d+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Lösche Weg</name>
				<script>PathEditor:delete_path(tonumber(matches[2]))</script>
				<command></command>
				<packageName></packageName>
				<regex>^#deletepath (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Portal aendern</name>
				<script>PathEditor:flip_portal(tonumber(matches[2]))</script>
				<command></command>
				<packageName></packageName>
				<regex>^#flipportal (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Portale erfassen</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex>^#catchportals$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Wegbedingung hinzufuegen</name>
				<script>PathEditor:update_path_condition(tonumber(matches[2]), matches[3], tonumber(matches[4]))</script>
				<command></command>
				<packageName></packageName>
				<regex>^#addpathcondition (\w+) (\w+)=(\w+)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Wegbedingung loeschen</name>
				<script>PathEditor:delete_path_condition(tonumber(matches[2]), matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#deletepathcondition (\w+) (\w+)</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Benutzen</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="no" isFolder="no">
				<name>Laufe nach X</name>
				<script>PathFinder:go(nil, matches[2], false)</script>
				<command></command>
				<packageName></packageName>
				<regex>^#go (\w+)$</regex>
			</Alias>
			<Alias isActive="no" isFolder="no">
				<name>Renne blind</name>
				<script>if table.size(matches) == 2 then
  PathFinder:go(matches[2], true)
elseif table.size(matches) == 4 then
  PathFinder:walk(matches[2], matches[4])
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#run (\w+)(\s(\w+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Fortsetzen</name>
				<script>PathFinder:walk_stored_path()</script>
				<command></command>
				<packageName></packageName>
				<regex>^#rerun$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Vorbereiten</name>
				<script>PathEditor:prepare_path(matches[2], matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#prepare (\w+) (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Erneut vorbereiten</name>
				<script>PathEditor:reprepare_path(matches[3], matches[4])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#reprepare(\s(\w+)\s(\w+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Zuletzt gelaufen</name>
				<script>PathFinder:show_last_runned_path()</script>
				<command></command>
				<packageName></packageName>
				<regex>^#runned$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Trigger/Timer loeschen</name>
				<script>PathFinder:kill_gag_trigger()
PathFinder:clean_trigger_and_timer()
iprint("Alle Trigger und Timer des letzten Weges sind geloescht.", "WS")</script>
				<command></command>
				<packageName></packageName>
				<regex>^#clea(n|r)trigger$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Spezielle Wege</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Parallelwelten</name>
				<script>local para = matches[2]

if not PathFinder.para_start_node then
  PathFinder.para_start_node = PathData.node_by_id[gmcp.MG.room.info.id]
  if not PathFinder.para_start_node then
    eprint("Der Raum ist kein Knotenpunkt.", "WS")
    return
  end
end

local function return_to_start()
  iprint("Gehe wieder zurueck.")
  send("sw", false)
  -- use directly the function otherwise the 
  -- move to southwest isn't fast enough an
  -- expandAlias(f("#go {PathFinder.para_start_node}")
  -- will recognize the portal room as a starting
  -- point.
  PathFinder:go("p32", PathFinder.para_start_node)
  PathFinder.para_start_node = nil
  MainGUI:update_world(tonumber(para))
end

if PathFinder.para_start_node then
  -- use manually go function to use extra arguments
  if PathFinder:go(PathFinder.para_start_node, "p32", false, false, true) then
    send("no", false)
    send("betrete portal", false)
    send(para, false)
    iprint(f("Portal {para} betreten, kurz warten!"), "WS") 
    -- here comes the tricky part:
    -- we HAVE TO wait for 1.5 seconds
    -- otherwise we will be teleported 
    -- somewhere
    tempTimer(1.5, return_to_start)
  end
else
  eprint("Du befindest dich an keinem Knotenpunkt.", "WS")
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#para (\d)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Sachen verkaufen</name>
				<script>-- save the node names of nodes in shops accessable in all worlds:
PathData.all_world_shops = PathData.all_world_shops or {"brad", "umshop"}
local all_world_shop_count = table.size(PathData.all_world_shops)
-- save the node names of nodes in shops accessable only in normal world:
PathData.normal_world_shops = PathData.normal_world_shops or {}
local normal_world_shop_count = table.size(PathData.normal_world_shops)
-- set an index if not defined yet
PathData.shop_index = PathData.shop_index or 0
iprint(f("Shopindex ist {PathData.shop_index}."), "WS")
--
local shop_index = PathData.shop_index
local chosen_shop
--
if PLAYER.world() == 0 then
  if PathData.shop_index &lt; normal_world_shop_count then
    chosen_shop = PathData.normal_world_shops[shop_index + 1]
  else
    shop_index = shop_index - normal_world_shop_count
    chosen_shop = PathData.all_world_shops[shop_index + 1]
  end
else
  shop_index = PathData.shop_index % all_world_shop_count
  chosen_shop = PathData.all_world_shops[shop_index + 1]
end
PathFinder.collected_money = PathFinder.collected_money or 0
PathFinder.last_money = 0
-- add sub trigger to catch lines for drop count
PathFinder.catch_gagged_line = PathFinder.catch_gagged_line or {}
local function extract_money(catched_line)
        local money = catched_line:match("%d+ Muenzen"):match("%d+")
        PathFinder.last_money = money or 0
        if money then
          PathFinder.collected_money = PathFinder.collected_money + money
        end
      end
PathFinder.catch_gagged_line["money_to_vault"] =
  {
    pattern = "Du steckst",
    type = "startswith",
    action = extract_money,
  }
PathFinder.catch_gagged_line["money_to_ground"] =
  {
    pattern = "Du laesst",
    type = "startswith",
    action = extract_money,
  }
--
-- save the node where to are standing at the moment
local current_node = PathData.node_by_id[gmcp.MG.room.info.id]
if current_node then
  -- go to shop, sell everything
  if PathFinder:go(current_node, chosen_shop, false, false, true) then
    send("verkaufe alles in mir", false)
    -- go to your house to drop the money
    PathFinder:go(chosen_shop, "haus", false, false, current_node == "haus")
    send("oeffne tresor", false)
    send("lege muenzen in mir in tresor", false)
    -- in case the tresor is full:
    send("lass muenzen in mir fallen", false)
    PathFinder.post_run_action = PathFinder.post_run_action or {}
    PathFinder.post_run_action["drop_count"] =
      function()
        iprint(
          {
            f("Du hast {PathFinder.last_money} Gold erhalten,"),
            f("insgesamt {PathFinder.collected_money} Gold."),
          },
          "WS"
        )
      end
    -- go back to last position:
    if current_node ~= "haus" then
      PathFinder:go("haus", current_node)
    end
    -- prepare for next round
    PathData.shop_index =
      (PathData.shop_index + 1) % (all_world_shop_count + normal_world_shop_count)
  else
    eprint(f("Fehler beim Laufen zum Shop '{chosen_shop}'."), "WS")
  end
else
  eprint("Der Raum ist kein Knoten.", "WS")
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#shop$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Rieseninsel-Drops</name>
				<script>local current_node = PathData.node_by_id[gmcp.MG.room.info.id]
if current_node then
  if PLAYER.world() &gt; 0 then
    eprint("In der Para-Welt gibt es keine Drops auf der Rieseninsel", "WS")
  else
    PathFinder.drop_count = 0
    -- add sub trigger to catch lines for drop count
    PathFinder.catch_gagged_line = PathFinder.catch_gagged_line or {}
    PathFinder.catch_gagged_line["drop_count"] =
      {
        pattern = "Du bedienst Dich aus der Bonbonniere und nimmst ein Drops heraus,",
        type = "startswith",
        action =
          function()
            PathFinder.drop_count = PathFinder.drop_count + 1
          end,
      }
    --
    if PathFinder:go(current_node, "p30", false, false, true) then
      -- go to shop
      for _, dir in ipairs({"s", "w", "nw", "n", "nw", "n", "o"}) do
        send(dir, false)
      end
      -- take four times drops
      for i = 1, 4, 1 do
        send("bediene mich", false)
      end
      -- go back to portal
      for _, dir in ipairs({"w", "s", "so", "s", "so", "o", "n"}) do
        send(dir, false)
      end
      -- add action to print the count of gathered drops
      PathFinder.post_run_action = PathFinder.post_run_action or {}
      PathFinder.post_run_action["drop_count"] =
        function()
          iprint(f("Du hast {PathFinder.drop_count} Drop(s) geholt."))
        end
      -- go back to start node
      PathFinder:go("p30", current_node)
    else
      PathFinder.catch_gagged_line = {}  
    end
  end
else
  eprint("Raum ist kein Knotenpunkt", "WS")
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#sdrops$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Anzeigen</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Wegaufzeichnung zeigen</name>
				<script>PathCreator:show_last(matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#showrecord(\s(\d+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Zeige Knoten</name>
				<script>PathEditor:show_node(matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#shownode(\s(\w+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Finde Knoten</name>
				<script>PathEditor:search_node(matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#searchnode (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Zeige Weg</name>
				<script>PathEditor:show_path(tonumber(matches[2]))</script>
				<command></command>
				<packageName></packageName>
				<regex>^#showpath (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Berechne Weg</name>
				<script>PathEditor:show_prepared_path(matches[2], matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#computepath (\w+) (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Portale sehen</name>
				<script>PathEditor:show_portals()</script>
				<command></command>
				<packageName></packageName>
				<regex>^#showportals$</regex>
			</Alias>
		</AliasGroup>
		<Alias isActive="yes" isFolder="no">
			<name>Syntaxhilfe</name>
			<script>PathFinder:syntax_help()</script>
			<command></command>
			<packageName></packageName>
			<regex>^#WS$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>Gag löschen</name>
			<script>PathFinder:kill_gag_trigger()
send("schau")</script>
			<command></command>
			<packageName></packageName>
			<regex>#nogag</regex>
		</Alias>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>WS_Help</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>WS_high_help</name>
				<script>GOR:show_help("WS")</script>
				<command></command>
				<packageName></packageName>
				<regex>^\?WS$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>WS_deep_help</name>
				<script>GOR:show_help("WS", matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^\?WS (\d+(.\d+)*)$</regex>
			</Alias>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>PathData:load</name>
			<packageName></packageName>
			<script>PathData = PathData or {}

local server, _, _ = getConnectionInfo()

local node_file = "WS_Knoten"
local edge_file = "WS_Kanten"
local portal_file = "WS_nutzbare_Portale"
local alias_file = "WS_Aliases"
local gag_file = "WS_Gags"

function PathData:load()
  --
  -- nodes
  debugc("Lade Daten fuer den Wegskript.", "WS")
  self.node = table.unfold(mload_jsonl(node_file) or {}, "name")
  self.node_by_id = {}
  self.neighbour = {}
  for name, props in pairs(self.node) do
    self.neighbour[name] = {}
    for _, id in pairs(props.ids) do
      self.node_by_id[id] = name
    end
  end
  --
  -- edges
  self.edge = mload_jsonl(edge_file) or {}
  for id, props in pairs(self.edge) do
    -- use newst weight function
    props.weight = WayFinder:compute_weight(props.path)
    --
    -- save neighbour information
    if self.neighbour[props.start_node] then
      self.neighbour[props.start_node][props.end_node] = id
    end
  end
  --
  -- load usable portals
  self.portals = pload_json(portal_file) or self.portals
  --
  -- load individual aliases
  self.aliaseddir = mload_tlines(alias_file) or self.aliaseddir
  iprint(f("Es wurden {len(PathData.node)} Knoten und {len(PathData.edge)} Kanten geladen."), "WS")
end

registerAnonymousEventHandler("sysInstall", "PathData:load")
registerAnonymousEventHandler("force_reload_path_data", "PathData:load")

local function del_id(tab)
  tab.id = nil
  return true
end

function PathData:save()
  msave_jsonl(table.fold(self.node, "name"), node_file)
  table.apply(self.edge, del_id)
  msave_jsonl(self.edge, edge_file)
  msave_tlines(self.aliaseddir, alias_file)
  psave_json(PathData.portals, portal_file)
  iprint(f("Es wurden {len(PathData.node)} Knoten und {len(PathData.edge)} Kanten gespeichern."), "WS")
  -- all **other** profils have to reload the data
  raiseGlobalEvent("force_reload_path_data")
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>init_pathes</name>
			<packageName></packageName>
			<script>function init_pathes()
  if PathData.loaded then
    return
  end
  PathData:load()
  PathData.loaded = true
end </script>
			<eventHandlerList>
				<string>sysInstallModule</string>
				<string>sysLuaInstallModule</string>
				<string>sysLoadEvent</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>WS Core</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--                                             --
--      Basic structure of the pathfinder      --
--                    ~ by ~                   --
--                   Mundron                   --
--                                             --
-------------------------------------------------
--
-- class to create pathes and nodes
PathCreator = PathCreator or {}
-- class to edit existing pathes and nodes
PathEditor = PathEditor or {}
-- class to run from node to node
PathFinder = PathFinder or {
  catch_gagged_line = {},
  post_run_action = {},
}
-- class for all data 
PathData = PathData or {}

PathData.prepared_path={}
PathData.path_end_action = "stolpert beim Abbremsen."
PathData.do_path_end_action = f"\\:{PathData.path_end_action}"
if PLAYER then
  PathData.catch_path_end_action = f"{PLAYER.playername()} {PathData.path_end_action}"
else
  local name = getProfileName():gsub("MG_", "")
  PathData.catch_path_end_action = f"{name} {PathData.path_end_action}"
end
--
PathData.shortendir = PathData.shortendir or {
    norden = "n",
    nordosten = "no",
    osten = "o",
    suedosten = "so",
    sueden = "s",
    suedwesten = "sw",
    westen = "w",
    nordwesten = "nw",
  }
--
PathData.oppositedirection = PathData.oppositedirection or {
    norden = "sueden",
    n = "s",
    nordunten = "nordoben",
    nordoben = "nordunten",
    nordosten = "suedwesten",
    no = "sw",
    nordostoben = "suedwestunten",
    nordostunten = "suedwestoben",
    osten = "westen",
    o = "w",
    ostunten = "westoben",
    ostoben = "westunten",
    suedosten = "nordwesten",
    so = "nw",
    suedostoben = "nordwestunten",
    suedostunten = "nordwestoben",
    sueden = "norden",
    s = "n",
    suedunten = "nordoben",
    suedoben = "nordunten",
    suedwesten = "nordosten",
    sw = "no",
    suedwestunten = "nordostoben",
    suedwestoben = "nordostunten",
    westen = "osten",
    w = "o",
    westunten = "ostoben",
    westoben = "ostunten",
    nordwesten = "suedosten",
    nw = "so",
    nordwestoben = "suedostunten",
    nordwestunten = "suedostoben",
    oben = "unten",
    ob = "unten",
    unten = "oben",
    u = "oben",
  }
--
PathData.aliaseddir = PathData.aliaseddir or {
    "n",
    "norden",
    "nordunten",
    "nordoben",
    "no",
    "nordosten",
    "nordostunten",
    "nordostoben",
    "o",
    "osten",
    "ostunten",
    "ostoben",
    "so",
    "suedosten",
    "suedostunten",
    "suedostoben",
    "s",
    "sueden",
    "suedunten",
    "suedoben",
    "sw",
    "suedwesten",
    "suedwestunten",
    "suedwestoben",
    "w",
    "westen",
    "westunten",
    "westoben",
    "nw",
    "nordwesten",
    "nordwestunten",
    "nordwestoben",
    "ob",
    "oben",
    "u",
    "unten",
    "raus",
  }
--
PathData.dirtokey = {8, 9, 6, 3, 2, 1, 4, 7}
--
PathData.portals = PathData.portals or {
    p0 = false,
    p1 = false,
    p2 = false,
    p3 = false,
    p4 = false,
    p5 = false,
    p6 = false,
    p7 = false,
    p8 = false,
    p9 = false,
    p10 = false,
    p11 = false,
    p12 = false,
    p13 = false,
    p14 = false,
    p15 = false,
    p16 = false,
    p17 = false,
    p18 = false,
    p19 = false,
    p20 = false,
    p21 = false,
    p22 = false,
    p23 = false,
    p24 = false,
    p25 = false,
    p26 = false,
    p27 = false,
    p28 = false,
    p29 = false,
    p30 = false,
    p31 = false,
    p32 = false,
    p33 = false,
    p34 = false,
    p36 = false,
    p37 = false,
    p38 = false,
    p39 = false,
    p40 = false,
  }
--
PathData.help_lines = PathData.help_lines or {
    {"Zu einem Knoten laufen oder Weg vorbereiten:\n", "l"},
    {"#go", "y"}, {"&lt;Knotenname&gt;\n", "g"},
    {"#run", "y"}, {"&lt;Startknoten&gt;?", "o"}, {"&lt;Endknoten&gt;\n", "g"},
    {"#rerun\n", "y"},
    {"#prepare", "y"}, {"&lt;Startknoten&gt; &lt;Endknoten&gt;\n", "g"},
    {"#reprepare", "y"}, {"&lt;Startknoten&gt;? &lt;Endknoten&gt;?\n", "o"},
    {"#computepath", "y"}, {"&lt;Startknoten&gt; &lt;Endknoten&gt;\n\n", "g"},
    {"#nogag", "y"}, 
    {"Neue Wege oder Knoten erstellen:\n", "l"},
    {"#wa start|ziel|stop|weiter\n", "y"},
    {"#addnode", "y"}, {"&lt;Knotenname&gt;", "g"}, {":&lt;Titel&gt;?\n", "o"},
    {"#addbounaries", "y"}, {"&lt;Startknoten&gt; &lt;Endknoten&gt;\n", "g"},
    {"#wait", "y"}, {"&lt;Zeit in Sekunden&gt;\n", "g"},
    {"#blocker", "y"}, {"&lt;NPC Name&gt;:&lt;1. Zeile Knuddel&gt;:&lt;1. Zeile Tod&gt;\n", "g"},
    {"#trigger", "y"}, {"&lt;Triggername&gt;", "g"}, {":&lt;Ausloeser&gt;?\n", "l"},
    {"#vor", "y"}, {"&lt;beliebiges Kommando&gt;\n", "g"},
    {"#showrecord", "y"}, {"&lt;Anzahl letzten Schritte&gt;?\n", "o"},
    {"#deleterecord", "y"}, {"&lt;Anzahl letzten Schritte&gt;?\n", "o"},
    {"#sweg", "y"}, {"&lt;Startknoten&gt; &lt;Endknoten&gt;\n", "g"},
    {"#seinbahn", "y"}, {"&lt;Startknoten&gt; &lt;Endknoten&gt;\n\n", "g"},
    {"Knoten und Wege anzeigen und aendern:\n", "l"},
    {"#shownode", "y"}, {"&lt;Knotenname&gt;?\n", "o"},
    {"#searchnode", "y"}, {"&lt;Suchtext&gt;\n", "g"},
    {"#addtitle", "y"}, {"&lt;Knotenname&gt;:&lt;Titel&gt;\n", "g"},
    {"#addid", "y"}, {"&lt;Knotenname&gt;\n", "g"},
    {"#deleteid", "y"}, {"&lt;Knotenname&gt;", "g"}, {"&lt;ID-Nummer&gt;?\n", "l"},
    {"#showpath", "y"}, {"&lt;Pfad-ID&gt;\n", "g"},
    {"#deletepath", "y"}, {"&lt;Pfad-ID&gt;\n\n", "g"},
    {"#addpathcondition", "y"}, {"&lt;Pfad-ID&gt; &lt;Bedingung&gt;=&lt;Wert&gt;\n\n", "g"},
    {"#deletepathcondition", "y"}, {"&lt;Pfad-ID&gt; &lt;Bedingung&gt;\n\n", "g"},
    {"Einstellungen fuer Wegaufzeichnung oder Wegnutzung:\n", "l"},
    {"#showaliases\n", "y"},
    {"#addalias", "y"}, {"&lt;Neuer Alias&gt;\n", "g"},
    {"#deletealias", "y"}, {"&lt;Alias-ID&gt;\n", "g"},
    {"#showportals\n", "y"},
    {"#flipportal", "y"}, {"&lt;Portalnumber&gt;\n", "g"},
    {"#catchportals\n\n", "y"},
  }
  
</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>PathFinder</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>pathfinder - algorithmn</name>
				<packageName></packageName>
				<script>local function get_next_node(graph)
  local best_node = nil
  local minimal_distance = math.huge
  for name, props in pairs(graph) do
    if not props.visited and props.distance and props.distance &lt; minimal_distance then
      minimal_distance = props.distance
      best_node = name
    end
  end
  return best_node, minimal_distance
end

local function path_is_usable(edge)
  local allowed = edge.allowed_world
  if allowed then
    if type(allowed) == "table" then
      return table.contains(allowed, PLAYER.world())
    else
      return allowed == PLAYER.world()
    end
  end
  local forbidden = edge.forbidden_world
  if forbidden then
    if type(forbidden) == "table" then
      return not table.contains(forbidden, PLAYER.world())
    else
      return forbidden ~= PLAYER.world()
    end
  end
  -- check if a portal shall be used and is usable by this player:
  local start_node = edge.start_node
  if start_node and start_node:match("^p%d+$") then
    return table.get(PathData.portals, edge.end_node, true)
  end
  return true
end

local function path_healthcheck(edge, graph, budget)
  for _,points in pairs({"lp", "kp"}) do
    local required_points = edge[points]
    if required_points then
      if graph then
        required_points = required_points + graph[edge.start_node].condition[points]
      end
      if budget[points] &lt; required_points then
        return false
      end
    end
  end
  return true
end

local function choose_path(edge, path_id, graph)
  local start_node = graph[edge.start_node]
  local end_node = graph[edge.end_node]
  end_node.distance = start_node.distance + edge.weight
  end_node.previous_node = edge.start_node
  end_node.path_id = path_id
  -- take conditions from start node
  local end_condition = table.deepcopy(start_node.condition)
  -- and add conditions from edge
  if edge.allowed_world then
    table.add(end_condition.allowed_world, edge.allowed_world)
  end
  if edge.forbidden_world then
    table.add(end_condition.forbidden_world, edge.forbidden_world)
  end
  end_condition.lp = end_condition.lp + (edge.lp or 0)
  end_condition.kp = end_condition.kp + (edge.kp or 0)
  end_node.condition = end_condition
end

function PathFinder:confirm_usability(conditions, budget)
  return path_is_usable(conditions) and path_healthcheck(conditions, nil, budget)
end

function PathFinder:get_connection(start_node, end_node, soft)
  -- compute shortest path from start_node to end_node
  -- according the Dijkstra algorithm
  graph = {}
  for name in pairs(PathData.node) do
    -- math.huge is infty
    graph[name] = {
      distance = name == start_node and 0 or math.huge, 
      condition = {lp=0, kp=0, allowed_world={}, forbidden_world={}}, 
      visited = false
    }
  end
  local health = PLAYER.vital or {lp=math.huge, kp=math.huge}
  local at_node, distance_to_start = get_next_node(graph)
  while at_node do
    -- check neighbours of closest node
    local neighbours = PathData.neighbour[at_node]
    for neighbour_node, path_id in pairs(neighbours or {}) do
      local edge = PathData.edge[path_id]
      if not edge then
        display(at_node, neighbour_node, path_id)
      end 
      if (
        (soft or (path_is_usable(edge) and path_healthcheck(edge, graph, health)))
        and distance_to_start + edge.weight &lt; graph[neighbour_node].distance
      ) then
        choose_path(edge, path_id, graph)
      end 
    end
    --
    graph[at_node].visited = true
    if at_node == end_node then
      break
    end
    -- if we didn't reached the goal, go into next round
    at_node, distance_to_start = get_next_node(graph)
  end
  -- Are we successfull?
  if graph[end_node].distance &lt; math.huge then
    -- collect path ids from end_node to start_node
    local node = end_node
    local path_ids = {}
    local node_names = {start_node}
    while node ~= start_node do
      table.insert(path_ids, 1, graph[node].path_id)
      table.insert(node_names, 2, node)
      node = graph[node].previous_node
    end
    -- expand path steps
    path = {}
    for _, path_id in ipairs(path_ids) do
      for _, step in ipairs(PathData.edge[path_id].path) do
        table.insert(path, step)
      end
      table.insert(path, {type="#node", name=PathData.edge[path_id].end_node})
    end
    path[len(path)] = nil
    --
    return path, node_names, path_ids, graph[end_node].condition
  else
    eprint(
      {"Es gibt keine Verbindung zwischen '", {start_node, "y"}, "' und '", {end_node, "y"}, "'."},
      "WS"
    )
  end
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>pathfinder - build path</name>
				<packageName></packageName>
				<script>local function handle_lines_to_gag()
  if PathFinder.catch_gagged_line then
    local line = getCurrentLine()
    for _,config in pairs(PathFinder.catch_gagged_line) do
      if config.type == "startswith" and string.startswith(line, config.pattern) then
        config.action(line)
      end
    end
  end
  deleteLine()
end

function PathFinder:start_gag_trigger()
  self:kill_gag_trigger()
  if not self.nevergag then
    send("ultrakurz", false)
    self.all_gag_trigger_id = tempLineTrigger(1, 10000, handle_lines_to_gag)
    tempTrigger("Du bist nun im \"Ultrakurz\"modus.", deleteLine, 1)
  end
  self.walk_in_progress = true
end

local function handle_post_run_actions()
  if PathFinder.post_run_action then
    for _, action in pairs(PathFinder.post_run_action) do
      action()
    end
  end
  PathFinder.post_run_action = {}
  PathFinder.catch_gagged_line = {}
end

function PathFinder:kill_gag_trigger()
  if self.walk_in_progress and not self.keep_silence then
    if self.all_gag_trigger_id then
      send("lang", false)
      killTrigger(self.all_gag_trigger_id)
      self.all_gag_trigger_id = nil
      send("schau", false)
      tempTimer(1, handle_post_run_actions)
    end
  end
  self.walk_in_progress = false
end

local function get_next_node(graph)
  local best_node = nil
  local minimal_distance = math.huge
  for name, props in pairs(graph) do
    if not props.visited and props.distance and props.distance &lt; minimal_distance then
      minimal_distance = props.distance
      best_node = name
    end
  end
  return best_node, minimal_distance
end

function PathFinder:clean_trigger_and_timer()
  table.apply(self.blocker_trigger_ids or {}, killTrigger)
  self.blocker_trigger_ids = {}
  table.apply(self.timer_ids or {}, killTimer)
  self.timer_ids = {}
  table.apply(self.enabled_trigger or {}, disableTrigger)
  self.enabled_trigger = {}
  table.apply(self.trigger_actions or {}, killTrigger)
  self.trigger_actions = {}
end

function PathFinder:continue_func()
  if table.size(PathFinder.last_path) &lt; PathFinder.next_walk_index then
    PathFinder:kill_gag_trigger()
  else
    PathFinder:walk_stored_path()
  end
end

function PathFinder:remove_blocker_trigger(list_of_trigger)
  for _, trig in pairs(list_of_trigger) do
    local key_name = f("{trig}_trigger")
    if PathFinder.blocker_trigger_ids[key_name] then
      killTrigger(PathFinder.blocker_trigger_ids[key_name])
      PathFinder.blocker_trigger_ids[key_name] = nil
    end
  end
end

function PathFinder:cuddle_blocker_func()
  send(f("knuddel {PathFinder.blocker_npc_name}"))
end

function PathFinder:kill_blocker_func()
  PathFinder:remove_blocker_trigger({"miss"})
  send(f("toete {PathFinder.blocker_npc_name}"))
end

function PathFinder:miss_blocker_func()
  PathFinder:remove_blocker_trigger({"kill", "die"})
  tempLineTrigger(1, 1, function()
    if not PathFinder:create_blocker_trigger() then
      PathFinder:continue_func()
    end
  end)
end

function PathFinder:die_blocker_func()
  -- just to be sure:
  PathFinder:remove_blocker_trigger({"miss", "kill"})
  -- create new blocker trigger set only 
  -- blocker set is not "any" which means
  -- all the blocker have to fall.
  tempLineTrigger(1,1,function()
    if PathFinder.blocker_stack.any or not PathFinder:create_blocker_trigger() then
      PathFinder:continue_func()
    end
  end)
end

function PathFinder:create_blocker_trigger(from_walk)
  -- return if a new trigger set is created
  local stack = PathFinder.blocker_stack
  local index = stack.index
  if index &gt; len(stack.names) then
    -- we reached the end
    return false
  end
  -- initiate cuddle
  PathFinder.blocker_npc_name = stack.names[index]
  if from_walk then
    local cuddle_id = tempTrigger(
      PathData.catch_path_end_action, 
      function() PathFinder:cuddle_blocker_func() end, 
      1
    )
    table.insert(PathFinder.trigger_actions, cuddle_id)
  else
    send(f("knuddel {PathFinder.blocker_npc_name}"))
  end
  -- react to missing npc
  local miss_id = tempRegexTrigger(
    "^(Knuddle wen?)|(Du kannst soviel ich weiss ausser Lebewesen nur Teddys knuddeln.)$", 
    function() PathFinder:miss_blocker_func() end,
    1
  )
  PathFinder.blocker_trigger_ids["miss_trigger"] = miss_id
  -- react to blocking npc
  local kill_id = tempRegexTrigger(
    stack.cuddle_subtext[index], 
    function() PathFinder:kill_blocker_func() end, 
    1
  )
  PathFinder.blocker_trigger_ids["kill_trigger"] = kill_id
  -- react to death. It is highly unlikely,
  -- but you can run into the blocker which 
  -- dies between cuddle and kill
  local die_id = tempRegexTrigger(
    stack.death_subtext[index], 
    function() PathFinder:die_blocker_func() end, 
    1
  )
  PathFinder.blocker_trigger_ids["die_trigger"] = die_id
  stack.index = index + 1
  return true
end

local function apply_trigger_actions()
  for _,action in ipairs(PathFinder.trigger_actions) do
    send(action, false)
  end
end

function PathFinder:walk_stored_path(verbose)
  -- prepare walk
  self.walk_in_progress = true
  if not verbose then
    PathFinder:clean_trigger_and_timer()
    PathFinder:start_gag_trigger()
    verbose = false
  end
  --
  -- get stored data
  local path = self.last_path
  if not path then
    wprint("Kein Weg gespeichert", "WS")
  end
  local start_index = self.next_walk_index
  local end_index = len(path)
  if start_index &gt; end_index then
    wprint("Der letzte Weg ist bereits zu Ende gelaufen.", "WS")
    self.last_path = nil
  end
  local step
  --
  -- do steps for walk the path
  for i = start_index, end_index, 1 do
    step = path[i]
    self.next_walk_index = i + 1
    if step.type == "#dopath" then
      for _,substep in ipairs(step.substeps) do
        send(substep, verbose)
      end
    elseif step.type == "#wait" then
      --
      -- timer to continue afterwards
      table.insert(self.timer_ids, tempTimer(step.time, function() PathFinder:continue_func() end))
      iprint(f"Warte {step.time} Sekunden.", "WS")
      break
    elseif step.type == "#trigger" then
      --
      -- enable prepared trigger
      for _,trigger_name in pairs(step.names) do
        enableTrigger(trigger_name)
        table.insert(self.enabled_trigger, trigger_name)
      end
      if step.actions and table.size(step.actions) &gt; 0 then
        PathFinder.trigger_actions = table.deepcopy(step.actions)
        local trig_act_id = tempTrigger(PathData.catch_path_end_action, apply_trigger_actions, 1)
        table.insert(PathFinder.trigger_actions, trig_act_id) 
      end
      break
    elseif step.type == "#blocker" then
      --
      -- prepare trigger to kill or to continue
      PathFinder.blocker_stack = table.deepcopy(step)
      PathFinder.blocker_stack.index = 1
      PathFinder:create_blocker_trigger(true)
      break
    elseif step.type == "#node" then
      -- just a place holder for a more pretty print of pathes
      -- do nothing here
    end
  end
  if step.type == "#dopath" then
    -- in this case, we went through the loop without a break
    --iprint("cleaned up")
    self:clean_trigger_and_timer()
  end
  -- stop or finish walk
  if not verbose and not self.keep_silence then
    if step.type == "#wait" then
      tempTimer(step.time - 0.5, function() PathFinder:kill_gag_trigger() end)
    elseif PLAYER then
      tempTrigger(PathData.catch_path_end_action, function() PathFinder:kill_gag_trigger() end, 1)
      send(PathData.do_path_end_action, false)
    else
      tempTimer(0.5, function() PathFinder:kill_gag_trigger() end)
    end
  end
end

function PathFinder:prepare_path(start_node, end_node)
  -- sanitycheck for input
  if not start_node then
    eprint("Der Startknoten ist 'nil'.", "WS")
    return
  end
  if not PathData.node[start_node] then
    eprint({"Der Startknoten '", {start_node, "y"}, "' ist unbekannt."}, "WS")
    return
  end
  if not end_node then
    eprint("Der Endknoten ist 'nil'.", "WS")
    return
  end
  if not PathData.node[end_node] then
    eprint({"Der Endknoten '", {end_node, "y"}, "' ist unbekannt."}, "WS")
    return
  end
  if start_node == end_node then
    wprint({"Start- und Endknoten sind identisch '", {start_node, "y"}, "'."}, "WS")
    return
  end
  local path_name = f("{start_node}_{end_node}")
  -- check if we already save this path. If not, we compute the best path
  local path, node_names, path_ids, path_meta = unpack(PathData.prepared_path[path_name] or {})
  if not path or PathFinder:confirm_usability(path_meta, PLAYER.vital or {lp=math.huge, kp=math.huge}) then
    path, node_names, path_ids, path_meta = self:get_connection(start_node, end_node)
    if not path then
      -- if get_connection returns nil, there was already an error message
      return
    end
    PathData.prepared_path[path_name] = {path, node_names, path_ids, path_meta}
  end
  return path, node_names, path_ids, path_meta
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>pathfinder - handling</name>
				<packageName></packageName>
				<script>function PathFinder:prepare_path(start_node, end_node, soft)
  -- sanitycheck for input
  if not start_node then
    eprint("Der Startknoten ist 'nil'.", "WS")
    return
  end
  if not PathData.node[start_node] then
    eprint({"Der Startknoten '", {start_node, "ly"}, "' ist unbekannt."}, "WS")
    return
  end
  if not end_node then
    eprint("Der Endknoten ist 'nil'.", "WS")
    return
  end
  if not PathData.node[end_node] then
    eprint({"Der Endknoten '", {end_node, "ly"}, "' ist unbekannt."}, "WS")
    return
  end
  if start_node == end_node then
    wprint({"Start- und Endknoten sind identisch '", {start_node, "ly"}, "'."}, "WS")
    return
  end
  local path_name = f("{start_node}_{end_node}")
  -- check if we already save this path. If not, we compute the best path
  local path, node_names, path_ids, path_meta = unpack(PathData.prepared_path[path_name] or {})
  if soft then
    if path then
      return path, node_names, path_ids, path_meta
    else
      return self:get_connection(start_node, end_node, soft)
    end
  else
    if not path or not PathFinder:confirm_usability(path_meta, PLAYER.vital or {lp=math.huge, kp=math.huge}) then
      path, node_names, path_ids, path_meta = self:get_connection(start_node, end_node) 
    end
    -- if path is None, there is no direct path under normal conditions.
    if path then
      PathData.prepared_path[path_name] = {path, node_names, path_ids, path_meta}
    end
      
    return path, node_names, path_ids, path_meta
  end
end

function PathFinder:go(start_node, end_node, blindly, verbose, keep_silence)
  if blindly then
    if not self.last_targeted_node then
      eprint(
        {
          "Der Wegeskript wurde seit Profilstart noch nicht genutzt. ",
          "Blindes Laufen erfordert Start- und Endknoten. ",
          "Benutze dazu ",
          {"#go &lt;Startknoten&gt; &lt;Endknoten&gt;", "ly"},
          ".",
        },
        "WS"
      )
    else
      start_node = self.last_targeted_node
    end
  elseif not start_node then
    start_node = PathData.node_by_id[gmcp.MG.room.info.id]
    if not start_node then
      eprint("Der Raum ist kein definiter Knoten.", "WS")
      return
    end
  end
  local path, node_names, path_ids, condition = self:prepare_path(start_node, end_node)
  if not path then
    PathEditor:show_prepared_path(start_node, end_node, true)
    return
  end
  iprint(
    {
      "Laufe von ",
      {start_node, "ly"},
      " nach ",
      {end_node, "ly"},
      " ueber ",
      {table.concat(node_names, ' -&gt; '), "b"},
      ".\n",
      f("Die Weg-Ids sind {table.concat(path_ids, ', ')}."),
    },
    "WS"
  )
  self.last_path = path
  self.last_path_data = {start_node, end_node, path, node_names, path_ids, condition}
  self.last_path_name = f("{start_node}_{end_node}")
  self.next_walk_index = 1
  self.keep_silence = keep_silence
  self.last_targeted_node = end_node
  self.last_targeted_node_ids = PathData.node[end_node].ids
  self:walk_stored_path(verbose)
  return true
end

function PathFinder:show_last_runned_path()
  local start_node, end_node, path, node_names, path_ids, condition = unpack(PathFinder.last_path_data or {})
  
  if not path then
    eprint("Du bist noch keinen Weg gelaufen.", "WS")
    return
  end
  local description = {
      "Der Weg von",
      {start_node, "ly"},
      "nach",
      {end_node, "ly"},
      "geht entlang\n   ",
      {table.concat(node_names, ' -&gt; '), "b"},
      "\n\n",
      "Die Weg-Ids sind ",
      {table.concat(path_ids, ', '), "ly"},
      "\n\nDie einzelnen Schritte sind:\n"
    }
    table.append_table(description, PathEditor:display_path(path))
    table.append_table(description, PathEditor:display_condition(condition))
    iprint(description, "WS")
end

function PathFinder:syntax_help()
  iprint(PathData.help_lines, "WS")  
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>PathEditor</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>patheditor - node</name>
				<packageName></packageName>
				<script>function PathEditor:search_node(text)
  local lowered_text = text:lower()
  local result = {}
  for node_name, node_props in pairs(PathData.node) do
    if node_props.title and substring(node_props.title:lower(), lowered_text) then
      result[node_name] = node_props.title
    end
  end
  if table.size(result) &gt; 0 then
    local text={f("Es wurden folgende Knoten gefunden, die '{text}' im Titel beinhalten:\n")}
    for node_name,node_title in spairs(result) do
      table.insert(text, "Knotenname:")
      table.insert(text, {node_name, "y"})
      table.insert(text, f("mit dem Titel\n   '{node_title}'\n"))
    end
    iprint(text, "WS")
    return
  else
    eprint(f("Es wurde kein Knoten gefunden, welcher '{text}' im Titel beinhaltet."), "WS")
    return
  end
end

function PathEditor:show_node(node_name)
  if not node_name then
    local room_id = gmcp.MG.room.info.id
    if len(room_id) == 0 then
      eprint(
        {
          "Kein Knotennamen gegeben und der Raum hat keine Id",
          "um einen Knoten ausfindig zu machen.",
        },
        "WS"
      )
      return
    else
      node_name = PathData.node_by_id[room_id]
      if not node_name then
        eprint("Kein Knotenname gegeben und der Raum ist auch kein Knoten.", "WS")
        return
      end
    end
  end
  local node = PathData.node[node_name]
  if not node then
    eprint(f("Es gibt keinen Knoten mit dem Namen '{node_name}'."), "WS")
    return  
  end
  local neighbours = PathData.neighbour[node_name]
  local description = f("Der Knoten '{node_name}' hat")
  if node.title then
    description = f("{description} den Titel\n   '{node.title}'\n\n")
  else
    description = f("{description} keinen Titel.\n\n")
  end
  if len(node.ids) == 0 then
    description = f("{description}Es sind keine Raum-IDs gespeichert.\n\n")
  else
    description = f("{description}Folgende Raum-IDs sind gespeichert:\n")
    for pos, room_id in ipairs(node.ids) do
      description = f("{description}   {pos}: {room_id}\n")
    end
  end
  if not neighbours or len(neighbours) == 0 then
    description = f("{description}\nGaenzlich und gar, nicht mal ein Nachbar ist da!\n")
  else
    description = f("{description}\nFolgende Nachbarn sind von hier zu erreichen:\n")
    if node_name:match("^p%d+$") then
      -- node is a portal node
      description = f("{description}   Alle erreichbaren Portale, siehe #showportals\n")
      for neighbour_name, path_id in pairs(neighbours) do
        if not neighbour_name:match("^p%d+$") then
          description = f("{description}   {neighbour_name} (Pfad-ID {path_id})\n")
        end
      end
    else
      for neighbour_name, path_id in pairs(neighbours) do
        description = f("{description}   {neighbour_name} (Pfad-ID {path_id})\n")
      end
    end
    
  end
  iprint(description, "WS")
end

function PathEditor:delete_id_from_node(node_name, room_id)
  -- node_name is given, check if the name is valid
  local node_prop = PathData.node[node_name]
  if not node_prop then
    eprint(f("Es gibt keinen Knoten mit dem Namen '{node_name}'."), "WS")
    return
  end
  if room_id then
    -- if room_id is given, it has to be the position in the id-List.
    local old_room_id = PathData.node[node_name].ids[room_id]
    if table.remove_at(PathData.node[node_name].ids, room_id) then
      PathData.node_by_id[room_id] = nil
      iprint(f("Die Room-ID '{old_room_id}' wurde vom Knoten '{node_name}' entfernt."), "WS")
    end
  else
    -- if room_id is missing, use the ID of the current room
    room_id = gmcp.MG.room.info.id
    if len(room_id) == 0 then
      -- A room with an empty id might be a node, but the node
      -- will not have an empty id as id.
      eprint("Der aktuelle Raum hat keine Id, so dass nichts entfernt werden kann.", "WS")
      return
    end
    local real_node_name = PathData.node_by_id[room_id]
    if node_name ~= real_node_name then
      eprint(f("Dieser Raum entspricht dem Knoten '{real_node_node}' und nicht der Eingabe '{node_name}'."), "WS")
      return
    end
    if table.remove_value(PathData.node[node_name].ids, room_id) then
      PathData.node_by_id[room_id] = nil
      iprint(f("Die aktuelle Room-ID '{room_id}' wurde vom Knoten '{node_name}' entfernt."), "WS")
    end
  end
  if main_gui_update_room then
    main_gui_update_room()
  end
  PathData:save()
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>patheditor - path</name>
				<packageName></packageName>
				<script>local function split_dopath(substeps)
  local result = {}
  for _, step in ipairs(substeps) do
    if table.contains(PathData.aliaseddir, step) then
      local prev = result[len(result)]
      if prev and string.startswith(prev, "\n#dopath") and len(prev) &lt; 42 then
        result[len(result)] = f("{prev} {step}")
      else
        table.insert(result, f("\n#dopath {step}"))
      end
    else
      table.insert(result, f("\n{step}"))
    end
  end
  local real_result = {}
  for _,step in ipairs(result) do
    if string.startswith(step, "\n#dopath") then
      table.insert(real_result, {"\n#dopath", "ly"})
      table.insert(real_result, step:sub(10))
    else
      table.insert(real_result, step)
    end
  end
  return real_result
end

function PathEditor:show_path(path_id)
  local path_props = PathData.edge[path_id]
  if not path_props then
    eprint(f("Es gibt keinen Weg mit der ID {path_id}."), "WS")
    return
  end
  local description = {
      f("Der Weg mit der ID {path_id} geht\n"),
      "   von",
      {path_props.start_node, "ly"},
      "nach",
      {path_props.end_node, "ly"},
      "\n\nDie einzelnen Schritte sind:\n",
  }
  table.append_table(description, self:display_path(path_props.path))
  table.append_table(description, self:display_condition(path_props))
  iprint(description, "WS")
end

function PathEditor:show_prepared_path(start_node, end_node, soft)
  local path, node_names, path_ids, condition = PathFinder:prepare_path(start_node, end_node, soft)
  local description = {}
  if path and not soft then
    table.insert(description, "Der Weg von")
  else
    table.insert(description, "Versuche einen Weg mit Einschraenkungen zu finden.")
    path, node_names, path_ids, condition = PathFinder:prepare_path(start_node, end_node, true)
    if path then
      table.insert(description, "\n\nDer Weg mit nicht erfuellen Einschraenkungen von")
    else
      table.insert(description, "Keine Chance ...")
    end
  end
  if path then
    local weight = 0
    for _,path_id in pairs(path_ids) do
      weight = weight + PathData.edge[path_id].weight
    end
    local weight_line = f("\nGewicht: {weight}")
    table.append_table(
      description,
      {
        {start_node, "y"},
        "nach",
        {end_node, "y"},
        "geht entlang\n   ",
        {table.concat(node_names, ' -&gt; '), "lb"},
        "\n\n",
        "Die Weg-Ids sind ",
        {table.concat(path_ids, ', '), "y"},
        "\n\nDie einzelnen Schritte sind:\n",
      }
    )
    table.append_table(description, self:display_path(path))
    table.append_table(description, self:display_condition(condition))
    table.insert(description, weight_line)
  end
  iprint(description, "WS")
end

function PathEditor:display_path(path)
  local result = {}
  for i, step in ipairs(path) do
    if step.type == "#dopath" then
      table.append_table(result, split_dopath(step.substeps))
    elseif step.type == "#wait" then
      table.insert(result, {"\n#wait", "ly"})
      table.insert(result, f("{step.time} / warte {step.time} Sekunden"))
    elseif step.type == "#trigger" then
      table.insert(result, {"\n#trigger", "y"})
      table.insert(result, f(" / Namen: {table.concat(step.names, ', ')}"))
      if step.actions then
        table.insert(result, "\n   Ausloeser:\n")
        table.insert(result, table.indent_lines(step.actions, "      "))
      end
    elseif step.type == "#blocker" then
      table.insert(result, {"\n#blocker", "ly"})
      if table.size(step.names) == 1 then
        table.insert(result, f("/ Namen: {table.concat(step.names, ', ')}"))
      else
        table.insert(result, "/ Namen:")
        table.insert(result, table.indent_lines_with_breaks(step.names, "   "))
      end
      table.insert(result, "\n    Knuddelnachrichten:")
      table.insert(result, table.indent_lines_with_breaks(step.cuddle_subtext, " "))
      table.insert(result, "\n    Sterbemeldungen:")
      table.insert(result, table.indent_lines_with_breaks(step.death_subtext, " "))
    elseif step.type == "#node" then
      table.insert(result, {f("\n#node {step.name} / Knoten {step.name}"), "lb"})
    end
  end
  return result
end

function PathEditor:display_condition(condition)
  local description = {"\n\nFolgende Einschraenkungen gelten auf diesem Weg:\n"}
  local text
  if condition.allowed_world then
    local allowed
    if type(condition.allowed_world) == "table" then
      allowed = condition.allowed_world
    else
      allowed = {condition.allowed_world}
    end
    if table.size(allowed) &gt; 1 then
      text = {f("Erlaubte Welten: {table.concat(allowed, ',')}"), "r"}
    elseif table.size(allowed) == 1 then
      if PLAYER.world() == allowed[1] then
        text = {f("Erlaubte Welt: {allowed[1]}"), "g"}
      else
        text = {f("Erlaubte Welt: {allowed[1]}"), "r"}
      end
    end
    if text then
      table.insert(description, text)
    end
  end
  text = nil
  if condition.forbidden_world then
    local forbidden
    if type(condition.forbidden_world) == "table" then
      forbidden = condition.forbidden_world
    else
      forbidden = {condition.forbidden_world}
    end
    if table.size(condition.forbidden_world) &gt; 1 then
      if PLAYER and table.contains(forbidden, PLAYER.world()) then
        text = {f("Verbotene Welten: {table.concat(forbidden, ',')}"), "r"}
      else
        text = {f("Verbotene Welten: {table.concat(forbidden, ',')}"), "g"}          
      end
    elseif table.size(condition.forbidden_world) == 1 then
      if PLAYER.world() == forbidden[1] then
        text = {f("Verbotene Welt: {forbidden[1]}"), "r"}
      else
        text = {f("Verbotene Welt: {forbidden[1]}"), "g"}
      end
    end
    if text then
      table.insert(description, text)
    end
  end
  if condition.lp and condition.lp &gt; 0 then
    if PLAYER and PLAYER.lp &gt; condition.lp then
      text = {f("Mindest-LP: {condition.lp}"), "g"}
    else
      text = {f("Mindest-LP: {condition.lp}"), "r"}
    end
    table.insert(description, text)
  end
  if condition.kp and condition.kp &gt; 0 then
    if PLAYER and PLAYER.kp &gt; condition.kp then
      text = {f("Mindest-KP: {condition.kp}"), "g"}
    else
      text = {f("Mindest-KP: {condition.kp}"), "r"}
    end
    table.insert(description, text)
  end
  return description
end

function PathEditor:delete_path_condition(path_id, condition_name)
  local edge = PathData.edge[path_id]
  if edge then
    if edge[condition_name] then
      edge[condition_name] = nil
      edge.weight = WayFinder:compute_weight(edge.path, edge)
      iprint(
        f("Die Bedingung {condition_name} wurde im Pfad mit der ID {path_id} geloescht."), "WS"
      )
      PathData:save()
    else
      wprint(f("Der Pfad mit der ID {path_id} hat keine Bedingung {condition_name}."), "WS")
    end
  else
    eprint(f("Ein Pfad mit der ID {path_id} gibt es nicht."), "WS")
  end
end

function PathEditor:update_path_condition(path_id, condition_name, condition_value)
  local edge = PathData.edge[path_id]
  if edge then
    if edge[condition_name] then
      iprint(
        f(
          "Der Pfad mit der ID {path_id} hat die Bedingung {condition_name} mit dem Wert {condition_value} erhalten."
        ),
        "WS"
      )
    else
      iprint(
        f(
          "Beim Pfad mit der ID {path_id} wurde die Bedingung {condition_name} auf den Wert {condition_value} aktualisiert."
        ),
        "WS"
      )
    end
    edge[condition_name] = condition_value
    edge.weight = WayFinder:compute_weight(edge.path, edge)
    PathData:save()
  else
    eprint(f("Ein Pfad mit der ID {path_id} gibt es nicht."), "WS")
  end
end

function PathEditor:delete_path(path_id)
  local path_props = PathData.edge[path_id]
  if not path_props then
    eprint(f("Es gibt keinen Weg mit der ID {path_id}."), "WS")
    return
  end
  local confirmation = PathEditor.confirm_path_deletion
  if not confirmation or confirmation ~= path_id then
    local description = {
        f("Willst du wirklich den Weg mit der ID {path_id} \n"),
        "   von",
        {path_props.start_node, "y"},
        "nach",
        {path_props.end_node, "y"},
        "loeschen? Die Einzelschritte sind:\n"
    }
    table.append_table(description, self:display_path(path_props.path))
    table.append_table(description, self:display_condition(path_props))
    table.insert(description, "\n\nFalls ja, wiederhole den Loeschbefehl.")
    iprint(description, "WS")
    PathEditor.confirm_path_deletion = path_id
  else
    PathData.edge[path_id] = nil
    PathData.neighbour[path_props.start_node][path_props.end_node] = nil
    PathEditor.confirm_path_deletion = nil
    iprint("Der Weg wurde geloescht.", "WS")
    PathData:save()
  end
end

function PathEditor:reprepare_path(start_node, end_node)
  if not start_node or not end_node then
    local path_names = {}
    for path_name, _ in pairs(PathData.prepared_path) do
      table.insert(path_names, string.split(path_name, "_"))
    end
    PathData.prepared_path = {}
    for _, path_name in pairs(path_names) do
      PathFinder:prepare_path(unpack(path_name))
    end
    iprint("Alle vorbereiteten Wege wurden neu berechnet.", "WS")
  else
    PathData.prepared_path[f("{start_node}_{end_node}")] = nil
    PathFinder:prepare_path(start_node, end_node)
    iprint(f("Der Weg von '{start_node}' nach '{end_node}' wurde neu berechnet."), "WS")
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>patheditor - portals</name>
				<packageName></packageName>
				<script>function PathEditor:show_portals()
  local result = {
    "Die Nutzbarkeit der Portale sieht fuer dich wie folgt aus:\n\n",
  }
  -- it is ugly to display the portals this way, but far more useful
  -- and faster storing it as a mapping, which doesn't provide an order
  for i=0,40,1 do
    if i ~= 35 then
      if i &lt; 10 then
        table.insert(result, {f("    P{i}: "), "y"})
      else
        table.insert(result, {f("   P{i}: "), "y"})
      end
      if PathData.portals[f("p{i}")] then
        table.insert(result, {"   nutzbar   ", "g"})
      else
        table.insert(result, {"nicht nutzbar", "r"})
      end
      local title = PathData.node[f("p{i}")].title
      if title then
        table.insert(result, f("({title})\n"))
      else
        table.insert(result, "\n")
      end
    end
  end
  iprint(result, "WS")
end

function PathEditor:flip_portal(nr)
  local portal_name = f("p{nr}")
  if not table.contains(PathData.portals, portal_name) then
    eprint(f("Ein Portal P{nr} gibt es nicht."), "WS")
    return
  end
  PathData.portals[portal_name] = not PathData.portals[portal_name]
  if PathData.portals[portal_name] then
    iprint(f("Das Portal P{nr} ist nun nutzbar."), "WS")
  else
    iprint(f("Das Portal P{nr} ist nicht mehr nutzbar."), "WS")
  end
  PathData:save()
end

local function store_portal_lines()
  local current_line = getCurrentLine()
  if isPrompt() then
    killTrigger(PathEditor.portal_catch_trigger_id)
    PathEditor.portal_catch_trigger_id = nil
    echo("\n\nGefundene Portale:\n")
    for _,line in ipairs(PathEditor.catched_portal_lines) do
      for match in line:gmatch("%d+%. [^(%d%]%[]+") do
        local tab = string.split(match, "%.")
        local portal_nr = tab[1]
        local portal_title = string.strip(tab[2])
        echo(f("{portal_nr}: '{portal_title}'"))
        PathData.portals[f("p{portal_nr}")] = true
        -- PathData.node[f("p{portal_nr}")].title = portal_title
        echo(" (gespeichert)\n")
      end
    end  
    --
    --iprint("Teleportiere zu allen Portalen um die Raum-Ids zu speichern.", "WS")
    --PathEditor.portal_to_visit = 0
    --enableTimer("catch_portal_room_ids")
  else
    table.insert(PathEditor.catched_portal_lines, getCurrentLine())
  end
end

function PathEditor:catch_portals()  --
  --[[iprint("Fuege dummy Knoten p0 bis p40 hinzu und alle potentiellen Wege dazwischen.", "WS")
  local edge_id = table.size(PathData.edge)
  for s = 1,40,1 do
    local start_node = f("p{s}")
    if s ~= 35 then
      if not PathData.node[start_node] then
        PathData.node[start_node] = {ids={}}
        for e = 1,40,1 do
          if e ~= s and e ~= 35 then
            local end_node = f("p{e}")
            if not PathData.neighbour[start_node][end_node] then
              local edge = {
                start_node=start_node, 
                end_node=end_node, 
                path={f("teleportiere {e}")}
              }
              table.insert(PathData.edge, edge)
              edge_id = edge_id + 1
              PathData.neighbour[start_node][end_node] = edge_id 
            end
          end
        end
      end 
    end
  end]]--
  --
  iprint("Erfasse nutzbare Portale", "WS")
  --
  PathEditor.catched_portal_lines = {}
  local trigger_id = tempLineTrigger(-1, 30, store_portal_lines)
  PathEditor.portal_catch_trigger_id = trigger_id
  send("teleportiere")
  --
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>WS_init</name>
			<packageName></packageName>
			<script>WayFinder = WayFinder or MundronClassMethods:new{
  _name="WayFinder",
  _shortname = "WS",
  _module = "Wegeskript",
  _version="1.1.0",
  _fixed_version={MundronClassMethods="1.1.0"},
  files = {
    profile = {
      portals = {}
    },
    game = {
      nodes = {},
      edges = {},
      gags = {}
    }
  },
  data = {},
  enum = {condition={"hp", "sp", "allowed_woldd", "forbidden_world"},
  portal={"all", "enabled", "missing"}}
}

function WayFinder:init()
  local nord, sued = {"nord", "n"}, {"sued", "s"}
  local ost, west = {"ost", "o"}, {"west", "w"}
  local oben, unten = {"ob", "ob"}, {"unt", "u"}
  local empty = {"", ""}
  
  local aliases = {}
  
  local save_dirs = function(x, y, z)
    if x == empty and y == empty and z == empty then
      return
    end
    local long, short = f"{y[1]}{x[1]}{z[1]}en", f"{y[2]}{x[2]}{z[2]}"
    aliases[long] = long
    if z == empty or (x == empty and y == empty) then
      aliases[long] = short
      aliases[short] = short
    end
  end
  
  for _, x in pairs({ost, empty, west}) do
    for _, y in pairs({nord, empty, sued}) do
      for _, z in pairs({oben, empty, unten}) do 
        save_dirs(x, y, z)
      end
    end
  end
  aliases["raus"] = "raus"
  
  self:assert(len(aliases) == 37, f"Wrong amount of aliases. Created {len(aliases)}/37")
  self.data.aliases = aliases
end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>WS_migration</name>
			<packageName></packageName>
			<script>function WayFinder:migrate_profile(saved_version)
  if self.version_lt(saved_version, "1.0.0") then
    self.psave(self.pload("WS_nutzbare_Portale", {}), self:filename("portals"))
    --self.pmove("WS_nutzbare_Portale", self:filename("portals"))
    saved_version = "1.0.0"
  end
  if self.version_lt(saved_version, "1.1.0") then
    saved_version = "1.1.0"  
  end
  return saved_version
end

function WayFinder:migrate_game(saved_version)
  if self.version_lt(saved_version, "1.0.0") then
    mremove_tlines("WS_Aliases")
    mremove_tlines("WS_Gags")
    local nodes = mload_jsonl("WS_Knoten")
    self.msave(nodes, self:filename("nodes"))
    --mremove_jsonl("WS_Knoten")
    local edges = mload_jsonl("WS_Kanten")
    self.msave(edges, self:filename("edges"))
    --mremove_jsonl("WS_Kanten")
    saved_version = "1.0.0"
  end
  if self.version_lt(saved_version, "1.1.0") then
    local edges = self.mload(self:filename("edges"))
    for _, edge in pairs(edges) do
      edge.condition = {
        hp = edge.lp,
        sp = edge.kp,
        allowed_world = edge.allowed_world,
        forbidden_world = edge.forbidden_world
      }
      edge.lp, edge.kp, edge.allowed_world, edge.forbidden_world = nil, nil, nil, nil
    end
    self.msave(edges, self:filename("edges"))
    saved_version = "1.1.0"
  end  
  return saved_version
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>WS_post_load_data</name>
			<packageName></packageName>
			<script>function WayFinder:post_load_data()
  local nbi, nbn, neigh = {}, {}, {}
  
  for nid, node in pairs(self.data.nodes) do
    node.nid = nid
    for _, rid in pairs(node.ids) do
      nbi[rid] = node
    end
    nbn[node.name] = node
  end
  
  for eid, edge in pairs(self.data.edges) do
    -- use newst weight function
    edge.weight = WayFinder:compute_weight(edge.path)
    -- save neighbour information
    table.set(neigh, {edge.start_node, edge.end_node}, eid)
  end

  table.set(self, "data.node_by_id", nbi)
  table.set(self, "data.node_by_name", nbn)
  table.set(self, "data.neighbour", neigh)

  self:info(f"Es wurden {len(self.data.nodes)} Knoten mit {len(nbi)} Raum-IDs und {len(self.data.edges)} Kanten geladen.")
end</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>WS_graph_handling</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>WS_nodes_edit</name>
				<packageName></packageName>
				<script>function WayFinder:get_node(name)
  local node
  if name then
    node = self.data.node_by_name[name]  
  else
    node = self.data.node_by_id[gmcp.MG.room.info.id]
  end
  if node then
    node = table.deepcopy(node)
    node.type = "#node"
  end
  return node
end

function WayFinder:save_node(name, title)
  local node = table.get(self, {"data", "node_by_name", name}, {})
  local room_id = gmcp.MG.room.info.id
  if len(node) &gt; 0 then
    if room_id and not table.contains(node.ids, room_id) then
      table.insert(node.ids, room_id)
      self.data.node_by_id[room_id] = node
    end
    node.title = title or node.title
    self:info(f"Update den existierenden Knoten mit dem Namen '{name}'")
  else
    table.update(node, {name=name, title=title, ids={}})
    self.data.node_by_name[name] = node
    if room_id then
      table.add(node.ids, room_id)
      self.data.node_by_id[room_id] = node
      self:info(f"Knoten '{name}' mit Titel '{title or ''}' und aktueller Raum-ID gespeichert.")
    else
      self:warn(f"Knoten '{name}' mit Titel '{title or ''}' OHNE Raum-ID gespeichert!")
    end
  end
  if self.data.recording then
    node = table.deepcopy(node)
    node.type = "#node"
    table.insert(self.data.recording.path, node) 
  end
  MainGUI:update_label("node", PLAYER.node_factor())
  --self:save_game()
end

function WayFinder:remove_node_id(name, position)
  local node = table.get(self, {"data", "node_by_name", name})
  if not node then
    self:warn(f"Es gibt keinen Knoten mit dem Namen {name}")
    return
  end
  if len(node.ids) == 0 then
    self:warn(f"Der Knoten {name} hat keine Raum-IDs hinterlegt.")
    return
  end
  if position &lt; 1 or position &gt; len(node.ids) then
    self:warn(f"Der Knoten hat nur Raum-IDs mit Position zwischen 1 und {len(node.ids)}")
    return
  end
  local rid = table.remove(node.ids, position)
  self:info(f"Die Raum-ID {rid} wurde aus der Liste der Raum-IDs des Knoten {name} entfernt")
  self:save_game()
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>WS_node_find</name>
				<packageName></packageName>
				<script>local function display_node(node)
  local tab = {
    {{"Name", "y"}, node.name},
    {{"Titel", "y"}, node.title or '&lt;Kein Titel vorhanden&gt;'},
  }
  if len(node.ids) == 0 then
    table.insert(tab, {{"IDs", "y"}, "&lt;Keine Raum-IDs vorhanden&gt;"})
  else
    for i, rid in ipairs(node.ids) do
      table.insert(tab, {i==1 and {"IDs", "y"} or "", f"{i}) {rid}"})
    end
  end
  print_table(tab)
  local ntab = {}
  local i = 1
  for neighbour, edge in pairs(table.get(WayFinder.data, {"neighbour", node.name}) or {}) do
    table.insert(ntab, {i==1 and {"Nachbarknoten", "y"} or "", {neighbour, "o"}, f"(Pfad-ID {edge})"})
    i = i + 1
  end
  print_table(ntab)
end

function WayFinder:find_nodes(pattern)
  if not pattern then
    local current = self.data.node_by_id[gmcp.MG.room.info.id]
    if not current then
      self:warn("Du stehst an keinem Knoten")
      return {current}
    end
    self:info("Du befindest dich an folgendem Knoten:")
    display_node(current)
    return {current}
  end
  
  local exact = self.data.node_by_name[pattern] 
  if exact then
    self:info("Eindeutigen Knoten gefunden")
    display_node(exact)
    return {exact}
  end
  local nodes = {}
  for name, node in pairs(self.data.node_by_name) do
    if name:find(pattern) then
      table.insert(nodes, node)
    end
  end
  if len(nodes) == 0 then
    self:warn(f"Keine Knoten gefunden, die dem Muster '{pattern}' entsprechen")
    return {}
  end
  self:info(f"Folgende {len(nodes)} Knoten gefunden, die dem Muster '{pattern}' entsprichen.")
  for _, node in pairs(nodes) do
    display_node(node)
    print(string.rep("-", 50))
  end
  return nodes
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>WS_node_portal</name>
				<packageName></packageName>
				<script>function WayFinder:show_portals(key)
  if not table.contains(WayFinder.enum.portal, key) then
    self:warn(f"Unzulaessiger Schluessel '{key}'")
    return
  end 
  local tab = {}
  local portals = WayFinder.data.portals
  for i = 1,40,1 do
    local name = f"p{i}"
    if i ~= 35 then
      if (
        key == "all" or 
        (key == "enabled" and portals[name]) or 
        (key == "missing" and not portals[name])) 
      then
        local node = WayFinder.data.node_by_name[name]
        table.insert(tab, {node.name, node.title})
      end
    end
  end
  if len(tab) == 0 then
    self:info("Keine Portale gefunden")
  else
    self:info("Folgende Portale wurden gefunden:")
    print_table(tab)  
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>WS_edges_edit</name>
				<packageName></packageName>
				<script>function WayFinder:compute_weight(commands, conditions)
  -- compute the weight of a path.
  -- Each single word command has a weight of 1
  -- For later:
  -- #trigger, #blocker, #wait will get a higher weight.
  local result = 0
  for _, cmd in pairs(commands) do
    if cmd.type == "#dopath" then
      result = result + len(cmd.substeps)
    elseif cmd.type == "#wait" then
      result = result + cmd.time
    elseif cmd.type == "#blocker" then
      result = result + 3 * len(cmd.names)
    elseif cmd.type == "#trigger" then
      result = result + 2 * len(cmd.names)
    end
  end
  if conditions then
    result = result + (conditions.lp or 0)
    result = result + (conditions.kp or 0)
  end
  return result
end

function WayFinder:create_base_condition(field, value)
  if not table.contains(self.enum.condition, field) then
    self:warn(f"Das Feld '{field}' ist nicht als Bedingung zulaessig.")
    return
  end
  local rvalue = tonumber(value)
  if not rvalue then
    self:warn(f"Der Wert '{value}' muss eine Zahl sein.")
    return
  end
  local condition = {}
  if field == "hp" or field == "sp" then
    condition[field] = rvalue
  else
    condition[field] = {rvalue}
  end
  return condition
end

function WayFinder:edit_condition(eid, field, value)
  local edge = self.data.edges[eid]
  if not edge then
    self:warn(f"Es gibt keinen Pfad mit der ID '{eid}'")
    return
  end
  local condition = self:create_base_condition(field, value)
  if not condition then
    return
  end
  edge.condition = condition
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>WS_edge_show</name>
				<packageName></packageName>
				<script>local function add_node(tab, node)
  table.insert(tab, {{"Name", "y"}, node.name})
  for i, rid in ipairs(node.ids) do
    table.insert(tab, {
      i == 1 and {"Raum-IDs", "y"} or "",
      f"{i}) '{rid}'"
    })
  end
end

local function add_dopath(tab, dopath)
  local temp, current = {}, ""
  for _, substep in pairs(dopath.substeps) do
    if WayFinder.data.aliases[substep] then
      if len(current) == 0 then
        current = substep
      else
        current = f"{current},{substep}"
      end
      if len(current) &gt; 50 then
        table.insert(temp, current)
        current = ""
      end
    else
      if len(current) &gt; 0 then
        table.insert(temp, current)
        current = ""
      end
      table.insert(temp, substep)
    end
  end
  local max_len = len(dopath.substeps)
  for i, substep in ipairs(dopath.substeps) do
    table.insert(tab, {i == 1 and {"Bewegung/Aktion", "y"} or "", 
    f"{i}) [{max_len - i + 1}] {substep}"})
  end
end

local function add_wait(tab, wait)
  table.insert(tab, {{"Wartezeit", "y"}, tostring(wait.time)})
end

local function add_trigger(tab, trigger)
  for i, name in ipairs(trigger.names) do
    table.insert(tab, {
      i == 1 and {"Triggernamen", "y"} or "",
      f"{i}) '{name}'"
    })
  end
  for i, action in ipairs(trigger.actions) do
    table.insert(tab, {
      i == 1 and {"Ausloeseaktionen", "y"} or "",
      f"{i}) '{action}'"
    })
  end
end

local function add_blocker(tab, blocker)
  for i, name in ipairs(blocker.names) do
    table.insert(tab, {
      i == 1 and {"Blockernamen", "y"} or "",
      f"{i}) '{name}'"
    })
  end
  for i, text in ipairs(blocker.cuddle_subtext) do
    table.insert(tab, {
      i == 1 and {"Knuddel-Reaktionen", "y"} or "",
      f"{i}) '{text}'"
    })
  end
  for i, text in ipairs(blocker.death_subtext) do
    table.insert(tab, {
      i == 1 and {"Todesmeldungen", "y"} or "",
      f"{i}) '{text}'"
    })
  end
end

local function print_condition(condition)
  if condition.hp then
    print(f"Mindest-HP: {condition.hp}")
  end
  if condition.sp then
    print(f"Mindest-SP: {condition.sp}")
  end
  if condition.allowed_world then
    local worlds = table.concat(condition.allowed_world, ", ")
    print(f"Erlaubte Welten: {worlds}")
  end
  if condition.forbidden_world then
    local worlds = table.concat(condition.forbidden_world, ", ")
    print(f"Verbotene Welten: {worlds}")
  end
end

function WayFinder:show_edge(eid)
  local edge = self.data.edges[eid]
  if not edge then
    self:warn(f"Keine Kante mit der Nummer '{eid}' gefunden.")
    return
  end
  self:display_edge(edge)
end

function WayFinder:display_edge(edge)
  if edge.start_node then
    print(string.rep("-", 50))
    print(f"Start-Knoten: {edge.start_node}")
  end
  for _, step in pairs(path) do
    print(string.rep("-", 50))
    local tab = {}
    table.insert(tab, {{"Type", "y"}, step.type})
    if step.type == "#node" then
      add_node(tab, step)    
    elseif step.type == "#dopath" then
      add_dopath(tab, step)
    elseif step.type == "#wait" then
      add_wait(tab, step)
    elseif step.type == "#trigger" then
      add_trigger(tab, step)
    elseif step.type == "#blocker" then
      add_blocker(tab, step)
    else
      table.insert(tab, {"MISSING", "SHOW_RECORDING"})
    end
    print_table(tab)
  end
  print(string.rep("-", 50))
  if edge.end_node then
    print(f"Start-Knoten: {edge.end_node}")
    print(string.rep("-", 50))
  end
  if edge.condition then
    print_condition(edge.condition)
    print(string.rep("-", 50))  
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>WS_deletes</name>
				<packageName></packageName>
				<script>function WayFinder:delete_edge(eid)
  if not self.data.edges[eid] then
    self:warn(f"Es wurde keine Kante mit der ID '{eid}' gefunden.")
    return  
  end
  local edge = table.remove(self.data.edges, eid)
  self:info(f"Die Kante mit der ID '{eid}' wurde geloescht.")
  self:save_game()
  self:post_load_data()
end

function WayFinder:delete_node(name)
  local nodes = self:find_nodes(name)
  if len(nodes) &gt; 1 then
    self:warn("Das Loeschen von Knoten geht nur bei eindeutigen Treffern.")
    return
  end
  local node = table.remove(self.data.nodes, nodes[1].nid)
  local eids = table.values(self.data.neighbour[node.name])
  for _, end_nodes in pairs(self.data.neighbour or {}) do
    for end_node, eid in pairs(end_nodes) do
      if end_node == node.name then
        table.add(eids, eid)
      end
    end
  end
  if len(eids) &gt; 0 then
    local eid_line = table.concat(eids, ", ")
    self:info(f"Loesche hin und abfuehrende Pfade {eid_line}")
    
  end
  self:save_game()
  self:post_load_data()
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>WS_create_path</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>WS_REC_start</name>
				<packageName></packageName>
				<script>function WayFinder:start()
  local node = self:get_node()
  if not node then
    self:warn("Die Wegaufzeichnung muss an einem Knoten beginnen. Erstelle einen Knoten bevor du startest.")
    return
  end
  if self.data.recording then
    self:warn("Die Wegaufzeichnung ist bereits gestartet. Falls Du erneut beginnen willst, musst zu erst die gestartete Aufzeichnung abbrechen.")
    return
  end
  self.data.recording = {path={node}}
  self:create_recording_aliases()
  self:create_recording_keys()
  self:register_event(
    "recording",
    "gmcp.MG.room.info", 
    function()
      local node = WayFinder:get_node()
      if node then
        table.insert(WayFinder.data.recording.path, node)
      end
    end
  )
  self:info("Wegaufzeichnung gestartet.")
end

function WayFinder:create_recording_aliases()
  self:kill_recording_aliases()
  local alias_ids = table.get(self, "data.recording.alias_ids", {})
  for input,action in pairs(WayFinder.data.aliases) do
    table.insert(alias_ids, tempAlias(f("^{input}$"), f("WayFinder:add_action('{action}')")))
  end
end

function WayFinder:create_recording_keys()
  -- bind keypad keys to directions to allow fast
  -- moving using the keypad
  self:kill_recording_keys()
  local keybinds = {
    ["7"]="nordwest", ["8"]="nord", ["9"]="nordost",
    ["4"]="west",                   ["6"]="ost",
    ["1"]="suewest",  ["2"]="sued", ["3"]="sueost",
  }
  local keypad, control, alt = mudlet.keymodifier.Keypad, mudlet.keymodifier.Control, mudlet.keymodifier.Alt 
  local key_ids = table.get(self, "data.recording.key_ids", {})
  for key, dir in pairs(keybinds) do
    local short_dir = table.get(self.data, {"aliases", f"{dir}en"}) or f"{dir}en"
    table.insert(key_ids, tempKey(keypad, mudlet.key[key], f"WayFinder:add_action('{short_dir}')"))
    table.insert(key_ids, tempKey(keypad+control, mudlet.key[key], f"WayFinder:add_action('{dir}oben')"))
    table.insert(key_ids, tempKey(keypad+alt, mudlet.key[key], f"WayFinder:add_action('{dir}unten')"))
  end
  
  -- key binding for up movement
  table.insert(key_ids, tempKey(keypad, mudlet.key.Minus, "WayFinder:add_action('ob')"))
  -- key binding for down movement
  table.insert(key_ids, tempKey(keypad, mudlet.key.Plus, "WayFinder:add_action('u')"))
  -- key binding for leave movement
  table.insert(key_ids, tempKey(keypad, mudlet.key.Asterisk, "WayFinder:add_action('raus')"))
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>WS_REC_stop</name>
				<packageName></packageName>
				<script>function WayFinder:stop()
  if not self.data.recording then
    self:warn("Es ist keine Wegaufzeichnung gestartet worden.")
    return
  end
  local path = self.data.recording.path
  if path[len(path)].type ~= "#node" then
    if gmcp.MG.room.info.id then
      self:warn({
        "Die Wegaufzeichnung muss an einem Knoten enden. Erstelle einen Knoten mit", 
        {"#WAnode &lt;name&gt; &lt;title&gt;", "y"},
        "\nDieser wird der Aufzeichnung automatisch hinzugefuegt und du kannst diese beenden."})
    else
      self:warn({"Die Wegaufzeichnung endet in einem Raum-ID-freien Raum.",
        "Mit",
        {"#WAnode &lt;name&gt; &lt;title&gt;", "y"},
        "wird der Knoten automatisch der Aufzeichnung hinzugefuegt und falls nicht vorhanden, erstellt.",
        "Willst du sicher gehen, dass es ein bereits existenter Knoten ist, dann kannst du mit",
        {"#WSfind &lt;name&gt;", "y"},
        "danach suchen."})
    end
    return
  end
  self:save_new_path()
  self.data.recording = nil
  self:kill_recording_aliases()
  self:kill_recording_keys()
  self:kill_event("recording")
end

function WayFinder:abort()
  if not self.data.recording then
    self:warn("Es ist keine Wegaufzeichnung gestartet worden.")
    return
  end
  self.data.recording = nil
  self:kill_recording_aliases()
  self:kill_recording_keys()
  self:kill_event("recording")
  self:info("Die Wegaufzeichnung wurde abgebrochen")
end

function WayFinder:kill_recording_aliases()
  local alias_ids = table.get(self, "data.recording.alias_ids")
  if alias_ids then
    table.apply(alias_ids, killAlias)
    table.set(self, "data.recording.aliases", {})
  end
end

function WayFinder:kill_recording_keys()
  local key_ids = table.get(self, "data.recording.key_ids")
  if key_ids then
    table.apply(key_ids, killKey)
    table.set(self, "data.recording.key_ids", {})
  end
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>WS_REC_add_step</name>
				<packageName></packageName>
				<script>function WayFinder:add_step(step)
  local recording = table.get(self, "data.recording")
  if recording then
    local path = recording.path
    local prev = path[len(path)]
    -- if new and previous step have the same type, combine them
    -- type = dopath,trigger,blocker,wait
    if step.type == prev.type then
      for key, value in pairs(step) do
        if type(value) == "table" then
          prev[key] = table.n_flatten({prev[key], value})
        else
          prev[key] = value
        end
      end
    else
      table.insert(path, step)
    end
    return true
  else
    self:warn("Es ist keine Wegaufzeichnung aktiv.")
    return false
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>WS_REC_step_types</name>
				<packageName></packageName>
				<script>function WayFinder:add_action(action)
  if self:add_step({type = "#dopath", substeps={action}}) then
    self:info(f"Die Aktion '{action}' wurde der Aufzeichnung hinzugefuegt")
    send(action)
  end
end


function WayFinder:add_wait(time)
  if self:add_step({type = "#wait", time = tonumber(time)}) then
    self:info(f"Eine Wartezeit von {time} Sekunden ist registriert.")
  end
end

function WayFinder:add_trigger(name, actions)
  local tr = findItems(name, "trigger", true, false)
  if len(tr) == 0 then
    self:warn(f"Es gibt keinen Trigger mit dem Namen '{name}'.")
    return
  elseif len(tr) &gt; 1 then
    self:warn(f"Der Name '{name}' ist fuer Trigger nicht eindeutig.")
    return
  end
  local trigger = {type = "#trigger", names = {name}, actions=actions}
  
  if self:add_step(trigger) then
    local desc = {f"Trigger mit den Namen {name} ist/sind registriert."}
    if actions then
      table.insert(
        desc, f"\nAusserdem werden die folgenden Ausloeser hinzugefuegt:"
      )
      for i, action in pairs(actions) do
        table.insert(desc, f"\n{i}) {action}")
      end
    end
    self:info(desc)
  end
end

function WayFinder:add_blocker(name, cuddle, death)
  local titled_name = string.title(name)

  local _, cuddle_words = cuddle:gsub("%w+", "")
  cuddle = cuddle_words == 1 and f"Du knuddelst {cuddle} {titled_name}." or cuddle
  
  local _, death_words = death:gsub("%w+", "")
  death = death_words == 1 and f"{string.title(death)} {titled_name} faellt tot zu Boden." or death

  if self:add_step(
    {type = "#blocker", names = {name}, cuddle_subtext = {cuddle}, death_subtext = {death}}
  ) then
    self:info(f"Blocker mit Namen '{name}'\nKnuddel-Text '{cuddle}'\nTodes-Meldung '{death}'\nhinzugefuegt")
  end
end

function WayFinder:add_path_condition(field, value)
  local condition = self:create_base_condition(field, value)
  if not condition then
    return
  end
  condition.type = "#condition"
  if self:add_step(condition) then
    self:info(f"Bedingung {field}={rvalue} hinzugefuegt.")
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>WS_REC_process_record</name>
				<packageName></packageName>
				<script>local function add(edge)
  local ex_edge_id = table.get(
    WayFinder.data, {"neighbour", edge.start_node, edge.end_node})
  if ex_edge_id then
    WayFinder:warn({
      f"Es gibt bereits einen Pfad von '{edge.start_node}' nach '{edge.end_node}' mit der ID {ex_edge_id}.",
      "Dieser Pfad wird ignoriert. Loesche alten Pfad um einen Neuen anzulegen."})
    return false
  elseif edge.start_node == edge.end_node then
    WayFinder:warn(f"Der direkte Rundweg von und nach '{edge.start_node}' wird ignoriert.")
    return false
  elseif len(edge.path) == 0 then
    WayFinder:warn(f"Zwei aufeinanderfolgende Knoten ohne Bewegung von '{edge.start_node}' nach '{edge.end_node}' unmoeglich. Loesche Aufzeichnung.")
    return false
  end
  
  edge.weight = WayFinder:compute_weight(edge.path)
  local eid = table.maxn(WayFinder.data.edges)  + 1
  WayFinder.data.edges[eid] = edge
  table.set(WayFinder.data, {"neighbour", edge.start_node, edge.end_node}, eid)
  WayFinder:info(f"Ein Pfad von '{edge.start_node}' nach '{edge.end_node}' mit der ID {edge_id} gespeichert.")
end

local function update_condition(basic, new_cond)
  for key, value in pairs(new_cond) do
    if type(value) == "number" then
      basic[key] = (basic[key] or 0) + value
    elseif type(value) == "table" then
      local cond = table.get(basic, key, {})
      for _, v in pairs(value) do
        table.add(cond, v)
      end
    end      
  end
end

function WayFinder:save_new_path()
  local path = table.get(self, "data.recording.path")
  if not path then
    self:warn("Es ist keine Wegaufzeichnung vorhanden, die gespeichert werden kann.")
    return
  end
  local edges = table.get(self, "data.edges", {})
  local edge_id = table.maxn(edges) + 1
  local edge
  for _,step in pairs(path) do
    if step.type == "#node" then
      if edge then
        edge.end_node = step.name
        add(edge)
      end
      edge = {start_node=step.name, path={}, condition={}}
    elseif step.type == "#condition" then
      step.type = nil
      update_condition(edge.condition, step)
    else
      table.insert(edge.path, step)
    end
  end
  --WayFinder:save_game()
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>WS_REC_show</name>
				<packageName></packageName>
				<script>function WayFinder:show_recording()
  local recording = table.get(self.data, "recording")
  
  if not recording then
    self:warn("Es gibt gerade keine aktive Wegaufzeichnung!")
    return
  end

  self:display_edge(recording)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>WS_REC_edit</name>
				<packageName></packageName>
				<script>function WayFinder:del_steps(number)
  local path = table.get(self.data, "recording.path")
  
  if number &lt; 0 then
    self:warn(f"Die Anzahl {number} ist nicht zulaessig.")
    return
  elseif not path then
    self:warn("Es gibt gerade keine aktive Wegaufzeichnung!")
    return
  elseif len(path) == 0 then
    self:warn("Die Wegaufzeichnung hat gar keine Schritte mehr! Abbruch!")
    self:abort()
    return
  elseif len(path) == 1 then
    self:warn("Du kannst den letzten Eintrag, den Anfangsknoten, nicht loeschen. Falls du das willst, dann breche mit #WAabort ab.")
    return
  end
  
  local last_step = path[len(path)]
  if last_step.type == "#dopath" then
    local size = len(last_step.substeps)
    if number &gt; size then
      self:warn(f"Es ist unzulaessig mehr Schritte ({number}) zu entfernen als das letzte #dopath besitzt ({size}).")
      return
    elseif number == size then
      table.remove(path, len(path))
      self:info(f"Der letzte Schritt vom Typ {last_step.type} wurde entfernt.")    
    else
      local new_substeps = {}
      for _=1,number do
        table.remove(last_step.substeps, len(last_step.substeps))
      end
      self:info(f"Die letzten {number} Schritte von #dopath wurden entfernt")
    end
  elseif number &gt; 1 then
    self:warn(f"Der letzte Schritt ist vom Typ {last_step.type} und muss mit der Anzahl 1 komplett geloescht werden.")
    return
  else
    table.remove(path, len(path))
    self:info(f"Der letzte Schritt vom Typ {last_step.type} wurde entfernt.")
  end
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
