<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage />
	<TimerPackage>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>test_install_status</name>
			<script>if MundronInstaller and MundronInstaller.done then
  disableTimer("test_install_status")
else
  disableTimer("test_install_status")
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.000</time>
		</Timer>
		<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>error_display</name>
			<script>local function centralize(text, space)
  if string.fill ~= nil then
    return string.fill(text, space)
  else
    return text
  end
end

if MundronInstaller and MundronInstaller.errors and #MundronInstaller.errors &gt; 0 then
  print("&lt;255,155,0:0,0,0&gt;" .. centralize("Es wurden folgende Fehler identifiziert", "="))
  for i, err in ipairs(MundronInstaller.errors) do
    print("&lt;255,155,0:0,0,0&gt;"..centralize(f"Fehler {i}", "-"))
    print(f"{err}\n")
  end
  print("&lt;255,155,0:0,0,0&gt;"..centralize("Die Fehlermeldungen werden nach einer Minute wiederholt", "="))
  print("&lt;255,155,0:0,0,0&gt;"..centralize("Bitte Fehler beheben und Profile neu starten", "="))
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:01:00.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>test_install_status</name>
			<script>if MundronInstaller and MundronInstaller.done then
  disableTimer("test_install_status")
else
  disableTimer("test_install_status")
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.000</time>
		</Timer>
		<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>error_display</name>
			<script>local function centralize(text, space)
  if string.fill ~= nil then
    return string.fill(text, space)
  else
    return text
  end
end

if MundronInstaller and MundronInstaller.errors and #MundronInstaller.errors &gt; 0 then
  print("&lt;255,155,0:0,0,0&gt;" .. centralize("Es wurden folgende Fehler identifiziert", "="))
  for i, err in ipairs(MundronInstaller.errors) do
    print("&lt;255,155,0:0,0,0&gt;"..centralize(f"Fehler {i}", "-"))
    print(f"{err}\n")
  end
  print("&lt;255,155,0:0,0,0&gt;"..centralize("Die Fehlermeldungen werden nach einer Minute wiederholt", "="))
  print("&lt;255,155,0:0,0,0&gt;"..centralize("Bitte Fehler beheben und Profile neu starten", "="))
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:01:00.000</time>
		</Timer>
	</TimerPackage>
	<AliasPackage />
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>MI_init_Core</name>
			<packageName></packageName>
			<script>GT = GT or {index=1}
print(f"Install position Install_Mundron_Skripte: {GT.index}")
GT.index = GT.index + 1

-----------------------------------------------------
-- initialize configuration
-----------------------------------------------------

function MI_init_Core()
  return MundronInstaller or {
    meta = {
      version = "1.0.0"
    },
    config = {
      prio = {["Mundron_Core"] = -1, ["GUI"] = 2, ["Wegeskript"] = 2, ["PrivateMisc"] = 3}
    },
    state = {
      loaded = false
    },
    data = {
      installed = {},
      migration = {},
      count = 0
    }
  }
end

setModulePriority("Install_Mundron_Skripte", -100)
MundronInstaller = MI_init_Core()</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>MI_basic_functions</name>
			<packageName></packageName>
			<script>-----------------------------------------------------
-- basics
-----------------------------------------------------

function MundronInstaller.get_repo_path(obj, parent)
  local path_table = string.split(getModulePath("Install_Mundron_Skripte"), "/")
  local result = table.concat(path_table, "/", 1, #path_table - 1 - (parent or 0))
  if obj then
    result = f"{result}/{obj}"
  end
  return result
end

function MundronInstaller:get_profile_data_path()
  return f"{getMudletHomeDir()}/data"
end

function MundronInstaller.read_json(path)
  local file, err = io.open(path, "r")
  local result = {}
  if file then
    local content = file:read("*all")
    result = yajl.to_value(content)
    file:close()
  else
    printError(f"Failed to open file {path}: {err}", true, true)
  end
  return result
end

function MundronInstaller.save_json(data, path)
  local file, err = io.open(path, "w+")
  if file then
    file:write(yajl.to_string(data))
    file:close()
  else
    printError(f"Failed to open file {path}: {err}", true, true)
  end
end
-----------------------------------------------------
-- profile migration status
-----------------------------------------------------

function MundronInstaller:get_profile_migration_filename()
  return f"{getMudletHomeDir()}/data/Install_Mundron_Skripte.json"
end

function MundronInstaller:get_profile_migration_status()
  return self.read_json(
    self:get_profile_migration_filename()
  ).profile_migration_completed or false
end

function MundronInstaller:set_profile_migration_status(completed)
  self.state.profile_migration_completed = completed
  self.save_json(
    {profile_migration_completed = completed}, 
    self:get_profile_migration_filename()
  )
end

-----------------------------------------------------
-- game migration status
-----------------------------------------------------

function MundronInstaller:get_game_migration_filename()
  return self.get_repo_path("data/Install_Mundron_Skripte.json")
end

function MundronInstaller:get_game_migration_status()
  return self.read_json(self:get_game_migration_filename()).game_migration_completed or false
end

function MundronInstaller:set_game_migration_status(completed)
  self.state.game_migration_completed = completed
  self.save_json({game_migration_completed = completed}, self:get_game_migration_filename())
end

function MundronInstaller.iprint(text)
  decho(f("&lt;120,170,255:0,0,0&gt;INFO (Installer)"))
  echo(f(" {text}\n"))
end

function MundronInstaller.print_migration(key, v1, v2, d1, d2, mapping)
  local d1 = d1 or "geloescht"
  local d2 = d2 or "migriert"
  print(f("{key} Migration: {v1}/{v2} {d1}/{d2}"))
  if mapping then
    local i = 0
    for k,v in pairs(mapping) do
      i = i+1
      print(f"{i}) {k} -&gt; {v}")
    end
  end
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>MI_bootstrap_profile_migration</name>
			<packageName></packageName>
			<script>MundronInstaller.data.profile = {
  movable = {
    ["Charakter_Einstellungen.json"] = "PLAYER.json",
    ["MainGUI_setting.json"] = "MainGUI.json",
    ["EK_Liste.jsonl"] = "EK_Kills.jsonl",
    ["Zaubertraenke.txt"] = "Zaubertraenke_gefunden.txt",
    ["Plaketten.jsonl"] = "EK_Plakettenvergleich.jsonl",
    ["pwt_diebe_trace.json"] = "EK_diebe_trace.json"
  },
  movable_pattern = {
    ["Wegeskript_.*_nutzbare_Portale.json"] = "WS_nutzbare_Portale.json",
    ["Zaubertraenke_History_.*.csv"] = "Zaubertraenke_History.csv"
  },
  deprecated = {
    ["Charakter_settings.txt"] = true,
    ["Einstellungen.txt"] = true,
    ["GUI_setting.txt"] = true,
    ["MainGUI_setting.txt"] = true,
    ["Plaketten_Liste.csv"] = true,
    ["init_GUI"] = true,
    ["init_PLAYER"] = true
  },
  deprecated_pattern = {}
}

function MundronInstaller:bootstrap_profile_migration()
  if self:get_profile_migration_status() then
    self.iprint("Profildateien Migration bereits erledigt")
    return
  end
  self.iprint("Starte Profildatenmigration")
  
  local dcount, mcount = self:generic_file_move(
    getMudletHomeDir(), f"{getMudletHomeDir()}/data", "profile"
  )
  
  self.print_migration("Profildateien", dcount, mcount, "geloescht(veraltet)", "migriert", self.data.migration["profile"])
  self:set_profile_migration_status(true)
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>MI_bootstrap_game_migration</name>
			<packageName></packageName>
			<script>local data_dir = MundronInstaller.get_repo_path("data")

MundronInstaller.data.game = {
  movable = {
    ["Zaubertraenke.txt"] = "Zaubertraenke.txt"
  },
  movable_pattern = {
    [".*_NPC_Liste.jsonl"] = "EK_NPC_liste.jsonl",
    [".*_pwt_diebe_ids.jsonl"] = "EK_pwt_diebe_ids.jsonl",
    [".*_pwt_diebe_liste.jsonl"] = "EK_pwt_diebe_liste.jsonl",
    ["Wegeskript_.*_Aliases.txt"] = "WS_Aliases.txt",
    ["Wegeskript_.*_Gags.txt"] = "WS_Gags.txt",
    ["Wegeskript_.*_Kanten.jsonl"] = "WS_Kanten.jsonl",
    ["Wegeskript_.*_Knoten.jsonl"] = "WS_Knoten.jsonl"
  },
  deprecated = {
    ["EK_Tracker_help.jsonl"] = true,
    ["Plaketten_Liste.csv"] = true,
    ["Zaubertraenke_temp.txt"] = true,
    ["pathscript_backup_date.txt"] = true
  },
  deprecated_pattern = {
    "EK_Liste.*.csv",
    "WS_.*_backup.jsonl",
    "Wege.*.txt",
    "log_pathfinder-build.*"
  }
}

function MundronInstaller:game_migration_from(source_path)
  self.iprint(f"Suche nach Spieldateien in {source_path}")
  
  local dcount, mcount = self:generic_file_move(source_path, data_dir, "game")
  
  if mcount &gt; 0 then
    self.iprint(f"Erfolgreich Spieldateien aus {source_path} migriert")
  end
  self:set_game_migration_status(mcount &gt; 0)
  return dcount, mcount
end

function MundronInstaller:bootstrap_game_migration()
  if self:get_game_migration_status() then
    self.iprint("Spieldateien Migration bereits erledigt.")
    return
  end
  
  self.iprint("Starte Spieldatenmigration")
  
  local pathes = {
    self.get_repo_path("MG_tools_public", 1), -- predicted old repo path
    self.get_repo_path("MG_tools", 1),
    self.get_repo_path(), -- look into repo path
  }
  local dcount, mcount = 0, 0
  
  for _, path in ipairs(pathes) do
    dcount, mcount = self:game_migration_from(path)
    if self:get_game_migration_status() then
      break
    end
  end
  
  if not self:get_game_migration_status() then
    self.iprint("Migration der Spieldateien fehlgeschlagen! Bitte README lesen und neu versuchen.")
  else
    self.print_migration("Spieldatei", dcount, mcount, "geloescht(veraltet)", "migriert", self.data.migration["game"])
  end
end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>MI_bootstrap_collect_modules</name>
			<packageName></packageName>
			<script>function MundronInstaller:bootstrap_collect_modules()
  local deprecated = {"Privat_alle", "private_klerus", "Wegeskript_v2"}
  self.iprint("Pruefe installierte Module.")
  local count_deleted = 0
  self.data.installed = {}
  for index, name in ipairs(getModules()) do
    local text = f"{index}) {name}"
    if table.contains(deprecated, name) then
      uninstallModule(name)
      text = f"{text} -&gt; wird geloescht, da veraltet"
    else
      self.data.installed[name] = getModulePath(name)
    end
    print(text)
  end
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>MI_bootstrap_add_new_modules</name>
			<packageName></packageName>
			<script>function MundronInstaller:bootstrap_upsert_modules()
  self.iprint("Durchsuche Repository nach Modulen")
  local repo = self.get_repo_path()
  local count_migration, count_installed = 0, 0
  for entry in lfs.dir(repo) do
    if entry:find("module") then
      local subdir = f"{repo}/{entry}"
      local ci, cm = self:upsert_modules_at_path(subdir)
      count_migration = count_migration + cm
      count_installed = count_installed + ci
    end
  end
  self.print_migration("Modul", count_installed, count_migration, "installiert", "migriert")
end

function MundronInstaller:upsert_modules_at_path(path)
  -- collect modules to install/migrate with corresponding
  -- priority to install them in priority order
  local upsert_in_order = {}
  
  local function add(name, module_path, replace)
    local prio = self.config.prio[name] or 0
    if upsert_in_order[prio] == nil then
      upsert_in_order[prio] = {}
    end
    table.insert(upsert_in_order[prio], {name, module_path, replace})
  end
  
  --self.iprint(f("Durchsuche Pfad {path}"))
  for entry in lfs.dir(path) do
    if entry:find("%.xml$") then
      local name = entry:gsub("%.xml$", "")
      -- self.iprint(f("Modul {entry} gefunden und Check sagt {self.data.installed[name]}"))
      local module_path = f"{path}/{entry}"
      if self.data.installed[name] ~= module_path then
        add(name, module_path, self.data.installed[name] ~= nil)
      end
    end
  end
  
  if not upsert_in_order then
    return 0, 0
  end
  
  local installed, migrated = 0, 0
  local prios = table.keys(upsert_in_order)
  table.sort(prios)
  -- install modules to install/migrate in prio order
  for _, prio in ipairs(prios) do
    for _, upsert in ipairs(upsert_in_order[prio]) do
      local name, module_path, replace = unpack(upsert)
      if replace then
        self.iprint(f"Entferne altes Modul {name}")
        uninstallModule(name)
        migrated = migrated + 1
      else
        installed = installed + 1
      end
      self.iprint(f("Installiere Modul {name} aus dem Verzeichnis {path}"))
      installModule(module_path)
      self.iprint(f("Setze Priority auf {prio}"))
      setModulePriority(name, prio)
      enableModuleSync(name)
      self.data.installed[name] = module_path
    end
  end
  
  return installed, migrated
end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>MI_install_modules</name>
			<packageName></packageName>
			<script>function MI_install_modules(_, module_name)
  if module_name ~= "Install_Mundron_Skripte" or MundronInstaller.state.loaded then
    return
  end
  MundronInstaller:bootstrap_profile_migration()
  MundronInstaller:bootstrap_game_migration()
  
  MundronInstaller:bootstrap_collect_modules()
  MundronInstaller:bootstrap_upsert_modules()
  
  MundronInstaller.state.loaded = true
  MundronInstaller.iprint("Ueberpruefung der installierten Module abgeschlossen.")
end</script>
			<eventHandlerList>
				<string>sysInstallModule</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>MI_generic_file_move</name>
			<packageName></packageName>
			<script>function MundronInstaller:get_categorizer(storage)
  -- Move files:
  -- mv = {&lt;old name&gt;=&lt;new name&gt;}, mv_pat = {&lt;old name pattern&gt;=&lt;new name&gt;}
  -- Delete deprecated files:
  -- de = {&lt;old name&gt;=true}, de_pat = {&lt;old name pattern&gt;}
  return function(filename)
    local mapping = self.data[storage]
    local new_filename = mapping["movable"][filename]
    if new_filename then
      return 1, new_filename
    end
    if mapping["deprecated"][filename] then
      return -1, nil
    end
    for pattern, new_filename in pairs(mapping["movable_pattern"]) do
      if filename:match(pattern) then
        return 1, new_filename
      end
    end
    for _, pattern in pairs(mapping["deprecated_pattern"]) do
      if filename:match(pattern) then
        return -1, nil
      end
    end
    return 0, nil -- some Mudlet file, ignore it
  end
end

function MundronInstaller:get_mover(source_path, target_path, storage)
  return function(source_name, target_name)
    local storage = storage or "default" 
    local source = f"{source_path}/{source_name}"
    local target = f"{target_path}/{target_name}"
    if io.exists(target) then
      local ok, err = os.remove(target)
      if not ok then
        printError(f"Failed to remove target {target}: {err}", true, true)
      end
    end
    local ok, err, code = os.rename(source, target)
    if not ok then
      printError(f"Error in move {source} to {target} with (err={err}, code={code})", true, true)
    end
    if not self.data.migration[storage] then
      self.data.migration[storage] = {}
    end
    self.data.migration[storage][source_name] = target_name
    return true
  end
end

function MundronInstaller:generic_file_move(source_path, target_path, storage)
  if not lfs.attributes(target_path, "mode") then
    lfs.mkdir(target_path)
  end
  local move_file = self:get_mover(source_path, target_path, storage)
  local categorize_file = self:get_categorizer(storage)
  
  local dcount, mcount = 0, 0
  local ok, iter, state, var = pcall(lfs.dir, source_path)
  if not ok then
    printError(f"lfs.dir failed: {tostring(iter)}", true, true)
  end
  
  for entry in iter, state, var do
    local code, new_entry = categorize_file(entry)
    if code == 1 then
      mcount = mcount + 1
      move_file(entry, new_entry)
    elseif code == -1 then
      dcount = dcount + 1
      local entry_path = f"{source_path}/{entry}"
      local ok, err = os.remove(entry_path)
      if not ok then
        printError(f"Failed to remove deprecated file {entry_path}: {err}", true, true)
      end
    end
  end
  return dcount, mcount
end</script>
			<eventHandlerList />
		</Script>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
